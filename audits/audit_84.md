# Audit Report

## Title
Backward Clock Adjustments Invalidate Legitimate Email Certificates, Causing Temporary Denial of Service

## Summary
The email certificate validation system creates a time synchronization dependency between client-side certificate issuance and blockchain-side verification. When the blockchain's consensus time is adjusted backwards (due to NTP synchronization, manual correction, or clock drift), legitimate certificates generated before the adjustment are rejected as "from the future," temporarily preventing users from accessing critical email-based authentication operations. [1](#0-0) [2](#0-1) 

## Impact
Medium

## Finding Description

**Location:** The vulnerability exists in the certificate validation logic in `lib/src/crypto/email_cert.rs`, specifically in the `EmailCert::verify()` function (lines 84-116), and affects all three HTTP endpoints that rely on email certificate authentication: [3](#0-2) [4](#0-3) [5](#0-4) 

**Intended Logic:** Email certificates should be validated within a 5-minute validity window to prevent replay attacks while allowing legitimate users to authenticate. The system should accept certificates that were recently generated by the client.

**Actual Logic:** The certificate validation performs a strict forward-only time check where it rejects any certificate with a timestamp greater than the blockchain's current time: [2](#0-1) 

The problem arises because:
1. Certificates are issued using the client's local `SystemTime::now()` 
2. Verification happens using blockchain's `ctx.current_time()`
3. If the blockchain time is adjusted backwards after certificate issuance, the certificate timestamp appears to be "in the future"

**Exploit Scenario:**
1. Blockchain consensus time is initially at T = 12:10:00
2. User generates an email certificate at T-1 minute = 12:09:00 (within normal operation)
3. Before the user submits the certificate, the blockchain's clock is adjusted backwards to 12:08:00 (e.g., due to NTP correction or manual adjustment to fix clock drift)
4. User submits the certificate to any of the three endpoints
5. Verification checks: `cert_time (12:09:00) > blockchain_time (12:08:00)`
6. The certificate is rejected with `CertificateFromFuture` error
7. User cannot complete their operation despite having a legitimately issued certificate

**Security Failure:** The system violates the availability invariant by preventing legitimate users from accessing critical authentication operations. Users cannot:
- Perform VDRF evaluations to generate email hashes
- Upload MSK records for email-to-account associations  
- Retrieve their stored secret shares

The error mapping shows these are treated as client errors (HTTP 400), providing no recovery mechanism: [6](#0-5) 

## Impact Explanation

**Affected Operations:**
- All three email certificate-dependent endpoints are affected
- Users attempting email-to-account association are locked out
- Users attempting secret recovery are denied access to their stored data
- The 5-minute validity window means users must wait and retry with a new certificate

**Severity of Damage:**
- Temporary denial of service for email-based authentication
- Users cannot access their secrets during the lockout period
- In scenarios with persistent clock drift or repeated adjustments, users could face prolonged inability to access critical operations
- This affects legitimate users during normal protocol operation, not just edge cases

**System Reliability Impact:**
The test suite reveals that developers are aware of this timing issue, as they explicitly add a 2-minute buffer to avoid it: [7](#0-6) 

However, this buffer only helps in the test environment and does not protect against backward clock adjustments in production, which can invalidate certificates that were valid at issuance time.

## Likelihood Explanation

**Triggering Conditions:**
- Any user can be affected during normal operation
- Requires blockchain clock to be adjusted backwards while users have in-flight or recently generated certificates
- Clock adjustments are common in distributed systems (NTP sync corrections, manual adjustments, leap second handling)

**Frequency:**
- In systems with clock drift monitoring and NTP synchronization, backward adjustments occur regularly
- Users with certificates generated within minutes of an adjustment are affected
- Given the short 5-minute validity period, the window of vulnerability is continuous
- Multiple users could be simultaneously affected if a blockchain-wide clock adjustment occurs

**Realistic Scenarios:**
- NTP daemon corrects clock drift that accumulated over time
- Manual correction of misconfigured blockchain node clocks  
- Time zone or daylight saving time adjustments (if improperly handled)
- Recovery from clock skew after network partitions

## Recommendation

Implement a tolerance window for certificate timestamps to account for clock drift and adjustments:

1. **Add a grace period for future timestamps:** Instead of strictly rejecting certificates from the future, allow a small tolerance (e.g., 2-5 minutes) to accommodate reasonable clock differences:

```rust
// In EmailCert::verify(), replace the future check:
const FUTURE_TOLERANCE: Duration = Duration::from_secs(2 * 60); // 2 minutes

if ts > now + FUTURE_TOLERANCE {
    return Err(SwafeError::CertificateFromFuture);
}
```

2. **Extend the validity period:** Consider increasing the `VALIDITY_PERIOD` from 5 minutes to 10 minutes to reduce the impact of clock synchronization issues: [8](#0-7) 

3. **Add certificate caching:** Implement a mechanism to cache recently validated certificates for a brief period, preventing repeated rejections if the same certificate is retried shortly after a clock adjustment.

4. **Improve error handling:** Return a more informative error that suggests clock synchronization issues and prompts users to retry with a fresh certificate.

## Proof of Concept

**File:** `lib/src/crypto/email_cert.rs` (add to the existing `tests` module)

**Test Function:** `test_backward_clock_adjustment_breaks_certificate`

```rust
#[test]
fn test_backward_clock_adjustment_breaks_certificate() {
    let mut rng = thread_rng();
    
    // Setup: Generate keys and certificate authority
    let swafe_keypair = sig::SigningKey::gen(&mut rng);
    let swafe_pk = swafe_keypair.verification_key();
    let user_keypair = sig::SigningKey::gen(&mut rng);
    let user_pk = user_keypair.verification_key();
    let email = "user@example.com".to_string();
    let node_id = "node:test".parse().unwrap();
    
    // Simulate blockchain time at T = 12:10:00
    let blockchain_time_initial = SystemTime::now();
    
    // User generates certificate at current time (simulating T = 12:09:00 relative to blockchain)
    let cert = EmailCert::issue(&mut rng, &swafe_keypair, &user_pk, email.clone());
    let token = EmailCert::token(&mut rng, &cert, &user_keypair, &node_id);
    
    // Verification succeeds with normal blockchain time
    assert!(EmailCert::verify(&swafe_pk, &node_id, &token, blockchain_time_initial).is_ok());
    
    // Trigger: Simulate backward clock adjustment (blockchain adjusted 2 minutes backwards)
    let blockchain_time_adjusted = blockchain_time_initial - Duration::from_secs(120);
    
    // Observation: Certificate is now rejected as "from the future"
    let result = EmailCert::verify(&swafe_pk, &node_id, &token, blockchain_time_adjusted);
    
    match result {
        Err(SwafeError::CertificateFromFuture) => {
            // This confirms the vulnerability: legitimate certificate rejected due to clock adjustment
            println!("Vulnerability confirmed: Legitimate certificate rejected after backward clock adjustment");
        }
        Ok(_) => {
            panic!("Expected CertificateFromFuture error but verification succeeded");
        }
        Err(e) => {
            panic!("Unexpected error type: {:?}", e);
        }
    }
}
```

**Setup:** The test creates a valid certificate during normal operation when blockchain time and client time are synchronized.

**Trigger:** The blockchain's consensus time is adjusted backwards by 2 minutes, simulating a clock correction or NTP synchronization event.

**Observation:** The certificate that was valid before the adjustment is now rejected with `CertificateFromFuture` error, demonstrating that backward clock adjustments break legitimate certificates and prevent users from accessing critical operations.

### Citations

**File:** lib/src/crypto/email_cert.rs (L7-7)
```rust
const VALIDITY_PERIOD: Duration = Duration::from_secs(5 * 60);
```

**File:** lib/src/crypto/email_cert.rs (L52-55)
```rust
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_secs();
```

**File:** lib/src/crypto/email_cert.rs (L101-104)
```rust
        // Check if certificate is from the future
        if ts > now {
            return Err(SwafeError::CertificateFromFuture);
        }
```

**File:** contracts/src/http/endpoints/association/vdrf/eval.rs (L40-45)
```rust
    let (email, _) = EmailCert::verify(
        &swafe_public_key,
        &node_id,
        &request.token.0,
        ctx.current_time(),
    )?;
```

**File:** contracts/src/http/endpoints/association/get_secret_share.rs (L43-43)
```rust
    let (email, _) = EmailCert::verify(&swafe_pk, &node_id, &request.token.0, ctx.current_time())?;
```

**File:** contracts/src/http/endpoints/association/upload_msk.rs (L54-55)
```rust
    let (email, user_pk) =
        EmailCert::verify(&swafe_pk, &node_id, &request.token.0, ctx.current_time())?;
```

**File:** contracts/src/http/error.rs (L75-76)
```rust
                SwafeError::CertificateExpired => 400,
                SwafeError::CertificateFromFuture => 400,
```

**File:** contracts/java-test/src/test/java/com/partisia/blockchain/contract/SwafeContractTest.java (L110-112)
```java
    // setup block time 2 min later to ensure that the email certificate time is not greater than
    // the block time.
    resetSystemTime(120000L);
```
