questions = [
    # 1. Complete Absence of Authorization
    "Can an unprivileged attacker enumerate all accounts by systematically querying account IDs derived from known verification keys?",
    "Can a network adversary extract email-to-account associations by correlating timing of account queries with VDRF evaluations?",
    "Can a malicious guardian query victim accounts to learn their recovery configurations before attacking?",

    # 2. Privacy Violation Through Full State Exposure
    "Does exposing RecoveryStateV0.assoc (encrypted associations) allow attackers to perform offline cryptanalysis to extract RIK shares?",
    "Can the social backup ciphertext in RecoveryStateV0 be used to infer the number and identity of guardians through metadata analysis?",
    "Does the backups field leak information about what secrets users are storing through ciphertext size or count analysis?",
    "Can the pke encryption key in AccountStateV0 be used to mount chosen-ciphertext attacks against the owner?",

    # 3. Serialization Vulnerabilities
    "Can an attacker provide malformed base64url strings in account_id to cause deserialization panics that crash the endpoint?",
    "Does the StrEncoded deserialization process validate that the decoded AccountId is exactly 32 bytes, or can oversized inputs cause buffer issues?",
    "Can an attacker exploit differences between bincode serialization versions to cause type confusion when deserializing AccountState?",
    "If AccountState schema evolves (e.g., from V0 to V1), can old clients deserialize new states, potentially misinterpreting encrypted fields?",

    # 4. State Consistency & TOCTOU
    "Can an attacker exploit TOCTOU by querying an account, triggering a recovery update, then using stale state to compute invalid guardian shares?",
    "If a user initiates recovery (setting RecoveryStateV0.pke), can querying the old state before the update propagates allow an attacker to submit guardian shares to the wrong encryption key?",
    "Can concurrent queries during account state transitions return inconsistent views (e.g., half-updated backup lists)?",

    # 5. Information Disclosure Through Error Messages
    "Can an attacker use timing differences between 'account not found' vs. successful deserialization to enumerate which account IDs exist?",
    "Does the error response leak whether an account ID is malformed vs. simply non-existent?",
    "Can the HTTP status code (404) be used to confirm whether an email has been associated with an account by deriving the AccountId from potential verification keys?",

    # 6. Lack of Rate Limiting (non-DoS)
    "Can an attacker perform mass surveillance by querying all possible account IDs to map the entire user base?",
    "Does unlimited querying allow an attacker to monitor when accounts are created, updated, or enter recovery mode?",
    "Can an attacker correlate query patterns with blockchain transactions to de-anonymize users?",

    # 7. Missing Cryptographic Binding
    "Can a guardian query another guardian's account to learn their recovery configuration before colluding to attack a mutual user?",
    "Can off-chain nodes (even honest minority) query accounts to extract encrypted MSK ciphertexts for offline attacks?",
    "Can Swafe-io query arbitrary accounts to violate the prohibition against unilateral reconstruction?",

    # 8. AccountState Structure Exposure
    "Can an attacker use the cnt field to track user activity (number of updates) and infer usage patterns?",
    "Does the act (encrypted combined secrets) field's size leak information about the number of old keys being retained?",
    "Can the recover field (backups marked for recovery) be compared across queries to detect when users initiate backup decryption?",
    "Can the rec.pke field's presence (indicating recovery initiation) be monitored to detect when users lose access and attempt recovery?",

    # 9. Versioned Enum Handling
    "If a V1 account state is introduced, can old API clients deserialize it without errors, potentially exposing new sensitive fields?",
    "Can an attacker submit a crafted account update that sets an invalid version number, causing queries to fail and lock out legitimate users?",
    "Does the versioned serialization correctly reject malformed version tags, or can an attacker inject arbitrary enum variants?",

    # 10. Guardian Share Metadata Leakage
    "Can an attacker infer the threshold value t by analyzing the structure or size of the social backup ciphertext?",
    "Can the number of guardian shares (n) be determined from the ciphertext, allowing attackers to identify high-value targets with many guardians?",
    "Can guardian identities be partially inferred by correlating social ciphertext changes with known account updates?",

    # I. Cryptographic Integrity & VDRF Security (1–30)
    "Can the VdrfSecretKeyShare in OffchainSecret be extracted from network traffic or logs during initialization?",
    "Does the VdrfPublicKey properly bind to the corresponding VdrfSecretKeyShare, preventing substitution attacks?",
    "Can an attacker verify whether a VdrfSecretKeyShare corresponds to a valid t-of-n scheme by analyzing VdrfPublicKey alone?",
    "Is the 32-byte randomizer generated with sufficient entropy to prevent predictable VDRF outputs?",
    "Could two nodes accidentally generate identical randomizers, violating randomness assumptions?",
    "Can a compromised node submit an invalid VdrfSecretKeyShare that still passes commitment verification?",
    "If nodes claim different VdrfPublicKeys, can the system detect the inconsistency during initialization?",
    "Can a malicious actor reuse a previously valid VdrfSecretKeyShare for a different node ID?",
    "Does VdrfPublicKey structure leak polynomial degree information about the threshold scheme?",
    "Could a zero-valued VdrfSecretKeyShare break threshold assumptions during initialization?",
    "Can Swafe-io embed weak shares into VDRF keys during key generation to backdoor reconstruction?",
    "Is the randomizer used correctly in downstream VDRF operations to avoid side-channel risks?",
    "Does the initialization process enforce correct share distribution according to threshold?",
    "Can an adversary tamper with VdrfPublicKey during transit before commitment verification?",
    "Does commitment verification properly check all fields: public_key, secret_share, and randomizer?",
    "Can an attacker trick the system into accepting a lower-threshold scheme than required?",
    "Could minority corrupted nodes infer honest nodes' shares through interpolation strategies?",
    "Can inconsistencies between stored and expected OffchainSecret values break VDRF evaluation?",
    "Does the system prevent reusing old OffchainSecret values after key rotation?",
    "Could timing or size of OffchainSecret submissions leak operational information about nodes?",
    "Can an attacker force weaker cryptographic parameters during VDRF initialization?",
    "Are VdrfSecretKeyShare and VdrfPublicKey serialized in canonical form to prevent malleability?",
    "Could Swafe-io provide biased randomizers that degrade VDRF security?",
    "Can invalid partial evaluations poison the final VDRF output?",
    "Does the system verify that VdrfPublicKey is a valid group element before storage?",
    "Does initialization enforce bounds checks on VdrfSecretKeyShare field elements?",
    "What happens if two nodes generate identical randomizers during initialization?",
    "Can the combination of public_key and randomizer link later VDRF outputs to a specific node?",
    "Does the reconstruction process correctly enforce a minimum of t valid shares?",
    "Is the randomizer used with proper domain separation to prevent cross-protocol misuse?",

    # II. Serialization & Encoding Vulnerabilities (31–50)
    "Can malformed base64 in StrEncoded<NodeId> cause deserialization errors that leak information?",
    "Could the separator 'v0:offchain-secret' collide with other tags and cause type confusion?",
    "Can outdated bincode formats allow incompatible OffchainSecret structures to bypass checks?",
    "Could a malicious OffchainSecret deserialize into extremely large memory structures?",
    "Can nested VdrfPublicKey or VdrfSecretKeyShare contain malicious payloads?",
    "Does StrEncoded deserialization safely handle missing or extra base64 padding?",
    "Can malformed UTF-8 in serialized fields create inconsistencies across nodes?",
    "Are there maximum size limits for OffchainSecret to avoid storage exhaustion?",
    "Does the system enforce canonical serialization for OffchainSecret?",
    "Should OffchainSecret contain a version prefix to support future schema upgrades?",
    "Can truncated OffchainSecret payloads deserialize into default/zero values?",
    "Does bincode maintain identical field ordering across all client implementations?",
    "Could future enum tags create type confusion vulnerabilities in OffchainSecret?",
    "Can compressed malicious data bypass size checks during deserialization?",
    "Can special characters in node_id enable encoding injection attacks?",
    "Does the deserializer reject OffchainSecret structures with duplicate fields?",
    "Can large integers in serialized curve points cause overflows?",
    "Are serialized field elements consistent across architectures with different endianness?",
    "Does the randomizer validate exact length (32 bytes) during deserialization?",
    "Could deeply nested serialized structures cause stack overflows during decoding?",

    # III. State Management & Replay Protection (51–70)
    "Can attackers replay a valid initialization request to overwrite existing secrets?",
    "Can concurrent initialization requests for the same node cause inconsistent state?",
    "Is the initialization endpoint idempotent, preventing repeated state changes?",
    "Could partial state remain if initialization fails midway?",
    "Can an attacker trigger a state rollback after initialization?",
    "Are there locks preventing concurrent writes to StoredOffchainSecret?",
    "Does initialization depend on node order, and could reordering break assumptions?",
    "Can attackers bypass the 'already initialized' check by manipulating storage keys?",
    "Does the storage key design prevent nodes overwriting each other's secrets?",
    "Does the contract verify that stored OffchainSecret matches the submitted one?",
    "Could uninitialized node storage be used by other endpoints?",
    "Are expired initialization requests rejected properly?",
    "If protocol upgrades occur, could old secrets be migrated insecurely?",
    "Could multiple Swafe contracts interfere with each other’s initialization?",
    "Can attackers pre-fill storage with malicious data before legitimate initialization?",
    "Is commitment verification and storage atomic, avoiding TOCTOU attacks?",
    "Can secrets be revoked, and could revocation be abused for DoS?",
    "What happens if two nodes claim the same NodeId?",
    "Does querying initialization status leak information about node activity?",
    "Are initialized secrets persisted correctly through upgrades or redeployments?",

    # IV. Privacy & Anonymity Violations (71–90)
    "Does NodeId reveal organizational or geographic information about a node?",
    "Can timing of initialization correlate nodes with user-level activities?",
    "Can VdrfPublicKey be linked to user accounts via on-chain analysis?",
    "If randomizers are deterministic, do they leak setup ceremony structure?",
    "Can packet size or OffchainSecret structure enable traffic analysis?",
    "Does storage layout of OffchainSecret leak which nodes are active?",
    "Can multiple initialization requests from one node be correlated?",
    "Does reusing VdrfPublicKey across accounts leak identity information?",
    "Can on-chain commitments reveal setup ceremony participant behavior?",
    "Does initialization reveal total off-chain node count indirectly?",
    "Does order of node initialization leak operational hierarchy?",
    "Do initialization error messages leak existing node configurations?",
    "Can timing of commitment verification leak secret share values?",
    "Could statistical analysis over many initializations reveal patterns?",
    "Can differences in how nodes serialize OffchainSecret enable fingerprinting?",
    "Do HTTP headers or metadata leak sensitive node identity information?",
    "Can network routes or IPs link nodes to locations?",
    "Can initialization be linked to later VDRF evaluation requests?",
    "Who can query stored OffchainSecret values, and is access restricted?",
    "Can initialization patterns leak data about other co-located protocols?",

    # V. Access Control & Authorization (91–110)
    "Can unprivileged attackers initialize a node without authorization?",
    "Can attackers impersonate nodes by stealing NodeId values?",
    "Can attackers bypass commitment verification with specially crafted OffchainSecret payloads?",
    "Should initialization require multi-party authorization?",
    "Is there verification that the requestor owns the NodeId they claim?",
    "Can Swafe-io maliciously initialize nodes with compromised secrets?",
    "Should guardians approve node initialization to strengthen trust?",
    "Can contract owners bypass checks and inject malicious secrets?",
    "Can operators of one node initialize another node without permission?",
    "Should initialization requests be signed to prevent MITM?",
    "Should node initialization require t-of-n approvals?",
    "Who can revoke secrets, and can revocation be abused?",
    "Is there a hidden administrative backdoor enabling forced initialization?",
    "Can corrupted off-chain nodes initialize themselves with malicious data?",
    "Is the initialization endpoint publicly accessible without controls?",
    "Should initialization require an authentication token?",
    "Should IP whitelisting restrict which hosts may initialize nodes?",
    "Should initialization only occur during specific time windows?",
    "Should nodes prove possession of private keys before initialization?",
    "Can privileges in one Swafe contract affect initialization in another?",

    # VI. Trust Model & Corruption Scenarios (111–130)
    "Can minority corrupted nodes collude to weaken threshold during initialization?",
    "Can Swafe-io manipulate setup ceremony to embed biased or weak shares?",
    "Does corruption of guardians after initialization affect stored secrets?",
    "Does initialization assume t-1 corrupted nodes, and are edge cases handled?",
    "Is setup ceremony treated as trusted, and can compromise cause long-term risks?",
    "If minority node snapshots leak, do secrets remain secure?",
    "Can Swafe-io correlate emails with accounts using initialization metadata?",
    "Could lack of guardian involvement enable recoverability attacks?",
    "Could node offline status cause effective threshold degradation?",
    "Could compromised initialization enable later VDRF reconstruction attacks?",
    "If initialization is compromised, which protocol invariants break?",
    "Should MPC be used to prevent any party from knowing full secrets?",
    "Is the setup ceremony publicly verifiable?",
    "Can node rotation introduce new attack surface in initialization?",
    "Is there an emergency recovery mechanism, and can it be abused?",
    "Can the system detect if initialized secrets are corrupted?",
    "Can threshold be safely increased post-initialization?",
    "Should proactive secret sharing refresh secrets periodically?",
    "Is accountability ensured if initialization fails?",
    "Does trust extend transitively to node operators who may be compromised?",

    # VII. Integration & Interaction Vulnerabilities (131–150)
    "Could mismatches between api/src/init.rs and contract init.rs cause parsing failures?",
    "Can incompatible OffchainSecret formats break VDRF evaluation?",
    "Does the hash used in commitment verification match the one used in commitment generation?",
    "Could OffchainSecret be confused with other tagged types in other modules?",
    "Could version mismatch between API and contract cause silent failures?",
    "Do initialization errors propagate correctly to callers?",
    "Does the VDRF eval endpoint depend on correctly initialized secrets?",
    "Could reconstruction operations fail due to incomplete initialization?",
    "Does compromised initialization break the account recovery invariant?",
    "Can compromised initialization enable unauthorized backup reconstruction?",
    "Does initialization pattern leak email–account associations indirectly?",
    "Could initialization bypass guardian approval requirements?",
    "Is on-chain commitment state always consistent with off-chain secrets?",
    "Could multiple contracts cause cross-initialization interference?",
    "Are secret migrations secure during upgrades?",
    "Could old OffchainSecret formats break later operations?",
    "Does initialization on one blockchain affect others in multi-chain deployments?",
    "Could metadata inside OffchainSecret be tampered with without detection?",
    "Could initialization inconsistencies cause incorrect VDRF proof verification?",
    "Are initialized secrets tested end-to-end across all protocol flows?",

    # --- Serialization & Encoding (10) ---
    "Does the StrEncoded<AccountId> wrapper in the Request struct properly validate that decoded bytes match the expected 32-byte format, or can malformed account IDs bypass validation at the API layer?",
    "Can an attacker craft a malicious base64 string in request.account_id that deserializes to an invalid AccountId, potentially causing panics or undefined behavior in downstream contract code?",
    "Does the StrEncoded<BackupId> deserialization enforce that the backup ID is properly formatted as a 32-byte hash, or can arbitrary bytes be injected?",
    "Can type confusion occur where a StrEncoded<GuardianShare> is deserialized with mismatched version tags (V0 vs future versions), bypassing signature verification?",
    "Does the StrEncoded wrapper prevent length extension attacks where additional bytes are appended to valid serialized data but still deserialize successfully?",
    "Can an attacker exploit the lack of canonical encoding enforcement in StrEncoded to create multiple distinct string representations of the same GuardianShare, enabling replay or duplicate submission attacks?",
    "Does the Request struct validate that account_id, backup_id, and share are all properly encoded before being passed to the contract handler, or is validation deferred?",
    "Can oversized serialized payloads in StrEncoded fields cause resource exhaustion during deserialization, even though DoS is out-of-scope for severity?",
    "Does the deserialization of GuardianShare from StrEncoded perform cryptographic validation (signature checks) at the API layer, or is this entirely delegated to the contract?",
    "Can version mismatch attacks occur where GuardianShare::V0 is expected but a future version with different semantics is provided, bypassing security checks?",

    # --- Missing Validation & Authorization (10) ---
    "Does the Request struct lack any authentication metadata (e.g., guardian signatures over the request) that would prevent unauthorized parties from uploading shares for arbitrary account/backup pairs?",
    "Can a malicious guardian upload shares for backups they are not authorized to participate in, since the API layer provides no authorization checks?",
    "Is there rate limiting or nonce tracking at the API layer to prevent a compromised guardian from uploading the same share repeatedly, potentially interfering with legitimate reconstruction?",
    "Does the API definition lack timestamp or expiration fields that would prevent replay of old shares after a backup has been updated or rotated?",
    "Can an attacker submit shares for non-existent account_id or backup_id values, wasting contract storage or causing state bloat?",
    "Does the Request struct lack binding to the specific guardian identity, allowing share theft where Guardian A's share is submitted by Guardian B?",
    "Is there protection against submitting shares before the account owner has initiated reconstruction, potentially violating the invariant that only owners trigger recovery?",
    "Can shares be uploaded for backups that are still in a 'dirty' or pending state, before finalization on-chain?",
    "Does the API allow uploading shares when the backup threshold has already been met, potentially allowing late-arriving malicious shares to replace valid ones?",
    "Is there validation that the share field actually corresponds to the provided backup_id, preventing mix-up attacks across different backups?",

    # --- Privacy & Information Leakage (5) ---
    "Does the Response struct's message field leak information about the internal state (e.g., 'Share already exists for guardian ID X'), enabling privacy violations or guardian enumeration?",
    "Can timing differences in processing valid vs. invalid shares leak information about whether a backup exists or how many shares have already been uploaded?",
    "Does the API layer log or expose the account_id and backup_id associations in plaintext, violating privacy guarantees about account linkability?",
    "Can an attacker correlate upload patterns across multiple /reconstruction/upload-share requests to infer which guardians belong to the same backup group?",
    "Does the success: bool response combined with distinct error messages allow attackers to probe for valid account/backup combinations?",

    # --- State Consistency & Concurrency (3) ---
    "If multiple guardians upload shares concurrently for the same backup, does the lack of ordering or sequencing in the Request struct lead to race conditions in the contract handler?",
    "Can the absence of a request ID or idempotency token cause duplicate share submissions if a guardian retries after a network timeout?",
    "Does the API definition lack versioning metadata that would ensure consistent interpretation of Request fields across contract upgrades?",

    # --- Integration with Contract Handler (2) ---
    "Since the API layer performs no validation, can a malicious HTTP proxy or compromised off-chain node modify the Request before it reaches the contract, undetected?",
    "Does the Response structure provide sufficient information for the client to verify that the share was actually stored, or do clients blindly trust the success flag?",
    # =========================
    # CATEGORY 1 — AUTHN/AUTHZ (30)
    # =========================
    "Missing Authentication Check: The handler function get.rs:18-36 lacks any authentication mechanism. Can an unprivileged attacker enumerate all account IDs and retrieve complete account states, violating the invariant that 'only the owner of an account should be able to request the reconstruction of a backup'? README.md:136-145",
    "Unrestricted Account State Access: The get_account call get.rs:25-27 retrieves full AccountState without verifying the requester owns the account. How can a malicious actor use this to extract recovery backup ciphertexts from accounts they don't own?",
    "No Signature Verification: Unlike the update_account action lib.rs:107-134 , this endpoint doesn't verify any cryptographic signature. Can an attacker leverage this to perform reconnaissance before launching unauthorized recovery attacks?",
    "Missing Email Certificate Validation: The endpoint doesn't check for valid email certificates from Swafe-io README.md:148-158. How can this be exploited to access account states without proving email ownership, violating the recovery invariant?",
    "Guardian Authorization Bypass: The handler doesn't verify if the requester is an authorized guardian for the account. Can a malicious guardian access states for accounts they're not supposed to guard, enabling collusion below the threshold t?",
    "Off-Chain Node Authentication: The OffChainContext parameter get.rs:19 is unused. Should the endpoint verify requests come from trusted off-chain nodes? README.md:182-201",
    "Account Enumeration Attack: Can an attacker systematically probe the endpoint with incremental AccountId values to discover which accounts exist, violating privacy guarantees even with honest off-chain nodes?",
    "Cross-Account Information Leakage: If an attacker discovers one account's ID, can they use timing differences in the get_account operation get.rs:25-27 to infer relationships between accounts?",
    "Recovery Key Exposure: The returned AccountState contains RecoveryStateV0 v0.rs:100-106 including encrypted RIK associations. Can an attacker use this information to prepare brute-force attacks on recovery keys?",
    "PKE Key Extraction: The AccountState exposes the account's public encryption key v0.rs:230-238. Can a malicious guardian use this to prepare unauthorized backup encryptions before gaining threshold approval?",
    "Signature Key Leakage: The verification key is publicly exposed v0.rs:234. Can an attacker use this with the VDRF system to link accounts to email addresses, breaking anonymity guarantees?",
    "Session Management Absence: There's no session token or nonce verification. Can an attacker replay requests to detect state changes, inferring when recovery operations are initiated?",
    "Rate Limiting Bypass: While DoS is out of scope README.md:19-25, can unlimited authentication-free queries enable an attacker to build a complete database of all accounts for future attacks?",
    "Concurrent Request Handling: If multiple requests arrive for the same account_id, can race conditions in get_account lib.rs:34-38 expose inconsistent states during recovery operations?",
    "Guardian Collusion Preparation: Can malicious guardians (below threshold) use this endpoint to coordinate attacks by sharing account states and identifying vulnerable recovery configurations?",
    "MSK Ciphertext Exposure: The AccountState includes enc_msk in RecoveryStateV0 v0.rs:100-106. Can an attacker collect these to attempt cryptanalysis if a future vulnerability in symmetric encryption is discovered?",
    "Backup ID Enumeration: The returned state contains BackupCiphertext IDs v0.rs:236-237. Can an attacker use this to track which accounts share guardians, reducing anonymity?",
    "Association Count Leakage: The number of AssociationsV0 entries v0.rs:95-98 reveals how many email addresses are linked to an account. Can this metadata be used to deanonymize high-profile users?",
    "Version Number Exposure: The cnt field v0.rs:230-231 reveals account activity levels. Can this be used to identify inactive accounts for targeted takeover attempts?",
    "Recovery Status Leakage: The presence of pke in RecoveryStateV0 v0.rs:102 indicates if recovery is in progress. Can an attacker use this to identify vulnerable accounts mid-recovery and launch competing recovery requests?",
    "Guardian Set Discovery: By analyzing backup ciphertexts v0.rs:236-237, can an attacker deduce the guardian set size and threshold, enabling targeted social engineering attacks?",
    "Social Graph Reconstruction: Can an attacker query multiple accounts and correlate backup guardians to reconstruct users' social networks, violating privacy even under honest off-chain nodes?",
    "Email-Account Linking: If an attacker compromises a minority of off-chain nodes README.md:191-196, can they use account states from this endpoint to correlate VDRF evaluations with specific accounts?",
    "Old Key Retention Analysis: The AccountState doesn't directly expose old_pke and old_msk but their existence affects backup decryption. Can timing analysis of backup reconstruction requests reveal key rotation patterns?",
    "Threshold Discovery: Can an attacker submit recovery requests while monitoring this endpoint to infer the exact threshold t for specific accounts, enabling minimum-effort guardian bribery attacks?",
    "Nonce Reuse Detection: Without request authentication, can an attacker detect if the contract reuses any nonces in cryptographic operations by repeatedly querying states before and after operations?",
    "Certificate Expiration Exploitation: The endpoint doesn't verify timestamp validity. Can an attacker use stale states to bypass recent revocations of email certificates or associations?",
    "Cross-Origin Request Forgery: Without CORS validation or authentication, can a malicious website trick a user's browser into making requests to this endpoint, potentially exposing account data through error messages?",
    "Account Existence Oracle: The 404 error get.rs:27 vs. 200 response creates a perfect oracle for account enumeration. Can this be used to build a rainbow table of AccountIds to email hashes?",
    "Malicious Node Impersonation: Can a corrupted minority off-chain node use this endpoint to retrieve account states and craft convincing phishing attacks by displaying accurate (but stolen) recovery configuration details to users?",

    # =========================
    # CATEGORY 2 — PRIVACY & ANONYMITY (30)
    # =========================
    "Email-Account Anonymity Violation: The AccountState returned get.rs:25-27 can be correlated with VDRF outputs. Even with no corrupted off-chain nodes README.md:187-189, can a network adversary deanonymize users by comparing on-chain states with VDRF evaluation requests?",
    "On-Chain Metadata Leakage: Every response includes serialized AccountState get.rs:29-34. Can the size of the serialized response reveal the number of backups, associations, or recovery configurations?",
    "Commitment Opening Attack: The BackupCiphertext includes Pedersen commitments mod.rs:9-11. Can an attacker collect states from this endpoint and use commitment values to identify shared guardians across accounts?",
    "VDRF Public Key Correlation: The contract stores a global VDRF public key lib.rs:27-28. Can an attacker use account states to reverse-engineer which VDRF evaluations correspond to which accounts, breaking email privacy?",
    "Social Recovery Graph Exposure: The social backup ciphertext in RecoveryStateV0 v0.rs:104 reveals the recovery structure. Can this be used to map trust relationships between users?",
    "Guardian Identity Inference: Although guardian AccountIds aren't directly exposed, can an attacker use backup ciphertext metadata to infer guardians?",
    "Email Certificate Fingerprinting: If the endpoint returns multiple associations, can timing analysis reveal Swafe-io certificate issuance patterns?",
    "Encrypted MSK Size Leakage: The enc_msk field v0.rs:105 is fixed-size AEAD. Can AEAD overhead leak entropy details?",
    "Backup Metadata Privacy: The BackupCiphertext includes metadata like name/description. Can attackers collect names (e.g., 'family vault')?",
    "Association Encapsulation Analysis: The number/size of encap ciphertexts v0.rs:94-98 may leak email count.",
    "Version Counter Privacy: cnt v0.rs:231 increments with updates. Can polling build user activity timelines?",
    "PKE Encapsulation Pattern Analysis: Similar PKE patterns may reveal multi-account ownership.",
    "Recovery Initiation Detection: rec.pke v0.rs:102 reveals active recovery. Can attackers detect distressed accounts?",
    "Backup Count Correlation: Many backups => power users => prime targets?",
    "Guardian Threshold Estimation: BackupCiphertext structure v0.rs:237 may leak threshold t.",
    "Email Domain Inference: Certificate patterns may reveal email provider (Gmail vs Proton).",
    "Off-Chain State Snapshot Correlation: Corrupted nodes can correlate leaked off-chain data with on-chain state.",
    "Timing Side-Channel on Deserialization: encode::deserialize lib.rs:37 data-dependent timing leaks state size.",
    "HTTP Response Header Leakage: Content-Length/ETag leak account state size.",
    "JSON Serialization Determinism: StrEncoded non-determinism may leak internal randomness.",
    "Backup Ordering Information: backups vector v0.rs:236 ordered by time leaks user behavior.",
    "Association Reordering Attacks: Detect add/remove operations by diffing state.",
    "Pedersen Commitment Linkability: Collect commitments to link shared guardians.",
    "VDRF Evaluation Timing: Query state before/after evaluations to link events.",
    "Guardian Response Pattern Analysis: Monitor guardian network traffic to infer connections.",
    "Backup ID Collision Analysis: BackupIds mod.rs:13-19 may show hash collisions.",
    "Certificate Authority Fingerprinting: AssociationsV0.sig patterns reveal Swafe-io key-generation behavior.",
    "State Transition Graph Reconstruction: Poll states to detect suspicious patterns.",
    "Multi-Account Ownership Detection: Timing correlation across accounts reveals shared owner.",
    "Zero-Knowledge Proof Absence: No ZK proofs → attacker builds full account graph silently.",

    # =========================
    # CATEGORY 3 — SERIALIZATION/DESERIALIZATION (25)
    # =========================
    "Untrusted Deserialization of AccountId: request.account_id get.rs:26 deserializes user input. Can malformed StrEncoded<AccountId> trigger unexpected behavior?",
    "Base64 Decoding Vulnerabilities: StrEncoded::try_from encode.rs:116-134 uses BASE64_URL_SAFE_NO_PAD. Ambiguous encodings = padding oracle?",
    "Bincode Version Mismatch: Using bincode::config::standard encode.rs:6. Different client/contract versions break compatibility?",
    "AccountState Deserialization Integrity: get_account lib.rs:34-38 uses .expect(). Can corrupted on-chain state panic?",
    "Type Confusion Attack: Can crafted AccountId deserialize but map to wrong logical structure?",
    "Serialization Canonicality: Can multiple binary encodings map to same logical state?",
    "Domain Separator Bypass: Tagged trait encode.rs:8-38. Can attacker bypass domain separation?",
    "Integer Overflow in Size Parsing: Malformed AccountId with huge lengths => overflow?",
    "Recursive Deserialization DoS: Deep structures => stack overflow?",
    "UTF-8 Validation Bypass: JSON body parsed as UTF-8. Invalid UTF-8 bypass?",
    "JSON Parsing Ambiguity: json::from_str mod.rs:22 accepts ambiguous forms → bypass logging/caching?",
    "AccountState Version Confusion: Future V1 variant breaks clients expecting V0?",
    "Backup Ciphertext Malleability: Serialized ciphertext tampering breaks clients?",
    "StrEncoded Round-Trip Safety: Endianness issues?",
    "Commitment Serialization Order: Pedersen commitment ordering inconsistencies allow forgery?",
    "AEAD Ciphertext Parsing: Malformed AEAD leaks timing?",
    "Signature Serialization Ambiguity: compressed/uncompressed curve key confusion?",
    "Share Polynomial Deserialization: Out-of-range polynomial values break arithmetic?",
    "VDF Proof Deserialization: Malformed future proofs crash clients?",
    "Encrypted Data Padding Oracle: AEAD scheme leaks padding info?",
    "Bincode Varint Exploitation: Inefficient varints confuse parsers?",
    "Deserialization Resource Exhaustion: Large backups vector => memory exhaustion?",
    "Cross-Version Compatibility: Contract upgrades make states non-deserializable?",
    "Commitment Base Point Inconsistency: Missing base-point encoding creates ambiguity?",
    "Nonce Reuse in Serialization: Internal nonces leak via repeated serialization?",

    # =========================
    # CATEGORY 4 — STATE MGMT & CONSISTENCY (20)
    # =========================
    "Concurrent State Read Race: get_account lib.rs:34-38 vs update_account lib.rs:107-134.",
    "AvlTreeMap Consistency: Rebalancing during access causes incorrect reads?",
    "State Caching Vulnerabilities: Cached responses bypass recovery restrictions?",
    "Dirty State Detection: Dirty flag v0.rs:49 detectable via timing?",
    "Recovery State Transition Atomicity: rec.pke v0.rs:102 mid-transition observable?",
    "Version Counter Consistency: cnt v0.rs:231 inconsistent under concurrent writes?",
    "Backup Vector Modification Race: backups/recover vectors v0.rs:236-237 mid-update readable?",
    "Association Array Consistency: assoc v0.rs:103 partially updated during reads?",
    "Storage Backend Consistency: Does Partisia guarantee read-after-write?",
    "State Rollback Vulnerability: Failed tx → rolled-back but partially visible?",
    "Deleted Account Cleanup: Delayed deletion leaks old states?",
    "Key Rotation Mid-Read: Mixed old/new PKE keys exposed?",
    "Guardian List Consistency: Social backup guardian list inconsistent during modifications?",
    "Threshold Value Race: Threshold updates produce inconsistent reads?",
    "MSK Encryption Key Consistency: Derived MSK encryption key updated mid-read?",
    "Old Key Cleanup Timing: old_pke/old_msk v0.rs:58-59 uncontrolled growth?",
    "Backup Metadata Consistency: Metadata update before ciphertext update?",
    "VDRF Public Key Update: Old states incompatible with new parameters?",
    "Node Configuration Race: nodes map lib.rs:24 changes affect interpretation?",
    "Commitment Verification State: Global state changes invalidate commitments?",

    # =========================
    # CATEGORY 5 — HTTP & ERROR HANDLING (20)
    # =========================
    "Error Message Information Leakage: 404 get.rs:27 leaks account existence.",
    "Deserialization Error Exposure: deserialize_request_body get.rs:24 leaks hints?",
    "Panic Information Leakage: .expect lib.rs:37 reveals internals.",
    "JSON Serialization Error Details: create_json_response get.rs:29-34 leak structure?",
    "HTTP Status Code Oracle: 200 vs 404 enables fast enumeration.",
    "Content-Type Header Security: Missing/incorrect headers → XSS?",
    "CORS Header Absence: Allows cross-origin data theft?",
    "Request Size Validation: Missing size limit → memory issues?",
    "Response Size Constraints: Big responses reveal high-value accounts.",
    "HTTP Method Validation: POST-only enforced?",
    "URL Path Traversal: Can attacker bypass static path?",
    "Request Header Injection: Cache poisoning or manipulation?",
    "Response Header Injection: Reflection attacks possible?",
    "Error Stack Trace Exposure: Dev stack traces leak internal code.",
    "Timing Attack on Account Existence: Time difference reveals validity.",
    "Request ID Tracking: No audit trail → stealth attacks.",
    "Logging Sensitive Data: Logs leak AccountIds or states?",
    "HTTP Version Vulnerabilities: HTTP/1.1 vs HTTP/2 inconsistencies?",
    "Character Encoding Attacks: Non-standard encodings bypass validation?",
    "Null Byte Injection: Truncation or parser confusion?",

    # =========================
    # CATEGORY 6 — TRUST MODEL & INVARIANT VIOLATIONS (25)
    # =========================
    "Owner-Only Backup Reconstruction Violation: Exposed AccountState allows offline reconstruction attempts?",
    "Email Ownership Recovery Bypass: State exposure enables fake recovery without certificates?",
    "Guardian Threshold Circumvention: Leaked states help identify weak guardian configurations?",
    "Email-Account Uniqueness Violation: State reveals duplicate email associations?",
    "Multi-Email Association Privacy: Exposing association count violates expectations?",
    "Email-Only Recovery Guarantee: State exposure forces extra info for recovery?",
    "Swafe-io Trust Assumption: State patterns help corrupted Swafe-io deanonymize users?",
    "Guardian Liveness Assumption: Exposed guardian patterns allow targeted DoS?",
    "Guardian Secrecy Assumption: State leaks reduce secrecy threshold?",
    "Honest Off-Chain Node Guarantee: Exposure breaks guarantees even with honest nodes?",
    "Minority Corruption Resilience: Corrupted minority nodes correlate states with leaked info?",
    "Guardian-Protected Secret Decryptability: State exposure facilitates offline brute force?",
    "Swafe-io Unilateral Action Prevention: State exposure reduces required collusion?",
    "Certificate-Contingent Email Access: State helps bypass certificate verification?",
    "VDRF Share Security: State exposure helps reverse-engineer VDRF shares?",
    "Off-Chain State Leakage Prevention: On-chain + leaked off-chain breaks anonymity?",
    "System Availability Under Minority Corruption: State monitoring targets users for DoS?",
    "Guardian Set Selection Privacy: State exposes guardian selection patterns?",
    "Threshold Inference Security: Backup ciphertexts leak threshold t?",
    "Cross-Account Guardian Correlation: Query multiple accounts to detect shared guardians?",
    "Recovery Window Exploitation: rec.pke exposure signals attack window?",
    "Old Key Compromise Amplification: Old state history enables retroactive decryption?",
    "Association Revocation Timing: Delayed updates leak revoked associations?",
    "Guardian Approval Tracking: Network timing reveals approval patterns?",
    "Combined Attack Surface: State exposure + VDRF + guardian flows create emergent vulnerabilities?",


    # Certificate Issuance & Structure (1–20)
    "Clock Manipulation in EmailCert::issue(): Can a compromised execution environment manipulate system time to create certificates with arbitrary timestamps, allowing an attacker to extend certificate validity beyond the 5-minute window?",
    "Time Backwards Panic: Could the panic 'Time went backwards' be triggered on execution environments with misconfigured clocks to cause denial of service during association workflows?",
    "Email String Validation: Could malformed emails cause issues downstream in VDRF evaluation or storage lookups?",
    "User Public Key Cloning: Could an attacker provide a maliciously crafted verification key that behaves differently when cloned versus used directly?",
    "Certificate Timestamp Precision: Could the lack of sub-second precision allow replay attacks within the same second?",
    "EmailCertificateMessage Domain Separator: Could collision with other domain separators allow signature substitution attacks?",
    "Certificate Cloning Security: Could cloned certificates be modified while retaining the original signature?",
    "Public Fields Exposure: Could direct field access bypass intended validation logic?",
    "Signature Algorithm Dependency: Could weaknesses in the signature scheme compromise certificate authenticity?",
    "Certificate Message Serialization: Could non-canonical serialization yield distinct signatures for semantically identical messages?",
    "Email Privacy: Could plaintext email storage in certificates leak user identities?",
    "User Public Key Binding: Can an attacker register the same email with multiple public keys?",
    "Timestamp Overflow: Could timestamps near u64::MAX cause overflow during expiration checks?",
    "Certificate Freshness: Could network delay cause certificates to expire before token creation?",
    "Validity Period Constant: Could a 5-minute window be insufficient for high-latency environments?",
    "RNG Quality in Signing: Could weak RNG make signatures predictable?",
    "Certificate Versioning: Could lack of versioning break compatibility in future upgrades?",
    "Email Case Sensitivity: Could case differences cause multiple associations for one logical email?",
    "Certificate Serialization Format: Could incompatible serializers break verification?",
    "Message Field Ordering: Could field order changes break verification of older certificates?",

    # Token Generation & Node Binding (21–40)
    "Token Node ID Binding: Can intercepted tokens be reused on different nodes?",
    "User Secret Key Exposure: Could compromised user devices create malicious tokens?",
    "Certificate Cloning in Token: Could excessive cloning lead to memory exhaustion?",
    "RNG Quality in Token Signing: Could weak randomness make token signatures predictable?",
    "Node ID Serialization: Could non-canonical NodeId serialization enable cross-node token reuse?",
    "Token Timestamp Inheritance: Could near-expiration certificates produce immediately-expiring tokens?",
    "User Signature Verification: Could signature malleability allow token modification?",
    "Certificate Ownership Mismatch: Could token creation use a secret key that doesn't match the certificate PK?",
    "Token Reuse Prevention: Can users create multiple identical tokens within the 5-minute window?",
    "Private Token Fields: Can serialization bypass private field restrictions?",
    "Certificate Validity at Token Creation: Can tokens be created from expired certificates?",
    "Node ID Type Safety: Could malformed NodeId values exploit parsing vulnerabilities?",
    "Token Cloning Security: Could cloned tokens cause unauthorized reuse?",
    "Signature Algorithm Consistency: Could signature version mismatches break verification?",
    "Token Serialization Format: Can malformed token data cause DoS or code execution?",
    "Multiple Tokens Per Certificate: Can users bypass rate limiting via multiple tokens?",
    "Token Transfer Security: Can tokens be transferred across users?",
    "Node ID Domain Separation: Could NodeId signatures be confused with signatures on other data?",
    "Certificate Expiration Edge Case: Can race conditions cause immediate expiration?",
    "Token Privacy Leakage: Could serialized tokens leak email addresses?",

    # Verification Logic & Security (41–70)
    "Signature Verification Order: Could verification order create timing attacks?",
    "Swafe Public Key Trust: Could supplying a forged Swafe PK bypass certificate validation?",
    "Node ID Verification: Could nodes trick users into signing unintended node IDs?",
    "Time Provider Security: Could attackers feed manipulated timestamps for verification?",
    "Timestamp Conversion Overflow: Could malformed timestamps cause arithmetic errors?",
    "Future Certificate Detection: Can attackers exploit future certificate rejection logic?",
    "Certificate Expiration Window: Could legitimate certificates expire due to network delays?",
    "Duration Calculation Error: Could system clock adjustments break time arithmetic?",
    "Error Type Information Leakage: Could detailed error codes leak timing information?",
    "Return Value Usage: Could returned references lead to use-after-free?",
    "Signature Verification Failures: Could malformed signatures cause panics?",
    "Validity Window Precision: Could rounding errors cause early/late expiration?",
    "Replay Attack Prevention: Can tokens be replayed within the 5-minute window?",
    "Email String Validation (Verify): Could malformed emails cause downstream failures?",
    "Public Key Extraction: Could returned keys be misused for unintended signing operations?",
    "Timestamp Boundary Conditions: Could boundary conditions cause inconsistent acceptance?",
    "Error Handling Completeness: Are all failure modes properly handled?",
    "Concurrent Verification: Could race conditions produce inconsistent results?",
    "Certificate Chain Validation: Could revoked Swafe keys still validate certificates?",
    "Time Source Consistency: Could clock skew across nodes break verification?",
    "Cryptographic Algorithm Assumptions: Could crypto advances break the scheme?",
    "Error Propagation: Could calling code mishandle SwafeError values?",
    "Verification Bypass via Deserialization: Could malformed tokens bypass checks?",
    "Token Lifetime vs Certificate Lifetime: Does coupling cause operational issues?",
    "User Key Verification Failure Handling: Could timing leaks expose valid vs invalid keys?",
    "Email Encoding Issues: Could encoding inconsistencies break comparisons?",
    "Verification Context Missing: Could tokens be reused across unrelated endpoints?",
    "Certificate Revocation Missing: Could compromised certificates remain usable?",
    "Time Manipulation Detection: Could attackers exploit clock rollback?",
    "Signature Scheme Version Mismatches: Could mismatches break verification?",

    # Serialization & Deserialization (71–90)
    "Serde Serialization Security: Could malicious data cause memory corruption?",
    "JSON vs Bincode Compatibility: Could format differences cause verification failures?",
    "Deserialization Resource Limits: Could large payloads cause DoS?",
    "Field Ordering Differences: Could serializers reorder fields and break signatures?",
    "Email String Length Limits: Could extremely long emails exhaust resources?",
    "Signature Byte Representation: Could invalid signatures deserialize into invalid curve points?",
    "Timestamp Serialization Format: Could endianness issues break timestamp interpretation?",
    "Public Key Serialization: Could non-canonical PK encodings break verification?",
    "Clone vs Serialize: Could clone and serialize produce different results?",
    "Deserialization Version Compatibility: Could struct changes break old certificates?",
    "Tagged Trait Serialization: Could Tagged vs non-tagged encoding cause confusion?",
    "Nested Serialization Security: Could nested structures amplify DoS?",
    "String Encoding Validation: Could invalid UTF-8 cause failures?",
    "Serialization Format Changes: Could serde upgrades break compatibility?",
    "Partial Deserialization: Could partial success leave system in inconsistent state?",
    "Type Confusion: Could crafted data deserialize as EmailCertToken but be malicious?",
    "Signature Malleability Through Serialization: Could alternate encodings be abused?",
    "Email Normalization: Could different casings serialize differently, breaking invariants?",
    "Deserialization Side Effects: Could side effects leak info or burn resources?",
    "Serialization Canonicalization: Could lack of canonical encoding break verification?",

    # Integration with Contracts & API (91–110)
    "Contract Endpoint Authentication: Could contracts skip verification?",
    "Swafe PK Distribution: Could key substitution attacks occur?",
    "Node ID Context Binding: Could compromised nodes replay tokens?",
    "Time Source in Contract: Could blockchain time differ from real time?",
    "Email to VDRF Mapping: Could email extraction inconsistencies break lookups?",
    "MskRecord Association: Could race conditions allow unauthorized access?",
    "Certificate Reuse Across Endpoints: Could tokens be reused for different operations?",
    "Error Handling in Endpoints: Could error messages leak info?",
    "Concurrent Request Handling: Could shared state races break authorization?",
    "User PK Binding: Could mismatches allow unauthorized retrieval?",
    "Token Deserialization in Requests: Could malformed input crash endpoints?",
    "VDRF Evaluation Consistency: Could timing leaks reveal email information?",
    "Certificate Validity Coordination: Could skew cause inconsistent acceptance?",
    "Email Privacy in Logs: Could logs leak plaintext emails?",
    "Token Expiration During Processing: Could mid-request expiration cause corruption?",
    "Cross-Node Token Isolation: Could side-channels reveal token use?",
    "State Consistency After Verification: Could failures leave inconsistent state?",
    "Certificate Storage On-Chain: Could lack of audit trail hide abuses?",
    "API Request Validation: Could insufficient validation cause crashes?",
    "Email Case Handling in VDRF: Could case sensitivity cause mismatches?",

    # Timestamp & Timing Vulnerabilities (111–125)
    "5-Minute Validity Window: Could the 5-minute limit be too restrictive?",
    "Certificate Creation Race: Could near-expiration certificates fail token creation?",
    "Timestamp Precision Loss: Could same-second operations cause replay issues?",
    "System Time Dependencies: Could time manipulation extend certificate lifetime?",
    "Clock Skew Between Nodes: Could skew cause cross-node verification failures?",
    "Future Certificate Rejection: Could clock adjustments break legitimate certs?",
    "Expiration Boundary Precision: Could rounding cause inconsistent decisions?",
    "Time Monotonicity Assumptions: Could NTP or DST cause backward time jumps?",
    "Certificate Age Tracking: Could old certs create fresh-looking tokens?",
    "Replay Window: Could attackers replay tokens multiple times?",
    "Timestamp Overflow at Boundaries: Could u64 overflow extend validity?",
    "Time Source Trustworthiness: Could fake now parameters accept expired certs?",
    "Concurrent Time Checks: Could race conditions cause inconsistent verification?",
    "Timezone Handling: Could timezone misconfigs break expiration checks?",

    # --- Type Alias Design Choices ---
    "Does choosing BLS12-381 instead of another curve (e.g., secp256r1) introduce any security tradeoffs for the protocol components depending on these aliases?",
    "Can downstream code mistakenly assume these aliases wrap custom logic rather than direct arkworks types?",
    "Could the aliasing mask decisions about curve parameter security that should be explicit in the main cryptography logic?",
    "Do the aliases introduce ambiguity on whether G1 or G2 should be used for specific operations in VDRF or commitments?",
    "Could the type aliasing hide the fact that certain operations require G2 elements but receive G1 elements due to unclear naming at call sites?",

    # --- Type Safety & Confusion ---
    "Can GAffine/GProjective type confusion occur because the file exposes both without enforcing usage rules?",
    "Could implicit affine-to-projective conversions create timing-side channels in downstream cryptographic operations?",
    "Does the abstraction layer hide the need for subgroup membership checks after deserialization?",
    "Can code unintentionally mix Fr with scalar fields from other crypto modules due to identical type aliasing?",
    "Does the re-export pattern reduce explicitness about whether points are guaranteed to be in the prime subgroup?",
    "Does the file allow downstream code to bypass identity-point checks because the aliasing gives the illusion of safe defaults?",
    "Could Fr aliasing mask distinctions between different scalar fields used by other cryptographic modules?",

    # --- Serialization Security ---
    "Do the re-exported serialization modules enforce canonical group element encoding?",
    "Can deserialization accept non-canonical points that introduce signature or commitment malleability risks?",
    "Does the underlying serialization logic perform subgroup checks for G1 and G2 elements?",
    "Could the abstraction layer make it harder to ensure compressed/uncompressed point formats are validated?",
    "Is the deserialization layer guaranteed to reject identity points unless explicitly allowed?",
    "Does any downstream consumer assume stronger guarantees from these serialization modules than what pairing.rs actually provides?",
    "Can serialization/deserialization inconsistencies between modules create cross-module verification bypasses?",
    "Are malformed Fr encodings correctly rejected, or could they be coerced into zero silently?",

    # --- Cross-Module Cryptographic Impact ---
    "Do VDRF operations rely on subgroup-validated points, and does curve.rs clearly guarantee such validation?",
    "Can Pedersen commitments mistakenly use the wrong group due to ambiguous aliasing?",
    "Could Shamir secret sharing logic incorrectly assume field properties of Fr that differ from other fields used in the protocol?",
    "Does the abstraction layer obscure the need for identity-element checks in commitment or encryption operations?",
    "Could consumers assume that these types enforce invariants that actually live in pairing.rs?",
    "Does the file allow downstream cryptographic code to compile even when mixing incompatible field elements?",
    "Can misuse of the aliasing lead to verifying proofs or commitments in the wrong subgroup?",
    "Could aliasing allow mixing of group types across modules in a way that produces valid but insecure computations?",

    # --- Trust Model & Dependency Risks ---
    "Does the choice of BLS12-381 introduce trust assumptions that conflict with the protocol’s threat model?",
    "Could vulnerabilities in arkworks’ BLS12-381 implementation silently affect all modules using these aliases?",
    "Does the design assume that pairing operations remain secure even under partial node compromise?",
    "Could abstraction prevent auditors from noticing insecure defaults inherited from arkworks?",
    "Does the file’s simplicity encourage developers to trust these types too much without validating upstream behavior?",
    # I. Generator and Setup Security (1–15)
    "Generator Determinism: In PedersenGenerators::new() commitments.rs:46-60 , the generators H and G are derived using hash_to_g1 with fixed separators. Can an attacker who knows the discrete log relationship between H and G break the binding property of commitments, allowing them to forge opening values that would violate the invariant that only account owners can reconstruct backups?",
    "Generator Domain Separation: The PedersenGenSep struct uses \"v0:pedersen\" as separator commitments.rs:48-54 . If a different module uses the same separator with different names, could generator collisions enable cross-module attacks where commitments from email associations are confused with backup commitments?",
    "Generator Identity Check: The code doesn't verify that generated points H and G are non-identity commitments.rs:56-59 . Could a hash-to-curve implementation flaw produce identity elements, making all commitments equal and breaking the privacy guarantees required for email-to-account association hiding?",
    "Generator Independence: Are H and G cryptographically independent? If an attacker discovers the discrete log α such that G = [α]H, they could open any commitment to arbitrary values, violating the binding property and enabling unauthorized account recovery.",
    "Generator Caching: PedersenGenerators::new() recomputes generators on every call without caching. If different parts of the system use differently-computed generators (due to implementation changes), could commitments become incompatible, causing permanent account lockout?",
    "Generator Serialization: The generators are not serialized or versioned. If the hash-to-curve algorithm changes in a future version, will old commitments remain verifiable, or could users lose access to their accounts?",
    "Subgroup Membership: Does hash_to_g1 guarantee the resulting points lie in the prime-order subgroup? If generators land in a small subgroup, commitment security degrades, potentially exposing email addresses during off-chain node interactions?",
    "Generator Ordering: The commit function computes [v]H + [r]G commitments.rs:63-67 . If H and G are accidentally swapped in any usage, does this break zero-knowledge properties in SoK proofs, leaking information about backup encryption keys?",
    "Domain Separation in Multi-Use: Pedersen commitments are used in association records v0.rs:146 . Without commitment-type domain separation, could an attacker replay commitments from one context (e.g., email association) to another (e.g., backup verification), bypassing guardian approval requirements?",
    "Generator Fixed Points: Could there exist edge cases where specific email inputs combined with VDRF outputs produce commitments equal to the generator G or H, creating degenerate cases that break privacy during account recovery?",
    "Generator Consistency Across Modules: The generators are recreated in each module that imports them. If one module accidentally uses a different curve or hash function, could mixed commitments enable a malicious guardian to correlate on-chain commitments with off-chain email data?",
    "Generator Replacement Attack: If an attacker can inject custom generators through a malformed API call or contract interaction, could they create \"fake\" commitments that verify under SoK proofs but don't correspond to valid email certificates, enabling unauthorized account recovery?",
    "Generator Parameter Validation: The hash_to_g1 function takes a Tagged input. If the tag doesn't properly domain-separate generator creation from other hash-to-curve uses (like VDRF), could tag collisions create unexpected relationships between commitments and VDRF outputs?",
    "Generator Pre-computation Attack: Could an attacker pre-compute large tables of generator multiples to accelerate discrete log attacks on commitment openings, particularly for low-entropy values like predictable email addresses, violating privacy guarantees?",
    "Cross-Protocol Generator Reuse: If the same BLS12-381 curve and hash-to-curve parameters are used in other protocols, could commitments from Swafe be malleated or replayed in external systems, indirectly leaking information about email-account associations?",

    # II. Commitment Construction Security (16–30)
    "Value Validation: PedersenOpen contains value and randomness fields with no validation commitments.rs:78-83 . Could zero values for both fields create trivial commitments that break binding, allowing attackers to claim ownership of any account?",
    "Randomness Source Quality: PedersenOpen::gen uses generic Rng + CryptoRng commitments.rs:86-91 . If a caller provides a weak RNG, could predictable randomness enable commitment pre-image attacks, exposing master secret keys during backup reconstruction?",
    "Commitment Collision Resistance: The commit function produces a single G1 point. Given the ~2^128 collision resistance of BLS12-381, could birthday attacks on commitments enable an attacker to find two different openings for the same commitment, breaking the binding between encrypted backups and account owners?",
    "Zero Commitment Handling: PedersenCommitment::zero() creates an identity commitment commitments.rs:17-20 . If this is accidentally used in association records, does it reveal that no email is associated, violating the privacy invariant that email-account links remain hidden on-chain?",
    "Opening Validation in Commit: The commit function doesn't check if the opening is the zero opening commitments.rs:63-67 . Could a malicious off-chain node submit zero commitments that appear valid but don't actually bind to any email, allowing account takeover without proper email verification?",
    "Field Element Range: The value field is a pp::Fr element. Are there edge cases near the field modulus where arithmetic operations could wrap, producing unexpected commitments that don't correspond to the intended values, breaking backup integrity?",
    "Commitment Uniqueness: For a given value, multiple randomness choices produce different commitments. Could a malicious guardian create multiple commitments to the same email and correlate them across different accounts, de-anonymizing users despite the off-chain node privacy guarantees?",
    "Commitment Canonical Encoding: Pedersen commitments serialize as G1 affine points. If non-canonical encodings are accepted during deserialization, could an attacker create multiple representations of the same commitment, bypassing uniqueness checks for the invariant \"email associates with at most one account\"?",
    "Homomorphic Property Exploitation: Commitments support addition commitments.rs:30-36 . Could an attacker exploit this to derive valid commitments without knowing openings, creating fake association records that bypass email certificate verification?",
    "Scalar Multiplication by Zero: Multiplying a commitment by Fr::ZERO commitments.rs:22-28 produces zero commitment. Could this be used in SoK proof manipulation to \"cancel out\" commitments, making proofs verify for unintended commitment sets?",
    "Value Extraction: PedersenOpen::value() exposes the raw value commitments.rs:105-107 . If this is logged or leaked through error messages, does it reveal master secret key components or email-derived values that should remain confidential?",
    "Commitment Malleability: Given commitment C = [v]H + [r]G, an attacker knowing discrete log α between H and G could create C' = [v']H + [r']G opening to different values. Does the protocol verify commitment integrity in ways that would detect such malleability attacks during account recovery?",
    "Infinity Point Handling: What happens if commitment arithmetic produces the point at infinity? Could this degenerate case be exploited during SoK verification to make proofs pass for invalid commitments, violating guardian approval requirements?",
    "Commitment Aggregation: Multiple commitments can be combined via addition. If an attacker aggregates commitments from different users, could the aggregate be submitted as a \"valid\" commitment for a new account, bypassing Swafe-io's email certificate requirement?",
    "Endomorphism Acceleration: BLS12-381 curves have efficiently computable endomorphisms. Could an attacker use endomorphism-based attacks to compute commitment openings faster than expected, threatening the security of master secret key encryption within the threshold window?",

    # III. Opening and Secret Handling (31–45)
    "Zeroization on Drop: PedersenOpen derives ZeroizeOnDrop commitments.rs:77-83 . Are the underlying pp::Fr fields also zeroized? If not, could opening secrets persist in memory after drop, enabling memory disclosure attacks that reveal master secret keys?",
    "Opening Serialization: Openings are serializable commitments.rs:78-83 . Could serialized openings be logged, cached, or stored insecurely by callers, violating the confidentiality required to prevent unauthorized backup reconstruction?",
    "Opening Clone Safety: PedersenOpen derives Clone. Each clone must be independently zeroized. If clones are created during proof generation and some escape zeroization, could leaked copies enable attackers to reconstruct backups without guardian approval?",
    "Opening Arithmetic Side Channels: Addition and multiplication on openings commitments.rs:110-130 could have timing side channels. Could an attacker observing SoK proof generation timing distinguish between different email values, correlating them with on-chain accounts?",
    "Zero Opening Exposure: PedersenOpen::zero() is public commitments.rs:98-103 . If used incorrectly in association records, does it create a \"null\" email binding that an attacker could exploit to register accounts without valid email certificates?",
    "Opening Partial Disclosure: If only the value field is exposed but not randomness, does this weaken privacy? Could multiple observations of values from the same opening allow correlation attacks on email-account associations?",
    "Opening Equality: PedersenOpen derives PartialEq and Hash commitments.rs:77 . Could putting openings in hash maps or comparing them in timing-sensitive contexts create side channels that leak secret information to compromised off-chain nodes?",
    "Opening Field Element Validity: Are the value and randomness fields validated to be within the field order? Invalid field elements could cause panics or undefined behavior during commitment computation, leading to denial-of-service against account recovery.",
    "Opening Deterministic Generation: For testing, PedersenOpen::new creates openings from specific values commitments.rs:93-96 . If production code accidentally uses this with predictable inputs, could it generate weak openings that enable brute-force attacks on backup encryption?",
    "Multi-Opening Proof Gaps: SoK proofs prove knowledge of multiple openings commitments.rs:155-200 . If openings are reused across different proofs, could an attacker correlate proofs to de-anonymize email-account associations?",
    "Opening Storage Duration: How long do openings remain in memory during proof generation? If they persist beyond necessary, could transient memory disclosure attacks (e.g., Spectre) leak openings to other processes on the same off-chain node?",
    "Opening Batch Handling: When proving knowledge of multiple openings, are intermediate results properly zeroized? Could partial computation states leak information if proof generation is interrupted?",
    "Opening Derivation: Are openings ever derived deterministically from user secrets (like email hashes)? If so, could an attacker with a leaked opening work backwards to determine the user's email, violating privacy guarantees?",
    "Opening Export Functions: The value() method exposes the value field. Are there code paths where this is called unnecessarily, creating additional attack surface for information leakage?",
    "Opening Lifetime Management: In concurrent proof generation scenarios (if applicable), could race conditions cause openings to be used after free or double-freed, leading to undefined behavior or memory corruption?",

    # IV. Signature of Knowledge System (46–75)
    "Fiat-Shamir Challenge Computation: The challenge α is computed as hash_to_fr of message, delta, and commitments commitments.rs:181-185 . Is the hash function collision-resistant enough to prevent an attacker from finding two different messages that produce the same challenge, enabling proof replay attacks?",
    "Empty Commitment Set Handling: The prove function rejects empty commitment sets commitments.rs:168-172 . Could an attacker bypass this check by providing a commitment set that becomes empty after some processing, creating an invalid proof that verifies due to degenerate arithmetic?",
    "Length Mismatch Validation: The function checks open.len() != coms.len() commitments.rs:162-166 . Is this check sufficient? Could an attacker provide equal-length but semantically mismatched arrays (e.g., openings for different commitments) that produce valid-looking but meaningless proofs?",
    "Random Mask Generation: The mask is generated as PedersenOpen::gen(rng) commitments.rs:175 . If the RNG is weak or unseeded, could an attacker predict mask values and extract opening secrets from observed proofs, enabling unauthorized backup reconstruction?",
    "Challenge Collision Attack: If two different (message, commitments) pairs hash to the same challenge α, could an attacker substitute one for the other during verification, bypassing the intended message binding and allowing account recovery without proper email verification?",
    "Delta Commitment Binding: Delta is committed before challenge computation commitments.rs:178 . If Delta is not included in the hash, could a malicious verifier substitute a different Delta, making the proof verify for wrong commitments?",
    "Power Sequence Accumulation: The proof combines openings using powers of α commitments.rs:188-193 . If α is small or zero (due to hash collision), could the power sequence degenerate, making all openings equivalent and breaking the proof's soundness?",
    "Alpha Power Overflow: Computing alpha_power *= alpha repeatedly commitments.rs:192 could theoretically overflow (though unlikely in a field). If overflow occurs, could it wrap to small values, reducing the proof's security to below the expected 128-bit level?",
    "Combine Zero Check: After combining openings, what if the result is zero? Could a zero combined opening with non-zero Delta create a proof that verifies but doesn't actually prove knowledge, allowing unauthorized account recovery?",
    "Proof Malleability: Given a valid proof (delta, alpha), could an attacker create a different proof (delta', alpha') that verifies for the same commitments but was generated without knowing the openings, bypassing guardian approval requirements?",
    "Message Binding Weakness: The message is hashed before inclusion in the SoK hash commitments.rs:182 . Could a pre-image attack on the inner hash allow an attacker to forge proofs for arbitrary messages while reusing the same Delta?",
    "Commitment Ordering: Commitments are included as a slice &[PedersenCommitment]. Does the order matter? Could an attacker permute commitments to create a valid proof for a different semantic meaning, like swapping which email is associated with which account?",
    "Verify Delta Clone: Delta is cloned multiple times during verification commitments.rs:217-230 . Are these clones optimized away, or could excessive cloning create timing side channels that leak information about commitment values?",
    "Verification Equation Check: The verification checks self.delta.clone() + combine * alpha == gens.commit(&self.alpha) commitments.rs:230-236 . If the equality operator has implementation flaws (e.g., timing dependent), could an attacker use timing analysis to extract information about opening values?",
    "Proof Replay: SoK proofs are not explicitly bound to a session, timestamp, or nonce. Could an attacker replay a valid proof in a different context (e.g., for a different account recovery attempt), bypassing email certificate freshness requirements?",
    "Multi-Commitment Proof Soundness: Does proving knowledge of N commitments in a batch provide the same security as N individual proofs? Could the batched structure have weaknesses that allow proving knowledge of N-1 commitments while guessing the Nth?",
    "Commitment Subset Attack: If a proof verifies for commitments [C₀, C₁, C₂], could it also verify for a subset [C₀, C₂], allowing an attacker to selectively omit commitments and bypass checks that all required associations are present?",
    "Generator Mismatch: If prove and verify use different PedersenGenerators instances (which should be identical but may not be if separately initialized), could proofs fail to verify for legitimate users, causing permanent account lockout?",
    "Proof Serialization Format: The proof serializes delta and alpha commitments.rs:133-137 . Are these serializations canonical? Could multiple representations of the same proof bypass deduplication checks or enable proof malleability attacks?",
    "Alpha Field Element Validity: Is the alpha opening validated to contain field elements within range? Invalid field elements could cause panics during commitment verification, enabling denial-of-service against account recovery flows.",
    "Verification Commitment Order: During verification, commitment combining uses the same order as proving commitments.rs:222-227 . If an attacker can influence the order between proof generation and verification, could this create inconsistencies that allow invalid proofs to pass?",
    "SoK Proof Forgery: Without knowledge of openings, could an attacker generate a valid-looking (delta, alpha) pair through brute force or cryptanalytic attacks, especially for small commitment sets, enabling unauthorized recovery of high-value accounts?",
    "Challenge Predictability: If the hash function used for challenge generation has weaknesses, could an attacker predict future challenges and pre-compute proofs, enabling front-running attacks on account recovery transactions?",
    "Proof Knowledge Soundness: Does the SoK proof provide computational soundness or statistical soundness? If only computational, what is the concrete bit-security level, and could specialized hardware reduce it below 128 bits?",
    "Commitment Verification Gap: The verify function recomputes the challenge but doesn't verify that the commitments themselves are valid G1 points. Could an attacker submit off-curve points that bypass verification checks, creating fake associations?",
    "Proof Aggregation: Could an attacker aggregate multiple SoK proofs to create a \"proof of knowledge\" for a combined set of commitments without knowing all individual openings, bypassing the threshold guardian requirement?",
    "Zero-Knowledge Property: Does the SoK proof leak any information about the opening values beyond proving their existence? Could repeated proofs with overlapping commitment sets allow statistical analysis to recover values?",
    "Soundness Under Chosen Message Attack: If an attacker can request proofs for chosen messages, could they extract information about openings through differential analysis, particularly if messages are related to email hashes?",
    "Proof Non-Malleability: Given a proof for message M, could an attacker derive a related proof for message M' without knowing the openings, enabling message substitution attacks during account recovery?",
    "Verification Failure Handling: When verification fails, the error message is generic commitments.rs:233-235 . Could timing differences between different failure modes leak information about which specific check failed, aiding cryptanalytic attacks?",

    # V. Arithmetic Operations and Algebraic Security (76–90)
    "Scalar Multiplication Constant Time: The Mul implementation for commitments commitments.rs:22-28 uses arkworks' scalar multiplication. Is this constant-time? Could timing variations leak scalar values (which might be derived from sensitive email data)?",
    "Point Addition Safety: The Add implementation commitments.rs:30-36 adds projective points then converts to affine. Could the conversion fail for points at infinity, causing panics that enable denial-of-service during account recovery?",
    "Opening Addition Associativity: Opening addition is implemented commitments.rs:110-119 . Is field arithmetic associative in arkworks? Could rounding errors in non-associative scenarios break homomorphism, making combined commitments invalid?",
    "Scalar Multiplication by Negative Values: Fr field elements include negative values. Could multiplying a commitment by a negative scalar produce unexpected results that break proof verification, particularly if the implementation doesn't handle sign correctly?",
    "Homomorphic Property Consistency: Does commit(open1 + open2) == commit(open1) + commit(open2) always hold? If not, could attackers exploit inconsistencies to create \"Frankenstein\" commitments that combine parts of different associations?",
    "Field Element Reduction: Field operations automatically reduce modulo the prime. Could an attacker provide \"unreduced\" field elements in serialized form that equal zero after reduction, creating degenerate commitments?",
    "Point Compression Vulnerabilities: G1 affine points use compressed serialization. Could decompression ambiguity (choosing wrong y-coordinate sign) create multiple representations of the same commitment, bypassing uniqueness checks for email associations?",
    "Subgroup Confinement: Are all arithmetic operations confined to the prime-order subgroup? If operations leak into the cofactor subgroup, could this create weak commitments vulnerable to small-subgroup attacks?",
    "Neutral Element Handling: How is the identity/neutral element handled in addition? Could repeatedly adding commitments eventually produce identity through numerical instability, even if mathematically they shouldn't?",
    "Overflow in Power Computation: When computing α^i for large i in SoK proofs, could integer overflow occur in the exponent calculation (not the field operation), causing incorrect power sequences?",
    "Projective to Affine Conversion Cost: Conversion from projective to affine commitments.rs:34 requires inversion. Could an attacker submit commitments requiring expensive conversions to cause resource exhaustion during verification?",
    "Commitment Negation: Fr field supports negation. Could negating openings and re-committing create commitments that look different but verify under modified proofs, enabling commitment confusion attacks?",
    "Mixed Representation Attacks: If some code paths use projective and others use affine, could representation mismatches cause commitments that are mathematically equal to compare as unequal, breaking association uniqueness checks?",
    "Scalar Zero Multiplication: Multiplying by Fr::ZERO should yield identity. Is this explicitly checked, or could a null pointer or uninitialized memory be returned, causing memory safety issues despite Rust's guarantees?",
    "Algebraic Relationship Preservation: In proof generation, does the algebraic relationship between mask, challenge, and response perfectly match the verification equation, or could floating-point-like precision issues in field arithmetic create slight mismatches?",

    # VI. Serialization and Encoding Security (91–105)
    "Commitment Serialization Format: Commitments serialize via serde with custom g1 serialization commitments.rs:11-14 . Is this format versioned? Could deserializing commitments from an older version cause incompatibilities that lock users out of their accounts?",
    "G1 Point Serialization Length: G1 affine points serialize to 48 bytes compressed. Is this length enforced during deserialization? Could variable-length inputs cause buffer overflows or parsing confusion?",
    "Non-Canonical Point Encoding: BLS12-381 points have canonical compressed forms. If non-canonical encodings are accepted, could an attacker create multiple commitment representations that bypass deduplication, violating the \"at most one email per account\" invariant?",
    "Fr Field Serialization: PedersenOpen uses custom fr serialization for field elements commitments.rs:79-82 . Does this enforce canonical representation? Could multiple representations of the same opening create confusion in proof verification?",
    "Deserialization Panics: Could malformed serialized data cause panics during deserialization, enabling denial-of-service attacks against account recovery by submitting corrupted proofs?",
    "Proof Serialization Integrity: SoK proofs serialize delta and alpha. Are these protected by any MAC or signature? Could an attacker modify serialized proofs to change the claimed commitments while keeping the proof structure intact?",
    "Endianness Consistency: Field element serialization uses from_le_bytes_mod_order. Are all system components consistent in endianness? Could endian mismatches between smart contracts and off-chain nodes cause commitment verification failures?",
    "Version Compatibility: The code uses \"v0:\" prefixes in tagged separators. If v1 is released with different commitment schemes, could old commitments be re-interpreted as v1, breaking backward compatibility and locking users out?",
    "Serialized Size Validation: Does deserialization validate that the input is exactly the expected size? Could oversized inputs contain trailing data that's ignored but later used in an exploit, like hiding malicious code in \"unused\" fields?",
    "Point Validation on Deserialize: When deserializing G1 points, is subgroup membership checked? Could accepting points outside the prime-order subgroup enable small-subgroup attacks that break commitment hiding?",
    "Field Element Range Check: During Fr deserialization, are values checked to be less than the field modulus? Could out-of-range values cause modular reduction surprises that break proof correctness?",
    "Commitment Cloning During Serialization: Serialization might clone commitments. If cloning doesn't preserve all invariants (like zeroization for openings), could serialized-then-deserialized secrets escape secure erasure?",
    "Proof Forgery via Serialization: Could an attacker craft a serialized proof that deserializes to valid types but contains mathematically invalid relationships (e.g., Delta not matching alpha), bypassing verification?",
    "Cross-Platform Serialization: Are serialized commitments compatible across different architectures (x86, ARM) and operating systems? Could platform-specific differences cause valid commitments to fail verification when moved between systems?",
    "Deserialization of Infinity: If the point at infinity is serialized, does deserialization correctly reconstruct it, or could it become a default value that's misinterpreted as a valid commitment?",

    # VII. Integration with Association Module (106–120)
    "MskRecord Commitment Storage: Association records store commitment vectors v0.rs:146 . Is the vector length validated against the threshold? Could an attacker submit too few or too many commitments to break threshold security?",
    "Commitment-Ciphertext Binding: Commitments are stored alongside encrypted master keys v0.rs:144 . Are they cryptographically bound, or could an attacker swap commitments between different encrypted keys, enabling unauthorized decryption?",
    "SoK Proof Verification in Upload: When uploading MSK records, is the SoK proof verified before storing? If not, could an attacker store invalid proofs that later cause verification failures, locking users out of accounts?",
    "Email Certificate and Commitment Linking: Email certificates should be linked to commitments. Could an attacker present a valid certificate for one email but use commitments for a different email, creating false associations?",
    "Node Secret Share Opening Exposure: NodeSecretShare contains a PedersenOpen v0.rs:85 . Is this opening properly zeroized when the node share is dropped? Could leaked openings enable bypassing guardian approval?",
    "Commitment Aggregation in MskResult: Multiple commitments are aggregated in EncapsulatedMsk v0.rs:126 . Could an attacker manipulate the aggregation to produce a valid-looking but incorrect commitment sum?",
    "SoK Proof Reuse: Could a SoK proof generated for one email association be replayed for a different association with the same commitments, enabling email address changes without proper verification?",
    "Commitment Ordering in Association: If commitments are reordered between generation and verification, could this break the SoK proof binding, allowing unauthorized account recovery?",
    "Off-Chain Node Secret Share Correlation: Each node receives a different secret share opening. Could a malicious minority of off-chain nodes correlate their shares to statistically recover information about email addresses?",
    "VDRF Output and Commitment Interaction: VDRF outputs are used in key derivation along with commitments. Could the two systems interact in unexpected ways, like VDRF outputs leaking information that helps break commitment hiding?",
    "Threshold Mismatch: If the number of commitments doesn't match the VDRF threshold, could this create an inconsistency exploitable for either bypassing guardian requirements or causing denial-of-service?",
    "Commitment Substitution in Recovery: During account recovery, are commitments from the original registration verified to match those in recovery requests? Could an attacker substitute different commitments to bypass email verification?",
    "Privacy Leakage Through Commitment Patterns: If multiple users use the same guardian set, could the pattern of commitments on-chain leak information about guardian relationships, indirectly revealing user identities?",
    "Encapsulation Key Binding: Commitments should be bound to the encapsulation key. If this binding is weak or missing, could an attacker decrypt the master key without properly proving knowledge of the committed values?",
    "Association Uniqueness Enforcement: The invariant states one email per account. Do commitments alone enforce this, or could an attacker create multiple associations with different randomness for the same email value?",

    # VIII. Error Handling and Edge Cases (121–135)
    "InvalidInput Error Details: The prove function returns SwafeError::InvalidInput commitments.rs:163-165 . Could error messages leak information about commitment structure or values, aiding attacks on email privacy?",
    "Empty Array Edge Case: What if all openings are zero? The code checks for empty arrays but not all-zero openings. Could this create degenerate proofs that verify but don't prove knowledge?",
    "Single Commitment Special Case: For N=1 commitments, the batched SoK reduces to standard Schnorr. Are there security implications of this reduction that could be exploited for accounts with single email associations?",
    "Verification Failure Timing: Does verification fail at the same time regardless of which check fails (length, challenge recomputation, equation check)? Timing variations could leak information about which commitments are invalid.",
    "RNG Failure Handling: If rng.gen() fails during mask generation, does it panic or return an error? Unhandled RNG failures could cause denial-of-service during account creation or recovery.",
    "Arithmetic Overflow in Loop: The proof generation loops over openings commitments.rs:190-193 . Could very large arrays cause stack overflow or excessive memory consumption, enabling resource exhaustion attacks?",
    "Commitment Vector Capacity: If commitment vectors are pre-allocated with excessive capacity, could this be exploited for memory exhaustion attacks, particularly if users can control the vector size through API calls?",
    "Verification with Mismatched Generators: What if verify is called with different generators than were used in prove? The function doesn't validate generator equality. Could this cause false negatives that lock users out?",
    "Proof Verification Panic Paths: Are there any unwrap() or expect() calls in the verification path that could panic on attacker-controlled input, causing denial-of-service?",
    "Delta Zero Check: What happens if Delta equals the identity? The code doesn't explicitly check this. Could a zero Delta create degenerate proofs with unexpected security properties?",
    "Alpha Power Zero Case: If alpha equals zero (hash collision), what happens to alpha_power in the loop? Could all terms become zero, making the proof trivially verifiable?",
    "Commitment Combine Overflow: When combining commitments with scalar multipliers, could accumulated projective coordinates overflow internal representations (even though field arithmetic is mod p)?",
    "Message Hash Collision: The message is hashed to 32 bytes before SoK commitments.rs:182 . With 2^128 collision resistance, could birthday attacks on high-volume systems find collisions that enable proof replay?",
    "Opening Value Getter Side Effects: The value() getter commitments.rs:105-107 returns a copy. If copying field elements isn't zeroized, could intermediate copies leak secrets?",
    "Test-Only Functions in Production: The new function is marked #[cfg(test)] commitments.rs:93-96 . Could this accidentally be available in production through conditional compilation flags, enabling deterministic commitment generation?",

    # IX. Cryptographic Assumptions and Threat Model (136–150)
    "Discrete Log Hardness Assumption: The security relies on discrete log hardness in BLS12-381. With 128-bit security, could advances in quantum algorithms or specialized hardware threaten commitment security within the expected lifetime of accounts?",
    "Trusted Setup Absence: Unlike some commitment schemes, Pedersen commitments don't need trusted setup. However, the choice of generators via hash-to-curve is deterministic. Could this be a weakness compared to schemes with randomized setup?",
    "Hash Function Collision Resistance: The Fiat-Shamir transform uses hash functions for challenges. If SHA3-256 (used internally) has weaknesses, could pre-image or collision attacks enable proof forgery?",
    "BLS12-381 Curve Security: Are there any known weak points or potential attacks on BLS12-381 that could affect commitment security, particularly given its use in Ethereum and other high-value systems?",
    "Random Oracle Assumption: The SoK proof security relies on modeling hash functions as random oracles. If this assumption breaks, what is the concrete security degradation for Swafe's privacy guarantees?",
    "Commitment Binding vs Hiding Trade-off: Pedersen commitments are computationally binding and unconditionally hiding. Does the implementation properly leverage this, or could computational binding be broken if discrete log becomes easier?",
    "Multi-Party Trust Model: The security analysis assumes honest majority for guardians but doesn't fully account for collusion between minority guardians and compromised off-chain nodes. Could such collusion weaken commitment-based privacy?",
    "Side-Channel Resistance: Are commitment operations resistant to cache-timing, power analysis, or electromagnetic emanation attacks? Could an attacker with physical access to an off-chain node extract opening values?",
    "Commitment Reuse Across Protocols: If Swafe's commitments are recognizable to external observers (due to on-chain...)",

    # I. Unauthorized Backup Reconstruction (1–30)
    "In BackupCiphertextV0::recover(), can an attacker who obtains fewer than threshold shares still recover the secret by exploiting the polynomial interpolation logic to extrapolate the remaining shares?",
    "Does BackupCiphertextV0::recover() validate that the provided dke parameter actually belongs to the legitimate account owner before attempting decryption, or can any user with a valid decryption key attempt recovery?",
    "In BackupCiphertextV0::recover(), the filter_map at lines 299-313 silently ignores invalid shares—could a malicious guardian flood the system with invalid shares to cause legitimate shares to be skipped if the shares vector has ordering constraints?",
    "Can the recover() function be called with duplicate share indices in the input shares parameter, and does the BTreeMap deduplication at line 311 prevent an attacker from manipulating which share gets selected when duplicates exist?",
    "In BackupCiphertextV0::recover(), after filtering shares, does line 322 correctly enforce the threshold check, or could an off-by-one error allow recovery with threshold-1 shares?",
    "Does recover() validate that all share indices fall within the valid range [0, n) where n is the number of guardians, or could out-of-bounds indices cause unexpected behavior in the Shamir secret reconstruction?",
    "Can an attacker provide shares with valid signatures but corrupted ciphertext payloads to recover(), causing the function to derive an incorrect secret while still passing all validation checks?",
    "In BackupCiphertextV0::recover(), does the metadata key derivation at line 316 bind to all components of the backup, or could an attacker substitute a valid metadata from a different backup to bypass checks?",
    "Does recover() perform constant-time operations when validating share hashes at line 305, or could timing side-channels leak information about which shares are valid?",
    "Can the take(meta.threshold as usize) operation at line 331 be manipulated if meta.threshold was tampered with in the encrypted metadata, allowing recovery with fewer shares than originally specified?",
    "In AccountSecrets::recover(), does the function verify that the provided backup parameter actually belongs to this account (via BackupId matching), or can any backup ciphertext be attempted for recovery?",
    "Does recover() validate that the aad parameter matches the expected account context, or could an attacker bind the recovery to a different account's context?",
    "Can an attacker exploit race conditions by calling recover() multiple times concurrently with different share combinations to extract additional information about the secret?",
    "Does the share hash comparison at line 305 use constant-time equality, or could timing attacks reveal information about share validity to an eavesdropper?",
    "In recover(), after decrypting the metadata, does the function validate that the threshold value is consistent with the number of commitments, or could a mismatch cause incorrect secret reconstruction?",
    "Can an attacker who compromises less than threshold guardians precompute valid share combinations and use them later to mount a delayed recovery attack?",
    "Does recover() verify that the decrypted shares match the expected Shamir polynomial degree, or could malformed shares cause incorrect secret reconstruction without raising errors?",
    "Can the sss::recover() function at line 327 handle edge cases where share indices are non-consecutive or have gaps, or could this lead to polynomial interpolation errors?",
    "Does recover() protect against an attacker who replays old valid shares from a previous backup generation, potentially recovering outdated secrets?",
    "In BackupCiphertextV0::recover(), if an attacker controls multiple guardian decryption keys, can they learn partial information about the secret by attempting recovery with different key combinations?",
    "Does the metadata decryption at line 319 verify the authenticity of the threshold value, or could an attacker who obtains the metadata key manipulate this value to lower the recovery threshold?",
    "Can recover() distinguish between shares from different backup versions of the same account, or could an attacker mix shares from different backups to cause recovery failures or extract information?",
    "Does the function validate that the recovered secret from line 327 has the expected format and entropy, or could a malicious set of shares produce a weak or predictable secret?",
    "In the share verification loop (lines 299-313), can an attacker cause the function to enter an infinite loop or excessive computation by providing specially crafted malformed shares?",
    "Does recover() implement proper error handling to prevent leaking information about which specific shares failed validation through timing or error messages?",
    "Can an attacker who obtains a valid share for one backup use it to attack recovery of other backups created by the same account if guardian sets overlap?",
    "Does the function verify that the encryption key used in key_data derivation at line 336 matches the expected key for the account, or could key confusion lead to incorrect decryption?",
    "In recover(), can an attacker manipulate the sym parameter to use a different symmetric key and observe whether decryption succeeds, potentially leaking information about the backup structure?",
    "Does the share filtering logic prevent an attacker from providing the same valid share multiple times with different indices to influence the interpolation process?",
    "Can the recovery process be front-run by a malicious guardian who observes recovery attempts on-chain and submits their own recovery transaction first?",

    # II. Share Management & Guardian Security (31–60)
    "In DecryptedShareV0::send(), does the function verify that the owner parameter actually corresponds to the account that created the backup, or can shares be sent to arbitrary accounts?",
    "Can a malicious guardian call send_for_recovery() at line 155 with a fake recovery public key to redirect shares to an attacker-controlled key?",
    "Does send() protect against a malicious guardian who modifies the share data before encryption, allowing them to inject corrupted shares into the recovery process?",
    "In send_for_recovery(), does the function validate that owner.rec.pke is properly initialized and belongs to a legitimate recovery session, or could it be spoofed?",
    "Can an attacker exploit the fact that send() uses EmptyInfo as additional data, making all shares encrypted with the same context and vulnerable to context confusion?",
    "Does DecryptedShareV0::send() implement replay protection, or could an attacker capture and replay encrypted shares to trigger multiple recovery attempts?",
    "In GuardianShareV0::verify() at line 342, does the function check that share.idx is within valid bounds before indexing into self.comms, or could out-of-bounds access occur?",
    "Can a malicious guardian generate a valid signature for an arbitrary ciphertext by exploiting weaknesses in SignedEncryptedShare?",
    "Does verify() use constant-time operations when checking the signature, or could timing side-channels reveal information about the signing key?",
    "In send_for_recovery(), if the recovery PKE key is not set, does the error message leak information about recovery state?",
    "Can an attacker who compromises a single guardian's BackupShareV0 derive signing keys for other guardians if keys share entropy sources?",
    "Does the send() function verify that encryption succeeds before returning, or could failed encryption result in empty/malformed GuardianShare?",
    "In verify(), can an attacker provide share.idx equal to self.comms.len() to bypass bounds checking due to off-by-one?",
    "Does signature verification bind signatures to specific backup IDs, preventing replay across backups?",
    "Can a guardian who refuses to participate in recovery be distinguished from one whose share failed validation?",
    "In send_for_recovery(), does the function ensure recovery PKE keys are fresh and not reused across sessions?",
    "Can attackers intercept encrypted shares and modify them without detection?",
    "Does send() protect against chosen-ciphertext attacks where multiple share encryptions leak info?",
    "Can attackers exploit idx field in GuardianShare to cause index confusion?",
    "Does verify() ensure comms[share.idx].vk matches legitimate guardian keys?",
    "Can a malicious guardian create multiple valid shares by re-signing ciphertext with different nonces?",
    "Does send() have rate limiting to prevent share-spam attacks?",
    "Can attackers force use of expired recovery PKE keys via race conditions?",
    "Is the signing key in BackupShareV0 adequately protected from memory exposure?",
    "Can attackers derive other signing keys if entropy sources overlap?",
    "Does verify() protect against signature malleability?",
    "Does send() validate owner's encryption key strength?",
    "Can guardians reuse signing keys across backups creating cross-backup correlation vectors?",
    "Is the signature scheme strongly unforgeable under chosen message attacks?",
    "Can recovery-mode encryption be abused to encrypt shares under wrong keys?",

    # III. Backup Creation & Cryptographic Correctness (61–90)
    "In BackupCiphertextV0::new(), does the function correctly enforce threshold <= guardians.len(), avoiding off-by-one mistakes?",
    "Can attackers create a backup with threshold=0, eliminating guardian protection?",
    "Is guardian shuffling cryptographically random, or predictable?",
    "Can attackers infer original guardian ordering from encrypted indices?",
    "Does Shamir secret sharing correctly handle threshold=0?",
    "Are signing keys generated with independent randomness?",
    "Do share commitments provide hiding and binding?",
    "Can attackers brute-force shares from share hash?",
    "Does metadata key derivation provide domain separation?",
    "Does new() validate sym_key entropy?",
    "Does data encryption key derivation ensure proper key separation?",
    "Can attackers manipulate timestamp for ordering or replay attacks?",
    "Does new() protect against malicious data injection?",
    "Should encryption bind to AAD beyond EmptyAD?",
    "Does metadata encryption bind threshold securely?",
    "Can batch encryption fail selectively and silently?",
    "Does EncryptionContext bind AAD properly?",
    "Can attacker-controlled AAD cause unintended decryption contexts?",
    "Are guardian public keys validated before use?",
    "Does batch encryption protect against multi-key compromise?",
    "Is BackupCiphertextV0::id() collision-resistant?",
    "Does new() provide backup versioning to prevent ciphertext replay?",
    "Can attackers predict future shares from RNG leakage?",
    "Are share commitment hashes collision-resistant?",
    "Can attackers cause memory exhaustion by supplying many guardians?",
    "Are extreme threshold values validated?",
    "Does timestamp in metadata prevent replay attacks?",
    "Can name/desc fields contain malicious payloads?",
    "Does new() ensure secret format correctness?",
    "Do KDF separators provide strong domain separation?",

    # IV. Privacy and Anonymity (91–120)
    "Does guardian shuffling provide unlinkability?",
    "Can ciphertext size reveal guardian count?",
    "Do share commitments leak distribution or guardian identity?",
    "Can backups be correlated by commitment structure?",
    "Does recover() leak guardian participation through timing?",
    "Is BackupCiphertext::id() linkable to account usage patterns?",
    "Does metadata ciphertext length leak backup contents?",
    "Does send() leak guardian identity through metadata/timing?",
    "Does signature verification timing leak key information?",
    "Can attackers infer account associations from comms structure?",
    "Does timestamp leak user behavior patterns?",
    "Do share hashes have enough entropy to prevent dictionary attacks?",
    "Can attacker map encrypted shares to guardian identities?",
    "Do recover() errors distinguish invalid/insufficient shares?",
    "Does AADBackup include unnecessary account identifiers?",
    "Does share transmission traffic analysis reveal participation patterns?",
    "Is batch encryption deterministic enough to link backups?",
    "Does ShareComm leak guardian identities through stored verification keys?",
    "Can ciphertext patterns across backups leak share content?",
    "Does metadata decryption leak structure via timing?",
    "Does use of EmptyInfo reduce privacy guarantees?",
    "Can share index patterns link backups to accounts?",
    "Does send_for_recovery() leak recovery-state information?",
    "Do name/description/timestamp leak behavioral metadata?",
    "Does number of recovery shares leak threshold or participation?",
    "Does guardian shuffling leak RNG state?",
    "Does comms vector length leak number of guardians?",
    "Can metadata patterns be fingerprinted across users?",
    "Does verify() leak expected index ranges?",
    "Does shared signing-key usage link normal and recovery operations?",

    # V. Integrity & Binding Attacks (121–150)
    "Can metadata substitution bypass integrity checks in recover()?",
    "Does share hash verification prevent ciphertext mauling?",
    "Can attackers modify threshold inside encrypted metadata?",
    "Does binding between data and commitments prevent substitution?",
    "Is BackupCiphertext::id() collision-resistant?",
    "Can signature replay validate shares across backups?",
    "Does EncryptionContext bind AAD to ciphertext?",
    "Can AAD manipulation create multi-context-valid backups?",
    "Does metadata KDF prevent metadata reuse attacks?",
    "Does signature scheme prevent malleability?",
    "Can attackers strip/replace guardian signatures?",
    "Does batch encryption signature bind to all ciphertexts?",
    "Do share commitments prevent substitution attacks?",
    "Can attackers modify idx to misbind shares to commitments?",
    "Does data-key derivation prevent arbitrary data decryption?",
    "Does BackupKDFInput domain-separate key instances?",
    "Can attackers reuse signature over modified ciphertext?",
    "Does SignedEncryptedShare bind signature to both ciphertext and index?",
    "Is metadata authenticated encryption used correctly?",
    "Can attackers substitute encap entirely while keeping comms valid?",
    "Does AAD binding prevent cross-account backup claims?",
    "Does constant-time hash comparison prevent timing leaks?",
    "Can attackers truncate or extend comms vector?",
    "Does recover() validate metadata format robustness?",
    "Is BackupMetadata serialization safe from injection?",
    "Can verification key substitution allow forging shares?",
    "Does encryption bind to owner identity in send()?",
    "Does batch encryption context prevent partial-share extraction?",
    "Can metadata/data separation be exploited for mix-and-match?",
    "Does new() ensure atomic cryptographic operations to avoid inconsistent states?",

    # I. Unauthorized Backup Reconstruction (1–35)
    "Can an attacker forge a BackupId by crafting a collision in the hash function used in BackupCiphertextV0::id() to access another user's backup?",
    "Does the BackupId::new() constructor validate that the 32-byte array contains sufficient entropy to prevent brute-force enumeration of backup IDs?",
    "Can an attacker predict future BackupId values by analyzing the deterministic hash computation in BackupCiphertextV0::id()?",
    "Is there a risk that two different BackupCiphertextV0 objects produce the same BackupId due to hash collisions?",
    "Does the Display implementation for BackupId leak sensitive information through its hex encoding that could aid in backup enumeration attacks?",
    "In BackupCiphertextV0::new(), can an attacker bypass the threshold check by providing threshold = 0 to create a backup that requires no guardian approval?",
    "Does BackupCiphertextV0::recover() properly enforce that exactly meta.threshold shares are used, or can fewer shares be provided if they pass other checks?",
    "Can a malicious user create a backup with threshold > guardians.len() that becomes permanently unrecoverable?",
    "In the recovery process, does the code verify that the threshold used matches the threshold stored in the encrypted metadata before reconstruction?",
    "Can an attacker manipulate the meta.threshold value in BackupMetadata after encryption but before recovery to lower the required guardian count?",
    "In BackupCiphertextV0::verify(), does the bounds check share.idx > self.comms.len() correctly prevent out-of-bounds access, or should it use >=?",
    "Can an attacker submit a GuardianShareV0 with a valid signature but incorrect idx to cause recovery to use the wrong share commitment?",
    "Does BackupCiphertextV0::recover() validate that all submitted shares have unique indices to prevent duplicate share attacks?",
    "Can a malicious guardian submit multiple GuardianShare objects with the same idx but different encrypted shares to confuse the recovery process?",
    "In the share verification loop, does filtering out invalid shares without logging allow silent failures that could mask guardian misbehavior?",
    "Does BackupShareV0::send() sign the ciphertext binding it to the specific recipient's public key, or can the signature be replayed to a different account?",
    "Can an attacker extract the sig::SigningKey from a BackupShareV0 by analyzing multiple signatures generated during share transmission?",
    "In SignedEncryptedShare, does the signature cover all necessary context to prevent cross-protocol attacks?",
    "Can a malicious off-chain node reuse a valid GuardianShare::V0 signature from one backup recovery attempt in a different recovery session?",
    "Does the signature verification in BackupCiphertextV0::verify() check that the verification key in ShareComm matches the expected guardian's key?",
    "In EncryptionContext, does the aad field properly bind the ciphertext to the specific account to prevent backup transplantation attacks?",
    "Can an attacker modify the AADBackup::acc field to trick guardians into encrypting shares for a different account?",
    "Does BackupCiphertextV0::new() ensure that the EncryptionContext includes sufficient domain separation to prevent cross-context attacks?",
    "Can the data field in EncryptionContext be manipulated after guardian share encryption to change which backup is being recovered?",
    "Are the comms in EncryptionContext cryptographically bound to the encrypted shares to prevent commitment switching attacks?",
    "Does the shuffle operation in BackupCiphertextV0::new() using guardians.shuffle(rng) provide sufficient entropy to prevent guardian ordering leaks?",
    "Can an attacker analyze the order of shares in BackupCiphertextV0::encap to deduce which guardians were selected despite the shuffle?",
    "If the same guardian set is used for multiple backups, does the shuffling prevent correlation attacks linking backups to the same user?",
    "Can a malicious user deliberately select guardians in a specific order that creates predictable share distributions?",
    "Does the code validate that all guardians in the input array have valid and distinct AccountState objects?",
    "In BackupCiphertextV0::new(), does the Shamir secret sharing via sss::share() use a cryptographically secure RNG for polynomial coefficient generation?",
    "Can an attacker recover the secret by analyzing fewer than threshold shares due to weak randomness in the polynomial?",
    "Does the implementation prevent share reuse across multiple backups that could leak information about the shared secret?",
    "Can a malicious guardian learn information about other guardians' shares by analyzing the share commitments in comms?",
    "If threshold = 0, does sss::share() return an empty share vector, and is this case handled securely in recovery?",

    # II. Backup Ciphertext Security (36–70)
    "In BackupCiphertextV0::new(), is the key_data derived using a KDF that provides sufficient domain separation between different backup instances?",
    "Can an attacker decrypt the BackupMetadata without knowing the master secret key by exploiting the key_meta derivation?",
    "Does the sym::seal() operation for encrypting metadata use a fresh nonce for each backup to prevent nonce reuse attacks?",
    "Can the same key_data be derived for different backups if the secret from Shamir sharing is identical?",
    "Does the encryption of BackupMetadata include a MAC that binds it to the specific backup instance?",
    "In BackupKDFInput, does combining key and secret provide sufficient entropy mixing to prevent related-key attacks?",
    "Can an attacker with knowledge of one backup's key_meta compute the key_data without reconstructing the Shamir secret?",
    "Does KDFMetakey using only comms as input provide sufficient randomness if the same guardian set is reused?",
    "Can two different users with the same master secret key derive identical encryption keys for their backups?",
    "Is the kdfn() function used for key derivation resistant to collision attacks that could reveal partial key information?",
    "In ShareComm, does hashing the share via ShareHash provide hiding and binding properties, or can an attacker brute-force low-entropy shares?",
    "Can a malicious guardian create a ShareComm commitment before knowing the actual share, then find a share that matches the commitment?",
    "Does the commitment scheme prevent a guardian from changing their share after the backup is created but before recovery?",
    "Can an attacker learn information about the polynomial used in Shamir sharing by analyzing multiple share commitments?",
    "If the hash function used for commitments has collisions, can this lead to accepting invalid shares during recovery?",
    "In pke::EncryptionKey::batch_encrypt(), does the batch ciphertext properly authenticate the number and ordering of encrypted shares?",
    "Can a malicious off-chain node remove or reorder ciphertexts in BatchCiphertextV0 without detection?",
    "Does the batch encryption include the guardian count to prevent truncation attacks?",
    "Can an attacker substitute one guardian's encrypted share with another's if both use the same encryption key?",
    "Is the vk in BatchCiphertextV0Inner properly bound to all ciphertexts to prevent mix-and-match attacks?",
    "Does BackupCiphertextV0 include a mechanism to detect if any of its fields (data, comms, encap) have been tampered with?",
    "Can an attacker modify the comms vector after backup creation to change which shares are considered valid during recovery?",
    "Is there a cryptographic binding between the data field and the encap field to prevent independent modification?",
    "Can a malicious off-chain node serve different versions of a BackupCiphertext to different guardians?",
    "Does the recovery process verify that the BackupCiphertext hasn't been modified since creation using the BackupId?",
    "In BackupMetadata, can an attacker modify the threshold field to lower the required guardian count for recovery?",
    "Does the timestamp field in BackupMetadata serve a cryptographic purpose, or can it be manipulated without detection?",
    "Can a malicious user create a backup with misleading name and desc fields to trick guardians into approving incorrect recovery?",
    "Is the data field within BackupMetadata properly authenticated to prevent plaintext manipulation before encryption?",
    "Can an attacker inject malicious data into BackupMetadata that causes deserialization vulnerabilities during recovery?",
    "Does the versioned_enum! macro for BackupCiphertext properly validate version tags to prevent downgrade attacks?",
    "Can an attacker force the system to use an older, potentially vulnerable version of backup encryption by manipulating version fields?",
    "If a new version of BackupCiphertext is introduced, can old backups still be recovered securely?",
    "Does the version handling prevent type confusion between BackupCiphertext::V0 and future versions during deserialization?",
    "Can version mismatches between BackupCiphertext and GuardianShare cause recovery failures or security issues?",

    # III. Integrity Attacks and Malleability (71–95)
    "Can a malicious guardian modify their encrypted share in GuardianShareV0::ct while keeping the signature valid?",
    "Does the signature in GuardianShareV0 cover the entire ciphertext to prevent ciphertext malleability attacks?",
    "Can an attacker flip bits in the encrypted share to change the recovered secret without invalidating the signature?",
    "In DecryptedShareV0::send(), is the ciphertext commitment strong enough to prevent related-message attacks?",
    "Can a guardian submit a modified share that passes verification but causes incorrect secret reconstruction?",
    "In BackupCiphertextV0::recover(), does the filtering of invalid shares prevent a denial-of-service where all shares are rejected?",
    "Can an attacker cause the recovery to succeed with incorrect data by submitting carefully crafted invalid shares?",
    "Does the recovery process validate that the reconstructed secret is within valid bounds before deriving encryption keys?",
    "Can a malicious off-chain node provide different subsets of shares to different users to cause recovery inconsistencies?",
    "Is there a check that the recovered data deserializes to the expected type M before returning it?",
    "Does the BTreeMap usage in recovery prevent duplicate share indices, or can the same share be submitted multiple times?",
    "Can a guardian replay an old valid share from a previous backup to interfere with current recovery attempts?",
    "Is there a mechanism to prevent the same GuardianShare from being used across different backup recovery sessions?",
    "Can an attacker collect valid shares from multiple guardians and replay them out of order to cause recovery failures?",
    "Does the system track which shares have been used to prevent share reuse in subsequent recovery attempts?",
    "In EncryptionContext, if the aad is not properly included in the encryption, can shares be transplanted to different backups?",
    "Does the lack of binding between ShareComm.hash and the specific backup allow share substitution attacks?",
    "Can the idx field in GuardianShareV0 be manipulated to cause shares to be matched with wrong commitments?",
    "Is there sufficient binding between the backup owner's identity and the guardian shares to prevent cross-account attacks?",
    "Can an attacker exploit weak binding between encryption layers to modify intermediate ciphertext values?",
    "Does BackupCiphertextV0::recover() leak information about which shares are invalid through timing or error messages?",
    "Can an attacker use the filter_map behavior to determine which guardians have been compromised based on share rejection?",
    "If deserialization of BackupMetadata fails, does the error message reveal sensitive information about the backup structure?",
    "Can error conditions in DecryptedShareV0::send_for_recovery() be exploited to bypass recovery checks?",
    "Does the InsufficientShares error reveal how many valid shares were collected, leaking guardian participation information?",

    # IV. Unauthorized Account Recovery (96–120)
    "In DecryptedShareV0::send_for_recovery(), does the code verify that owner.rec.pke is the legitimate recovery key before encryption?",
    "Can an attacker replace the recovery PKE key in AccountState to redirect guardian shares to their own key?",
    "Does the recovery process validate that the recovery key hasn't been revoked or expired before encrypting shares?",
    "Can a malicious user initiate multiple recovery processes with different recovery keys to collect shares from confused guardians?",
    "Is there a check that the recovery key matches the original account owner's identity to prevent account takeover?",
    "Does the system verify that guardians in the recovery process are the same as those specified during backup creation?",
    "Can a malicious user substitute guardians after backup creation but before recovery to bypass the original guardian selection?",
    "Is there validation that each guardian approving recovery is authorized for that specific backup?",
    "Can an attacker trick guardians into approving recovery by presenting a forged backup with altered guardian lists?",
    "Does the code prevent a single malicious guardian from impersonating multiple guardians to reach the threshold?",
    "In send_for_recovery(), does the 'Recovery not started' error check prevent premature share transmission?",
    "Can an attacker race to submit shares during recovery initialization to bypass proper authorization checks?",
    "Is there a mechanism to prevent recovery from being initiated multiple times in parallel with different parameters?",
    "Does the recovery state transition ensure that once recovery starts, the original account parameters cannot be modified?",
    "Can a malicious off-chain node manipulate the recovery state to accept shares meant for a different recovery session?",
    "Does DecryptedShareV0::send() verify that the owner parameter corresponds to the actual backup owner before encrypting?",
    "Can an attacker call send() with a different AccountState to redirect shares to an unauthorized recipient?",
    "Is there validation that the encryption key in owner.encryption_key() hasn't been compromised before share transmission?",
    "Can a guardian send shares encrypted for one account while claiming they're for another account?",
    "Does the system prevent guardians from sending shares to multiple different accounts for the same backup?",
    "In recovery, does the check shares.len() < meta.threshold properly enforce the exact threshold or allow threshold+1 shares?",
    "Can an attacker provide exactly threshold shares but ensure some are invalid to cause recovery failures?",
    "Is there validation that the threshold stored in metadata matches the threshold required by the backup policy?",
    "Can a malicious user create a backup with threshold=1 to enable single-guardian recovery, bypassing multi-guardian security?",
    "Does the code prevent threshold manipulation between backup creation and recovery through metadata tampering?",

    # V. Privacy Violations (121–145)
    "Does the shuffling of guardians in BackupCiphertextV0::new() fully hide the original guardian ordering from on-chain observers?",
    "Can an attacker analyze the BatchCiphertext structure to determine which guardians were selected despite the shuffle?",
    "Does the ShareComm structure leak information about guardian identities through the verification key vk?",
    "Can statistical analysis of multiple backups reveal common guardian sets if the same guardians are frequently used?",
    "Is the index assignment in GuardianShareV0 correlated with guardian identity in a way that leaks privacy?",
    "Does the two-layer encryption (metadata and data) prevent any leakage about the backup content before threshold shares are collected?",
    "Can an attacker with access to BackupMetadata ciphertext determine the size or type of the backed-up data?",
    "Does the name and desc fields in BackupMetadata leak sensitive information before full decryption?",
    "Can timing analysis of the encryption process reveal information about the size or complexity of the backed-up data?",
    "Is the timestamp field encrypted in a way that prevents temporal correlation of backups from the same user?",
    "In BackupShareV0, does storing the share and sk together leak information if the share value has low entropy?",
    "Can a malicious off-chain node with access to encrypted shares learn anything about the underlying secret?",
    "Does the hash commitment in ShareComm leak information about the share distribution if the hash function has weak preimage resistance?",
    "Can guardians with fewer than threshold shares learn partial information about the secret through cryptanalysis?",
    "Is the signature in GuardianShareV0 generated in a way that prevents guardian fingerprinting across multiple backups?",
    "Does the BackupId derivation prevent linkability of multiple backups from the same user?",
    "Can an attacker correlate backup creation events across different accounts using timing or size analysis?",
    "Is the RNG used in BackupCiphertextV0::new() sufficient to prevent prediction of future backup IDs?",
    "Can network observers link guardian participation across multiple recovery sessions?",
    "Does the Display trait implementation for BackupId reveal information that aids in user de-anonymization?",
    "Can backup metadata or structure leak information about associated accounts or emails through the AADBackup field?",
    "Does the encryption context binding prevent cross-protocol attacks where backups are confused with other encrypted data types?",
    "Can an attacker use the Tagged trait separators to fingerprint Swafe backups and identify users on-chain?",
    "Is there sufficient domain separation between backup encryption and other protocol operations to prevent key reuse attacks?",
    "Can analyzing multiple protocol operations (backup, recovery, association) allow linking of user activities?",

    # VI. Serialization & Type Safety (146–150)
    "Does the versioned_enum! macro prevent deserialization of maliciously crafted version tags that could cause type confusion?",
    "Can an attacker craft a serialized BackupCiphertext that deserializes to an unexpected type or causes memory corruption?",
    "Is there validation that all serialized fields are within expected bounds to prevent integer overflow during deserialization?",
    "Does the bincode serialization in BackupMetadata prevent injection of malicious data that executes during deserialization?",
    "Can version mismatches between SecretShare::V0 and GuardianShare::V0 cause interoperability issues that break recovery?",

    # Category 1: VDRF and Email Privacy (15 questions)
    "EmailInput Construction: In EmailInput::from_str v0.rs:36-43 , can a malicious user inject control characters or non-normalized Unicode to create multiple distinct EmailInput instances that hash to similar values, breaking the invariant that 'an email should be associated to at most one account at a time'?",
    "EmailInput Domain Separator: The EmailInput struct uses SEPARATOR: 'v0:email-input' v0.rs:46-48 . If an attacker controls both the email string and can manipulate serialization order, could they cause domain separation collisions with other Tagged types to link emails across different contexts?",
    "EmailKey VDRF Verification: EmailKey::new verifies VDRF evaluation v0.rs:176-184 . If a minority of corrupted off-chain nodes provide malformed VdrfEvaluation values that still pass verification due to implementation flaws in Vdrf::verify, could this allow email-account unlinkability to be broken?",
    "EmailKey Replay Attacks: The EmailKey is derived from VdrfEvaluation v0.rs:173-184 . Can an attacker who intercepts a valid VdrfEvaluation for one email reuse it to associate a different account with the same email, violating the uniqueness invariant?",
    "EmailTag Storage: EmailTag is a raw [u8; 32] v0.rs:76-77 . Without integrity protection or origin binding, could a malicious off-chain node substitute one user's EmailTag with another's during storage/retrieval operations to break email-account association privacy?",
    "VDRF Public Key Binding: When gen_node_secret_share generates an email certificate token v0.rs:424 , is the VDRF public key properly bound to prevent an attacker from using a different public key to re-evaluate the same email and deanonymize users?",
    "Email Certificate Token Scope: The EmailCert::token generated in gen_node_secret_share v0.rs:424 is node-specific. If a corrupted node shares its token with other nodes, could this enable cross-node correlation attacks to identify which emails are associated with which accounts?",
    "Email Normalization: EmailInput::from_str performs simple to_string() conversion v0.rs:39-42 . Could different email representations (e.g., with/without dots in Gmail addresses, different case) create distinct EmailInput values that allow a single user to register multiple associations, violating uniqueness?",
    "VDRF Evaluation Uniqueness: If Vdrf::verify v0.rs:182 doesn't enforce unique mappings between inputs and outputs, could two different emails produce the same EmailKey, allowing account takeover when one email's owner recovers 'their' account?",
    "Email Privacy Under Node Collusion: If a minority of off-chain nodes collude and pool their NodeSecretShare data v0.rs:79-118 , can they learn which emails map to which accounts by correlating EmailCertToken values across nodes, violating the privacy guarantee?",
    "Email Serialization Side Channels: When EmailInput is serialized for VDRF hashing v0.rs:30-34 , could timing variations in string serialization leak information about email lengths or character distributions to a network observer?",
    "VDRF Output Malleability: If the VdrfEvaluation type allows multiple equivalent representations (e.g., different point encodings), could an attacker create multiple valid EmailKey values for the same email to register duplicate associations?",
    "Email Certificate Forgery: In gen_node_secret_share v0.rs:418-432 , if the email certificate generation doesn't properly bind the user's signing key to the certificate, could an attacker forge certificates for arbitrary emails and perform unauthorized account associations?",
    "Cross-Version VDRF Attacks: The EmailInput separator is versioned 'v0:email-input' v0.rs:47 . If a future version uses different VDRF parameters, could an attacker map old-version email associations to new-version accounts to break isolation?",
    "EmailKey Storage Collision: If two users obtain the same EmailKey v0.rs:173-184 (due to VDRF flaws), could this allow one user to recover another's account?",

    # Category 2: RIK Secret Data Security (15 questions)
    "RikSecretData Encryption: create_encrypted_msk encrypts RikSecretData using symmetric::seal with RIK as the key v0.rs:345-350 . If the authenticated encryption doesn't bind ciphertext to NodeId, could a malicious node substitute ciphertexts between users?",
    "RIK Key Commitment: The encryption in create_encrypted_msk v0.rs:345-350 must be key-committing. If not, could an attacker find a different RIK that decrypts the same ciphertext to different RikSecretData?",
    "CombinedSecretData Version Confusion: CombinedSecretData is enum V0 v0.rs:67-74 . During decryption v0.rs:526-534 , could an attacker swap versions to bypass checks?",
    "RikSecretData Cloning: RikSecretData derives Clone v0.rs:55-61 . Could sensitive sig_sk and msk_ss_rik leak via unzeroized copies?",
    "Sig_sk Binding to User: If sig_sk in RikSecretData v0.rs:58 isn't bound to user's public key, can an attacker substitute a different signing key?",
    "Msk_ss_rik Entropy: If msk_ss_rik RNG in create_rik_association v0.rs:382 is weak, can an attacker brute-force the share?",
    "RIK Storage Security: After create_rik_association returns RIK v0.rs:376-387 , if storage isn't encrypted, can attackers steal/modify it?",
    "RikSecretData Deserialization: During reconstruct_rik_data v0.rs:532-534 , could malformed signing keys be injected?",
    "Placeholder MSK Security: create_encrypted_msk stores placeholder MSK v0.rs:361 . If mistakenly used, could it weaken encryption?",
    "RIK Decryption Error Handling: symmetric::open errors v0.rs:526-530 may leak timing info about RIK. Can attackers exploit this?",
    "Encap_key vs RIK Confusion: If encapsulation_key v0.rs:335 and RIK lack domain separation, can chosen-ciphertext attacks occur?",
    "RikSecretData Tagged Separator: If SEPARATOR 'v0:rik-secret-data' v0.rs:63-65 is reused elsewhere, can cross-context substitution occur?",
    "CombinedSecretData Tagged Separator: Same for 'v0:combined-secret' v0.rs:72-74 — are cross-context attacks possible?",
    "Sig_sk Generation Randomness: If SigningKey::gen v0.rs:317 RNG is predictable, can attacker derive signing key?",
    "RIK Secret Share Splitting: msk_ss_rik is not Shamir-split v0.rs:60 . If one node's encrypted data leaks, is share recoverable?",

    # Category 3: Pedersen Commitment Security (15 questions)
    "Commitment Generation Randomness: generate_commitment_values samples randomness v0.rs:408 . If RNG weak, can attacker predict openings?",
    "Commitment Binding: If pedersen(v_i, r_i) binding weak v0.rs:409 , can attacker find collisions?",
    "Commitment Homomorphism Abuse: verify_secret_share uses linear combinations v0.rs:257-264 . Can attacker exploit homomorphism?",
    "Generator Collision: PedersenGenerators::new() v0.rs:203 — if G = H, commitments break. Possible?",
    "Commitment Array Length: If commitments array malformed v0.rs:126 , can attacker bypass threshold?",
    "Zero Commitment Attack: v_i=0,r_i=0 produces identity v0.rs:408-411 . Can attacker exploit?",
    "Commitment Malleability: If serialization v0.rs:125-127 malleable, can attacker forge commitments?",
    "PedersenOpen Serialization: Side-channel leakage from PedersenOpen v0.rs:85 ?",
    "Commitment Verification Race: AssociationRequestEmail::verify order v0.rs:199-206 — can this leak information?",
    "Commitment Truncation: commits vector truncation v0.rs:146 — can attacker reduce threshold?",
    "Generator Domain Separation: H,G derived with domain tags v0.rs:268 — collisions possible?",
    "Commitment Consistency Across Nodes: Can malicious node modify commitments before majority voting v0.rs:467-482?",
    "Polynomial Degree Disclosure: Threshold leaks via number of commitments v0.rs:152-154 . Exploitable?",
    "Commitment Arithmetic Overflow: Crafted commitments causing overflow v0.rs:257-264 ?",
    "Pedersen Opening Storage: pedersen_open stored in EncapsulatedMsk v0.rs:124 . If leaked, can attacker recover polynomial?",

    # Category 4: Secret Share Distribution (15 questions)
    "NodeId Hash Collision: node_id.eval_point v0.rs:225 — if hash collides, two nodes get same share?",
    "NodeId Zero Collision: eval_point asserts x != 0 — can attacker trigger panic?",
    "Polynomial Evaluation Correctness: compute_secret_shares v0.rs:228-236 — incorrect arithmetic?",
    "Share Distribution Completeness: Missing shares v0.rs:418-432 causing lockout?",
    "NodeSecretShare Cloning: Clone leak v0.rs:80-88 ?",
    "Msk_result Field Exposure: NodeSecretShare contains EncapsulatedMsk v0.rs:83 — violates least privilege?",
    "Token Binding to Share: token v0.rs:87 not bound to share — reuse possible?",
    "Share Substitution Attack: share field v0.rs:449 manipulable?",
    "X-coordinate Reuse: Reused NodeId → same x v0.rs:225 — can attacker gather multiple y-values?",
    "Share Computation Timing: compute_secret_shares timing leaks?",
    "Field Element Overflow: y accumulation v0.rs:233 — overflow possible?",
    "X_power Accumulation: Issues with x^k accumulation?",
    "Share Request Replay: No nonce in gen_association_request v0.rs:435-451 — replay possible?",
    "PedersenOpen Zero Initialization: zero() correctness v0.rs:230 ?",
    "Share Distribution Ordering: Observing share order leaks which nodes get which shares?",

    # Category 5: Secret Share Verification (15 questions)
    "Verify_secret_share X-collision: node_id.eval_point v0.rs:253 collision?",
    "Commitment Linear Combination: Off-by-one errors v0.rs:257-264 ?",
    "X_power Initialization: Wrong initial value v0.rs:258 ?",
    "Commitment Addition Order: Reordering effects?",
    "Generator Consistency: Fresh generators v0.rs:268 mismatch original ones?",
    "Equality Check Timing: comb != generators.commit(eval) timing leak?",
    "Empty Commitments Array: coms empty v0.rs:248-251 — trivial acceptance?",
    "Verification Error Oracle: Failure as oracle?",
    "Filter_map Reconstruction Drop: attacker injecting many invalid shares v0.rs:494-506 ?",
    "Share Verification Before Storage: Flaw allows invalid shares stored v0.rs:199-200 ?",
    "Commitment Clone Safety: Clone issues v0.rs:260-262 ?",
    "X_power Multiplication Order: If reversed?",
    "Verification in Multiple Contexts: Same function used in different trust contexts exploitable?",
    "Partial Verification State: Exceptions leaking info?",
    "Zero Eval Attack: eval zero v0.rs:249 trivial acceptance?",

    # Category 6: Polynomial Interpolation Security (10 questions)
    "Interpolation Point Selection: Attacker influences points v0.rs:509 ?",
    "Insufficient Points: Exactly threshold but one malicious share?",
    "Lagrange Coefficient Overflow: Degenerate x values?",
    "Duplicate X-coordinates: Division by zero v0.rs:499 ?",
    "Interpolation at Known Points: Leakage via observing inputs/outputs?",
    "Y-coordinate Extraction: PedersenOpen::value() side channel?",
    "Points Vector Construction: filter_map inclusion bugs v0.rs:494-506 ?",
    "Interpolation Error Propagation: Silent errors?",
    "Field Element Stability: Non-exact arithmetic?",
    "Reconstruction Determinism: Non-deterministic algorithm?",

    # Category 7: Encapsulation Key Derivation (10 questions)
    "V0 Point Serialization: Non-canonical encodings allow multiple keys v0.rs:326-334 ?",
    "EncapKeyKDF Domain Separator: 'v0:encap-key' collision?",
    "Generator Multiplication: v0 = 0 case weak key?",
    "Affine Conversion: Timing leak v0.rs:329 ?",
    "Serialization Error Handling: DoS via encoding failures v0.rs:330-333 ?",
    "Key Derivation Collision: KDF collisions allow identical keys?",
    "V0_bytes Length: Variable-length input ambiguity?",
    "Reconstruction Key Consistency: Different serialization paths v0.rs:512-603 ?",
    "Encapsulation Key Storage: Key stored in EncapsulatedMsk v0.rs:136 leaked?",
    "Generator Consistency: GProjective::generator misuse?",

    # I. Recovery Mechanism Vulnerabilities (1-30)
    "In initiate_recovery, can a malicious actor with a compromised but invalid RIK bypass the verification at lines 186-192 by crafting a signature that matches a different association's verification key? v0.rs:171-193",
    "Does initiate_recovery verify that the account ID provided matches the actual account being recovered, preventing cross-account recovery attacks where an attacker provides their own account ID with another user's RIK? v0.rs:171-226",
    "In RecoverySecrets::complete, if multiple recovery attempts are in progress simultaneously, can an attacker reuse guardian shares from a previous recovery attempt for a different account? v0.rs:145-162",
    "Does complete verify that the recovery PKE decryption key used matches the one set in rec.pke, preventing decryption with a different key if an attacker replaces the recovery state? v0.rs:145-162",
    "In derive_msk_decryption_key, can an attacker who obtains msk_ss_rik from a corrupted minority of off-chain nodes and bruteforce/derive msk_ss_social from on-chain data reconstruct the MSK? v0.rs:329-358",
    "Does the KDF used in derive_msk_decryption_key provide sufficient domain separation to prevent key confusion attacks where the derived key could be valid for different contexts? v0.rs:329-358",
    "In initiate_recovery, when iterating through rec.assoc to find a valid RIK, can an attacker cause all associations to fail decryption and then exploit timing differences to identify which association was recently added? v0.rs:178-193",
    "Can an attacker replay an old AccountUpdateRecoveryV0 message to reset the recovery state to a previous PKE key, allowing them to intercept guardian shares meant for a newer recovery? v0.rs:802-832",
    "In verify_update for recovery messages, does the signature verification at lines 818-821 prevent a malicious actor from forging recovery requests if they compromise one association's signing key but not the RIK? v0.rs:802-832",
    "When rec.pke is set to Some(recovery.pke) during recovery initiation, can an attacker overwrite an existing recovery in progress, causing the original requester's guardian shares to be encrypted for the wrong key? v0.rs:829",
    "Does check_for_recovery verify that the requesting account is actually authorized to receive shares from this guardian's backup, preventing unauthorized share distribution? v0.rs:727-755",
    "In check_for_recovery, can a malicious user trigger multiple recovery requests and exhaust a guardian's ability to respond by forcing them to generate shares for invalid requests? v0.rs:727-755",
    "When calling decrypt_share_recovery at line 744, does the function verify that the backup belongs to the correct account to prevent cross-account share leakage? v0.rs:744-751",
    "In create_recovery, if threshold is set to 0, does this bypass guardian approval entirely, violating the invariant that recovery requires guardian approval? v0.rs:373-394",
    "Can an attacker manipulate the AADRecovery associated data to cause guardians to decrypt shares for the wrong account, enabling unauthorized recovery? v0.rs:361-367",
    "In update_recovery, when regenerating the social secret share, are old guardian shares invalidated to prevent mix-and-match attacks combining old and new shares? v0.rs:532-554",
    "Does initiate_recovery protect against timing attacks where an attacker measures decryption time differences to determine which association index corresponds to a valid RIK? v0.rs:178-193",
    "In RecoverySecrets, can an attacker who compromises the dkey field decrypt other users' recovery states if the same PKE key is somehow reused? v0.rs:130-135",
    "When rec.social.recover is called, does it verify that the shares provided are from the current recovery session and not replayed from a previous session? v0.rs:147-151",
    "Can an attacker provide malformed guardian shares to complete that cause guardians to be blamed for providing invalid data when the issue is actually share corruption? v0.rs:145-162",
    "In verify_update for recovery, does the code prevent an attacker from setting rec.pke to None after recovery has started, potentially locking out legitimate recovery attempts? v0.rs:829",
    "Does initiate_recovery ensure that the newly generated dkey has sufficient entropy, or can weak RNG compromise the confidentiality of guardian shares? v0.rs:196",
    "Can an attacker who obtains RecoverySecrets from a client's local storage impersonate the account owner to guardians and collect unauthorized shares? v0.rs:130-135",
    "In check_for_recovery, when rec_st.pke.is_none() returns true, does this leak information about whether recovery has been initiated, enabling timing attacks? v0.rs:738-740",
    "Does RecoverySecrets::complete enforce that the account ID in self.acc matches the account being recovered to prevent cross-account key derivation? v0.rs:154-158",
    "Can an attacker manipulate the rec.enc_msk ciphertext to cause MSK decryption failures that permanently lock the account after recovery? v0.rs:161",
    "In create_recovery, does passing an empty guardians slice with threshold: 0 create a recovery backup that can be reconstructed without any guardian approval? v0.rs:373-394",
    "When send_for_recovery encrypts shares for recovery_pke, can an attacker substitute this key to intercept shares meant for the legitimate account owner? v0.rs:155-179",
    "Does verify_update for recovery messages prevent replay attacks where an old signed recovery request is resubmitted after the RIK has been rotated? v0.rs:802-832",
    "Can an attacker exploit the find_map operation in initiate_recovery to leak information about the number of valid associations through observable behavior differences? v0.rs:178-193",

    # II. Key Management and Rotation (31-50)
    "In new_msk, when the MSK is rotated, are all dependent encrypted materials (backups, recovery state) properly re-encrypted or invalidated? v0.rs:480-483",
    "Does new_sig preserve the old signing key in old_sig correctly to ensure that pending account updates can still be verified? v0.rs:486-489",
    "When new_pke rotates the encryption key, does it verify that all old encrypted shares can still be decrypted with keys in old_pke? v0.rs:492-496",
    "Can an attacker force unlimited growth of old_pke or old_msk vectors through repeated key rotations, eventually causing memory exhaustion or performance degradation? v0.rs:492-496",
    "In gen, does the account ID derivation from the verification key prevent collisions where two different signing keys map to the same account ID? v0.rs:404",
    "When generating fresh keys in gen, is the RNG properly seeded to prevent predictable key generation across multiple accounts? v0.rs:397-440",
    "Does new_pke ensure that the old PKE key is not immediately removed from old_pke, preventing decryption failures for in-flight backup shares? v0.rs:492-496",
    "Can an attacker exploit the fact that old_sig is set to the current sig during initialization to forge signatures if they compromise old_sig later? v0.rs:424-426",
    "In update, are old MSK values in old_msk properly included in the encrypted state to allow backward compatibility for decrypting old backups? v0.rs:672-676",
    "Does the dirty flag correctly track all state modifications that require a version increment, preventing stale state attacks? v0.rs:637",
    "When old_pke contains multiple keys, does decrypt_share try them in a predictable order that could leak timing information about when keys were rotated? v0.rs:595-602",
    "Can an attacker cause account lockout by corrupting old_sig such that neither the current nor old signing keys can produce valid signatures? v0.rs:719",
    "In new_msk, does rotating the MSK invalidate the recovery state's enc_msk, requiring a full recovery setup refresh? v0.rs:480-483",
    "When AccountSecrets::gen creates initial recovery secrets with empty guardians and threshold 0, does this violate the invariant that recovery requires guardian approval? v0.rs:407-416",
    "Does new_sig update the account ID if the signing key changes, or can this cause the account to become unreachable? v0.rs:486-489",
    "Can an attacker exploit race conditions between multiple concurrent calls to new_pke to cause old_pke to miss storing a key? v0.rs:492-496",
    "In decrypt, if the MSK is incorrect, does the error message leak information about which specific decryption step failed? v0.rs:251-289",
    "When old MSKs are stored in old_msk, is there a maximum retention period or count to prevent indefinite storage of sensitive key material? v0.rs:58",
    "Does gen verify that the generated msk_ss_rik and msk_ss_social have sufficient entropy and are not reused across accounts? v0.rs:407-408",
    "Can an attacker who observes multiple update transactions infer that key rotation occurred by analyzing the encrypted state size changes? v0.rs:669-689",

    # III. Backup Management (51-70)
    "In add_backup, can a malicious user add the same backup ciphertext multiple times to inflate storage costs or cause processing overhead? v0.rs:503-507",
    "Does remove_backup verify ownership before removing a backup, or can any user remove backups from shared storage? v0.rs:510-514",
    "In mark_recovery, when moving a backup from backups to recover, does the function verify that the backup is actually decryptable by the account? v0.rs:517-526",
    "Can an attacker exhaust the backups or recover vectors by repeatedly adding backups without removing old ones? v0.rs:503-507",
    "Does mark_recovery prevent marking the same backup for recovery multiple times, potentially causing duplicate guardian share requests? v0.rs:517-526",
    "In decrypt_share_backupy, does using AADBackup with the wrong account ID allow decryption of another user's backup shares? v0.rs:556-562",
    "Can an attacker replace backups in the backups vector with malicious ciphertexts that cause denial of service when guardians attempt to decrypt shares? v0.rs:503-507",
    "Does recover_backups expose all backup ciphertexts publicly, potentially leaking metadata about the number and types of backups? v0.rs:246-248",
    "In decrypt_share, when trying old_pke.last() as a fallback, does this create timing differences that leak information about recent PKE rotations? v0.rs:600",
    "Can an attacker cause decrypt_share to return None by manipulating the EncryptionContext parameters, causing guardians to believe they're not authorized for a backup? v0.rs:572-603",
    "Does remove_backup properly synchronize removal across both backups and recover vectors to prevent orphaned entries? v0.rs:510-514",
    "In add_backup, is there validation that the backup ciphertext is well-formed and decryptable before adding it to the account state? v0.rs:503-507",
    "Can an attacker exploit the comment at line 501-502 about no unique ID guarantees to create confusion about backup ownership? v0.rs:499-502",
    "Does mark_recovery verify that the backup ID exists in backups before attempting to move it, preventing unnecessary error conditions? v0.rs:519-522",
    "In decrypt_share_recovery, can an attacker provide a backup encrypted with AADRecovery when the guardian expects AADBackup, causing authorization failures? v0.rs:564-570",
    "When decrypt_share returns Some, does it verify that the decrypted share corresponds to the expected backup ID to prevent share substitution attacks? v0.rs:572-603",
    "Can an attacker cause guardians to decrypt the same backup multiple times by repeatedly marking and unmarking it for recovery? v0.rs:517-526",
    "Does update ensure that backups and recover vectors are properly serialized and deserialized without data loss? v0.rs:705-706",
    "In decrypt_v0 helper function, can an attacker exploit the batch decryption mechanism to cause out-of-bounds errors if the index is manipulated? v0.rs:573-593",
    "Does the system prevent an attacker from cloning backups across multiple accounts by reusing the same BackupCiphertext? v0.rs:503-507",

    # IV. Association Management (71-85)
    "In add_association, can an attacker add unlimited associations to cause the assoc vector to grow unboundedly, exhausting resources? v0.rs:605-619",
    "Does revoke_association verify that the RIK being revoked actually exists before modifying the assoc vector? v0.rs:622-632",
    "In update, when generating associations, does the function ensure that all RIKs are encrypted with fresh randomness to prevent ciphertext linking? v0.rs:640-666",
    "Can an attacker exploit the comment at line 640 about hiding which association is being modified to perform differential analysis on multiple update transactions? v0.rs:639-641",
    "Does add_association return the generated RIK through a secure channel, or can it be intercepted during transmission to compromise recovery? v0.rs:605-619",
    "In revoke_association, can an attacker cause the function to fail silently by providing an invalid RIK, leaving the association active? v0.rs:622-632",
    "When multiple associations exist, does initiate_recovery try all of them in a predictable order that could leak information about which association is actively used? v0.rs:178-193",
    "Can an attacker who compromises one association's signing key generate valid recovery requests without knowing the RIK? v0.rs:647-665",
    "Does update ensure that the generated signing keys for associations are unique across all associations to prevent signature confusion? v0.rs:647",
    "In revoke_association, if the revoked RIK was stored by off-chain nodes, are those nodes notified to delete their shares? v0.rs:622-632",
    "Can an attacker determine the number of associations by analyzing the size of the assoc vector in the encrypted state? v0.rs:640-666",
    "Does add_association verify that the newly generated RIK is not accidentally reused from a previous association? v0.rs:612",
    "In update, when encrypting EncapV0, does the function use proper domain separation to prevent key confusion between different associations? v0.rs:650-658",
    "Can an attacker exploit the find_map operation in initiate_recovery to cause timing variations based on the position of the valid association in the vector? v0.rs:178-193",
    "Does revoke_association set the dirty flag before returning an error to prevent state inconsistencies? v0.rs:630-631",

    # V. State Encryption & Decryption (86-105)
    "In decrypt, can an attacker provide a malicious AccountStateV0Ad with an incorrect version to bypass version checks? v0.rs:251-289",
    "Does update use proper associated data in AccountStateV0Ad to bind the ciphertext to the specific account and version? v0.rs:685-688",
    "In decrypt, if the MSK is incorrect, does the error reveal whether the failure was due to MAC verification or deserialization? v0.rs:253-260",
    "Can an attacker exploit the act field in AccountStateV0 to substitute encrypted state from another account? v0.rs:232",
    "Does update ensure that the encrypted act ciphertext is properly bound to the account ID to prevent cross-account attacks? v0.rs:669-689",
    "In decrypt, are old_msk and old_pke vectors properly validated to prevent unbounded growth attacks through repeated decryption attempts? v0.rs:261-287",
    "Can an attacker manipulate the cnt field during encryption to cause version confusion between multiple account states? v0.rs:637",
    "Does decrypt verify that the decrypted CombinedSecret is of the expected version (V0) before processing? v0.rs:261-266",
    "In update, when sealing the combined secret, is sufficient randomness used to prevent nonce reuse across multiple updates? v0.rs:669-689",
    "Can an attacker cause deserialization errors by crafting malformed CombinedSecretV0 that passes MAC verification but fails to parse? v0.rs:67-74",
    "Does the AccountCiphertext type provide sufficient abstraction to prevent direct ciphertext manipulation? v0.rs:316",
    "In decrypt, are the signing and PKE keys from CombinedSecretV0 validated to match the public keys in the account state? v0.rs:261-287",
    "Can an attacker exploit race conditions between update calls to cause the cnt version to skip values or wrap around? v0.rs:637",
    "Does update properly handle the case where dirty is false, ensuring no state changes are committed? v0.rs:636-637",
    "In decrypt, if the old_sig field doesn't match the current signing key, does this indicate potential state corruption? v0.rs:269",
    "Can an attacker replay an old encrypted state with a lower cnt value to rollback account changes? v0.rs:637",
    "Does update ensure that the rec.enc_msk is re-encrypted whenever recovery parameters change? v0.rs:692-701",
    "In decrypt, are sensitive fields like msk and sig zeroized from memory after decryption failures? v0.rs:267-287",
    "Can an attacker extract partial plaintext information by analyzing MAC verification failures for different ciphertexts? v0.rs:253-260",
    "Does AccountStateV0Ad provide sufficient domain separation to prevent the same ciphertext from being valid under different account IDs? v0.rs:318-322",

    # VI. Signature Verification (106-120)
    "In verify_allocation, does checking st.cnt != 0 prevent attackers from submitting pre-allocated accounts with non-zero versions? v0.rs:765-767",
    "Does verify_allocation ensure that the account ID is derived correctly from the verification key to prevent ID spoofing? v0.rs:770-772",
    "In verify_update, can an attacker bypass version increment checks by exploiting integer overflow in checked_add(1)? v0.rs:792-794",
    "Does verify_update use constant-time comparison for signature verification to prevent timing attacks? v0.rs:797",
    "In update, when signing with old_sig, does this create a window where an attacker can forge updates using a compromised old key? v0.rs:719",
    "Can an attacker exploit the fact that verify_update accepts recovery messages to bypass normal signature verification? v0.rs:802-832",
    "Does verify_update prevent replay attacks where an old valid signature is reused with a different state? v0.rs:789-801",
    "In verify_update for recovery, when iterating through associations, does the function prevent timing attacks based on the number of iterations? v0.rs:815-822",
    "Can an attacker provide a recovery signature that verifies against multiple associations, creating ambiguity about which association initiated recovery? v0.rs:815-822",
    "Does verify_allocation validate that all fields in the initial state are properly initialized before accepting the allocation? v0.rs:760-783",
    "In update, is the signature computed over the complete AccountStateV0 including all nested structures? v0.rs:719",
    "Can an attacker manipulate the RecoveryRequestMessage fields to create a valid signature for an unintended recovery? v0.rs:809-812",
    "Does verify_update ensure that the new state cannot have fields set to attacker-controlled values despite valid signatures? v0.rs:789-801",
    "In verify_update, when handling recovery messages, does setting verified = false initially protect against logic errors? v0.rs:815",
    "Can an attacker exploit the signature verification at line 775 to cause denial of service through expensive cryptographic operations? v0.rs:775",

    # VII. Guardian Share Handling (121-135)
    "In check_for_recovery, does cloning self at line 743 create security risks if the clone is not properly protected? v0.rs:743",
    "Can an attacker cause check_for_recovery to return invalid guardian shares by manipulating the state parameter? v0.rs:727-755",
    "Does check_for_recovery verify that the requesting account has permission to receive shares before calling send_for_recovery? v0.rs:754",
    "In decrypt_share, when decryption fails with the current PKE key, does trying old_pke.last() leak information about key rotation? v0.rs:597-601",
    "Can an attacker exploit the decrypt_batch function to cause guardians to decrypt shares for unintended recipients? v0.rs:578-587",
    "Does check_for_recovery handle the case where multiple recovery requests are active simultaneously? v0.rs:727-755",
    "In decrypt_share_backupy, can providing the wrong acc parameter cause guardians to decrypt shares for a different account? ???",
    # Remaining 14 guardian-share questions from 136-150 will be added if you supply the missing tail of the text.

    "In Association::create_association, can an attacker who observes the EncapsulatedMsk on-chain reverse the VDRF evaluation to determine the user's email address, violating the anonymity invariant that only corrupted off-chain nodes should learn email associations?",
    "Does EmailKey::new in v0.rs properly verify that the VDRF evaluation corresponds to the claimed email input before accepting it as valid, or can an attacker forge email keys by providing arbitrary evaluation outputs?",
    "In AssociationV0::gen_node_secret_share, is the email certificate token generation vulnerable to replay attacks where a malicious node could reuse a token from one node_id on a different node_id to impersonate the user?",
    "Can a corrupted minority of off-chain nodes correlate multiple NodeSecretShare instances by comparing the msk_result field, thereby linking a user's email across different nodes and violating email privacy?",
    "Does the EmailInput struct's from_str implementation sanitize or normalize email addresses consistently, or can attackers create multiple associations for the same logical email using different string representations?",
    "In the VDRF evaluation flow, can an attacker who compromises a single off-chain node extract the email from the EmailCertificate and brute-force match it against on-chain EncapsulatedMsk using the VDRF public key?",
    "Does the EmailTag type implement domain separation or binding to prevent an attacker from using the same email tag to associate multiple accounts?",
    "Can a network adversary performing timing analysis on gen_node_secret_share distinguish different email addresses based on VDRF token generation timing?",
    "If the EmailCertificate expires but the EncapsulatedMsk remains stored on-chain, can an attacker bypass freshness checks and re-associate the same email to different accounts?",
    "In gen_association_request, is there a binding between EmailCertToken and AssociationRequestEmail to prevent token substitution attacks?",
    "Does Association::new verify that the provided email certificate matches the user_secret_key public key, preventing mismatched credentials?",
    "Can multiple users call create_association with the same threshold and receive colliding EncapsulatedMsk commitments that link accounts?",
    "In AssociationV0::new, is there validation that msk_result corresponds to the user_secret_key through the SoK proof, preventing inconsistent data?",
    "Does the protocol prevent a user from creating multiple associations for the same email by repeatedly calling create_encrypted_msk with different RIK values?",
    "Can an attacker observing the EmailCertificate message forge a valid association by crafting their own EncapsulatedMsk with the same user_pk?",
    "In gen_node_secret_share, does the function generate a fresh random nonce per node_id, or could deterministic tokens be predicted by attackers?",
    "If a user calls gen_node_secret_share multiple times for the same node_id, will identical shares leak fingerprinting information?",
    "Can corrupted off-chain nodes perform timing side-channel analysis on NodeSecretShare verification to infer email patterns?",
    "Does compute_secret_shares implement constant-time evaluation to prevent timing leakage of node_id or polynomial coefficients?",
    "In compute_secret_shares, can integer overflow in x_power computation cause incorrect shares for large node_id hash values?",
    "Does AssociationRequestEmail::verify check certificate revocation by Swafe-io before accepting association requests?",
    "Can an attacker replay old AssociationRequestEmail messages with expired certificates if timestamp freshness isn't validated?",
    "In gen_association_request, is there protection to prevent callers from requesting shares for node_ids they do not control?",
    "Does EmailCertToken binding in gen_node_secret_share prevent MITM replaying tokens to different nodes?",
    "Can a user with a valid email certificate for one account use it to create associations for multiple accounts, violating uniqueness?",
    "If threshold−1 nodes are corrupted, can they statistically narrow down email addresses via share analysis?",
    "Does the system prevent corrupted nodes from requesting shares for fake node_ids to identify email patterns through differential analysis?",
    "Can an attacker who compromises email certificate storage on one node extract all emails and match them to on-chain accounts using VDRF?",
    "After a node compromise and recovery, is there a mechanism for rotating exposed email certificates or detecting leakage?",
    "Does EmailKey derivation use a cryptographically secure hash preventing rainbow-table precomputation attacks?",
    "In reconstruct_rik_data, can attackers controlling fewer than threshold shares provide corrupted shares that still pass reconstruction?",
    "Does majority voting in reconstruct_rik_data handle exact ties deterministically, or could this yield inconsistent reconstruction?",
    "Can malicious nodes provide invalid shares that pass verify_secret_share but break interpolate_eval and v_0 reconstruction?",
    "Does silently ignoring invalid shares allow attackers to force discarding good shares until fewer than threshold remain?",
    "Does reconstruct_rik_data verify that reconstructed RikSecretData corresponds to user_pk, preventing data substitution?",
    "Can attackers exploit div_ceil(2) majority logic to trigger reconstruction with fewer than the intended threshold?",
    "Can attackers submit >threshold malicious shares and dominate majority voting to select incorrect fixed fields?",
    "Does interpolate_eval handle duplicate node_ids safely, preventing division-by-zero or incorrect interpolation?",
    "Can users who lose RIK but control threshold nodes reconstruct another user’s RIK if identity isn't verified?",
    "Can users repeatedly reconstruct RIK data, causing off-chain state inconsistencies or resource exhaustion?",
    "Does encapsulation key derivation provide domain separation preventing KDF reuse across contexts?",
    "Can attackers observing v0_point reverse the KDF and recover v_0, enabling unauthorized decryption?",
    "Is the recovered symmetric key properly zeroized during reconstruct_recovery_key?",
    "Can attackers brute-force v_0 if KDF stretching is insufficient?",
    "Can floating-point precision errors during point serialization cause incorrect encapsulation key derivation?",
    "Does authenticated encryption in create_encrypted_msk bind ciphertext to user identity?",
    "Can attackers perform chosen-ciphertext attacks by modifying encrypted RIK and observing reconstruction?",
    "Does symmetric::seal use a secure random nonce to avoid nonce reuse?",
    "Can attackers supply a valid RIK for one user and decrypt another user's data during reconstruction?",

    # =========================
    # Category 1: Account Identification and Initialization (1–15)
    # =========================

    "AccountId Derivation from Verification Key: In AccountId::from_vk(), the account ID is derived as hash(vk). Can an attacker generate collisions by finding two different verification keys that hash to the same AccountId, allowing them to claim ownership of another user's account?",
    "AccountId Constructor Exposure: The from_vk() method is pub(crate) while from_verification_key() is public. Could inconsistent access patterns allow external code to bypass intended visibility restrictions in account creation flows?",
    "AccountId Hash Function Security: The AccountId::from_vk() uses a generic hash() without domain separation. Could this lead to hash collisions with other system components?",
    "Account Allocation Without Email Verification: In AccountUpdateV0::verify_allocation(), an account can be allocated if acc == AccountId::from_vk(&st.sig). Can an attacker create multiple accounts without email association, bypassing the intended recovery mechanism?",
    "Initial Account State Validation: Allocation checks only st.cnt != 0 and signature validity. Are there other state fields that should be validated to prevent malicious initial configurations?",
    "MSK Randomness Quality: In AccountSecrets::gen(), the MSK is generated using rng.gen(). If RNG is weak or compromised, could an attacker predict the MSK?",
    "MSK Secret Share Independence: msk_ss_social and msk_ss_rik are independently generated. Could correlation reduce security?",
    "Initial Recovery State Setup: Initial account creates a recovery backup with empty guardians and threshold 0. Could this allow unauthorized recovery before configuration?",
    "Old Key Initialization: old_msk and old_pke start empty. Could this break key rotation if code assumes non-empty history?",
    "Signing Key Reuse: sig and old_sig are initialized to same key. Could this confuse verification logic?",
    "Dirty Flag Manipulation: dirty flag controls version increments. Could an attacker manipulate it to avoid version increments?",
    "Version Counter Overflow: cnt is u32. Could overflow create replay attacks?",
    "Multiple Old Keys Storage: old_pke can grow unbounded. Could it cause bloat or DoS?",
    "Old MSK Vector Purpose: old_msk never populated. Does this indicate incomplete rotation logic?",
    "Recovery Secrets Exposure: AccountSecretsV0Recovery contains sensitive fields. Are these zeroized on drop?",

    # =========================
    # Category 2: State Encryption and Decryption (16–30)
    # =========================

    "AccountState Encryption Context: Does the AAD include all required info to prevent ciphertext replay across accounts?",
    "Version-Based AAD Binding: Can attackers replay ciphertext with version N to version N+1 via dirty flag manipulation?",
    "MSK Encryption Key Derivation: Is the KDF domain-separated to prevent key reuse?",
    "Encrypted MSK Binding: Does encryption bind MSK to account ID to prevent substitution?",
    "Association Encapsulation Security: Is RIK-based encryption bound to prevent reuse across accounts?",
    "Decryption Version Mismatch: Can attackers exploit version mismatch in AAD?",
    "CombinedSecret Version Downgrade: Can downgrade attacks return older versions?",
    "Old Key Restoration: Could discrepancies between decrypted old_sig and current sig bypass verification?",
    "Recovery State Clone: Could cloning desynchronize state if social backup changes later?",
    "Dirty Flag Not Reset: Could dirty=false after decryption cause update issues?",
    "Share Combination Method: Could serialization order changes break key security?",
    "KDF Info Structure: Should more context be included to prevent key reuse?",
    "Share Type Confusion: Can attackers swap RIK and social shares?",
    "Key Output Binding: Does decrypted MSK prove it matches original ciphertext?",
    "Symmetric Key Extraction: Could aliasing cause reused key material?",

    # =========================
    # Category 3: Account Update and Verification (31–50)
    # =========================

    "Dirty State Increment Logic: Can attackers set dirty=false to bypass version increment?",
    "Association Regeneration: Does regeneration leak timing or linkability?",
    "Old Signature Key Usage: Using old_sig for updates—can compromised old key forge updates?",
    "Backup List Cloning: Can attackers manipulate backup list client-side?",
    "Social Backup Immutability: Reusing social backup—can stale data be exploited?",
    "Zero Version Requirement: Could attacker craft version=0 update to reset state?",
    "AccountId Verification: Is hash collision-resistant enough?",
    "Signature Verification Timing: Could early rejection leak account existence?",
    "Recovery Message Rejection: Can message type confusion bypass rejection?",
    "Initial State Constraints: Could malicious initial recovery state be allocated?",
    "Version Increment Check: Could checked_add(None) be misinterpreted?",
    "Old Signature Verification: Could old key authorize updates indefinitely?",
    "State Replacement Without Validation: Could attacker inject malicious backups?",
    "Recovery State Modification: Could attacker disable recovery?",
    "Backup Addition Validation: Are new backups validated?",

    # =========================
    # Category 4: Recovery Initiation and Completion (51–75)
    # =========================

    "RIK Decryption Timing Attack: Can timing reveal valid associations?",
    "Verification Key Matching: Can attacker manipulate encrypted data to pass verification?",
    "Fresh Key Generation: Is RNG sound for ephemeral keys?",
    "Recovery Request Signature: Can attacker forge ephemeral key?",
    "MSK Share Leakage: Could error messages leak shares?",
    "RecoverySecrets Protection: Are sensitive fields protected in memory?",
    "State Clone in Recovery: Could modifications affect session?",
    "No Association Revocation Check: Can revoked RIK still recover?",
    "Account ID Mismatch: Can attacker initiate recovery for wrong account?",
    "Iterator Short-Circuit: Can ordering be detected via timing?",
    "Guardian Share Validation Missing: Can attacker submit fake shares?",
    "Social Share Recovery Parameters: Is EmptyInfo sufficient?",
    "MSK Decryption Key Security: Does compromising one share weaken MSK?",
    "EmptyInfo Parameter Risk: Should include session context?",
    "Account ID Binding in MSK Decryption: Is binding sufficient?",
    "No Threshold Validation: Can attacker attempt recovery with few shares?",
    "Decryption Key Lifetime: Can keys be replayed?",
    "Share Type Matching: Could V1 shares bypass checks?",
    "MSK Return Without Validation: Could corrupted MSK cause downstream issues?",
    "Recovery State Reuse: Could attacker replay recovery to extract MSK?",

    # =========================
    # Category 4B: Recovery Authorization (75–90)
    # =========================

    "Guardian Share Generation DoS: Can compromised guardian flood invalid shares?",
    "Recovery PKE Manipulation: Can attacker manipulate pke field to influence recovery?",
    "Guardian Authorization Check: Can non-guardian probe backup structure?",
    "Share Re-encryption Tampering: Can guardian tamper with re-encrypted shares?",
    "Account State Mutability: Can attacker supply modified state to guardian?",

    # =========================
    # Category 5: Association Management (76–90)
    # =========================

    "RIK Generation Entropy: Is RNG strong enough for RIK?",
    "Association Limit Missing: Could attacker bloat associations?",
    "Dirty Flag Mismanagement: Could attacker bypass version increments?",
    "Association Ordering: Does order leak timing or metadata?",
    "RIK Return Leakage: Is safe storage guaranteed?",
    "Revocation by RIK Theft: Could attacker revoke associations with stolen RIK?",
    "Revocation Without Confirmation: Can attacker revoke multiple associations silently?",
    "Dirty Flag After Revocation: Could attacker interrupt update to prevent revocation?",
    "Removing All Associations: Could attacker lock account permanently?",
    "Revocation Timing: Can revoked RIK still initiate recovery before update?",
    "Association Regeneration Cost: Could regeneration create DoS?",
    "Signing Key Generation Safety: Is entropy sufficient?",
    "Encapsulation Integrity: Can tampering with fields bypass decryption?",
    "RIK Reuse Across Updates: Does reuse create linkability?",
    "Verification Key Storage: Could keys link associations across updates?",

    # =========================
    # Category 6: Backup Management (91–105)
    # =========================

    "Backup Addition Without Validation: Can attacker add malformed backups?",
    "Duplicate Backup IDs: Could duplicates confuse recovery?",
    "Backup List Size: Could attacker bloat backups (DoS)?",
    "Dirty Flag Management: Could inconsistent dirty state corrupt updates?",
    "Backup Ordering Leakage: Does ordering leak creation time?",
    "Removing Backups in Recovery: Can attacker remove active recovery backups?",
    "Silent Removal: Can attacker spoof success?",
    "Dirty Flag on Removal: Can attacker force version increments?",
    "Recovery List Modification: Could removing from recover disrupt ongoing recovery?",
    "Concurrent Modifications: Could race conditions cause inconsistent lists?",
    "Marking All Backups for Recovery: Can attacker exhaust guardians?",
    "Recovery List Uniqueness: Could duplicates cause confusion?",
    "Backup Not Found Error Timing Leak: Can presence be inferred?",
    "State Consistency Risk: Crash between removal/addition?",
    "Guardian Notification Missing: Could guardians miss recovery requests?",

    # =========================
    # Category 7: Share Decryption & Distribution (106–120)
    # =========================

    "PKE Decryption DoS: Could attacker force many expensive decrypt attempts?",
    "Batch Decryption Index Manipulation: Can attacker access unintended shares?",
    "Generic AAD Parameter: Could AAD confusion lead to cross-context decryption?",
    "Old Key Fallback: Why only last old key? Could earlier keys be needed?",
    "Share Index Conversion: Could overflow create incorrect indexing?",
    "Encryption Context Binding: Are all components properly bound?",
    "Decrypted Share Return Type: Can wrapping cause type confusion?",

    # I. Serialization & Deserialization Vulnerabilities (1–30)
    "Panic on Deserialization in Mapping::load: Can a malicious actor craft a Key type that fails serialization at storage.rs:14-19, causing encode::serialize(&key).unwrap() to panic and DoS the node?",
    "Unhandled Deserialization Failure: At storage.rs:18, does malformed data cause encode::deserialize::<Value>().ok() to silently return None, blocking legitimate recovery operations?",
    "Panic on Serialization in store: Can attackers craft GuardianShare or MskRecord values that cause encode::serialize(&value).unwrap() to panic at storage.rs:21-27?",
    "Type Confusion via bincode: Can GuardianShareCollection data be deserialized as MskRecordCollection due to lack of type tagging at storage.rs:10?",
    "Version Mismatch in Deserialization: Can old serialized structs be deserialized into new incompatible types at storage.rs:14-19, causing undefined behavior?",
    "Bincode Integer Overflow: Can attacker-controlled tuple keys (AccountId, BackupId) overflow during serialization at storage.rs:17, creating key collisions?",
    "Non-Canonical Serialization: Can two crafted EmailKey objects serialize to identical bytes at storage.rs:17, causing multi-account collisions?",
    "Deserialization Bomb: Can a huge BTreeMap<u32, GuardianShare> cause memory exhaustion during deserialization at storage.rs:18?",
    "Malformed UTF-8 in COLLECTION_NAME: Can invalid bytes in COLLECTION_NAME at storage.rs:12 cause cross-collection contamination?",
    "Replay Attack via Old Deserialized State: Can attackers replay old MskRecord or GuardianShare data due to missing timestamp/nonce checks at storage.rs:14-19?",
    "Bincode Length Prefix Manipulation: Can attackers manipulate Vec<u8> length prefixes at storage.rs:17 for collisions or OOB reads?",
    "Bincode Endianness Issues: Can different architectures serialize values differently at storage.rs:24-25, causing cross-node inconsistencies?",
    "Unbounded BTreeMap Deserialization: Can attacker store massive GuardianShareCollection causing DoS at storage.rs:18?",
    "Recursive Structure Overflow: Can nested Value types cause stack overflow during bincode deserialization at storage.rs:18?",
    "Enum Type Confusion: Can bincode enum discriminant reuse allow one variant to deserialize as another at storage.rs:18?",
    "Missing Serialization Version Tag: Can old formats be misinterpreted by new code at storage.rs:8-28?",
    "Serialization Timing Side Channel: Can attackers measure timing differences in encode::serialize at storage.rs:24-25 to infer data?",
    "Padding Oracle in Serialized Data: Can repeated storing/loading leak information about MskRecord padding behavior?",
    "Canonical Encoding Violations: Can multiple EmailKey canonical forms be used to violate 1-email-1-account invariants?",
    "Signed/Unsigned Integer Confusion: Can AccountId or BackupId type confusion cause key access mixups?",
    "Silent Backend Failure: Can storage.insert at storage.rs:26 silently fail, misleading endpoints?",
    "Inconsistent Error Handling: Can load return None while store pretends success at storage.rs:21-27?",
    "Unwrap Panic Propagation: Can repeated serialization panics at storage.rs:24-25 destabilize the node?",
    "Error Message Leakage: Do serialization errors reveal sensitive internal structure?",
    "Partial Write on Panic: Can storage be left inconsistent if panic occurs after insert at storage.rs:26?",
    "Collection Name Collision: Can two Mapping implementations use the same COLLECTION_NAME at storage.rs:12 and overwrite each other?",
    "Collection Namespace Injection: Can malicious collection names with null bytes break storage namespace integrity?",
    "Type Safety Across Collections: Can identical collection names cause cross-type deserialization?",
    "Deserialization Type Downgrade: Can attacker use permissive Mapping<Value> to store invalid guardian shares or email associations?",
    "Prefix Collision: Can crafted COLLECTION_NAME prefixes collide with others in ctx.storage()?",

    # II. Key Collision & Manipulation Attacks (31–55)
    "Singleton Key Security: Can OffchainSecrets using Key=() allow one node to overwrite another’s secrets?",
    "Predictable Unit Key Serialization: Does () serialize to a fixed value attackers can spoof?",
    "Unit Key Replay Across Nodes: Can attackers replay OffchainSecret store ops across nodes?",
    "Missing Node Identity in Key: Does Key=() allow cross-node secret contamination?",
    "Unit Key Collision: Can () collide with other zero/default keys in backend?",
    "VDRF Output Collision: Can two different emails produce identical EmailKey values?",
    "EmailKey Malleability: Can multiple serializations of EmailKey leak associations?",
    "Weak Hash in EmailKey: Can attackers create colliding (pk, email, eval) tuples?",
    "Field Ordering Attacks: Can EmailKey field order be exploited to force collisions?",
    "VDRF Eval Replay: Can vdrf_eval be reused with different email addresses?",
    "Tuple Component Swap: Can (AccountId, BackupId) be swapped in serialization?",
    "AccountId Hash Collision: Can attacker create colliding AccountId values?",
    "BackupId Overflow: Can large BackupId values overflow and collide during serialization?",
    "Tuple Padding Manipulation: Does tuple padding allow crafted collisions?",
    "Zero-Value Components: Can zero AccountId / BackupId trigger special-case serialization?",
    "Prefix Injection: Can serialized keys include collection prefixes?",
    "Control Character Injection: Can AccountId contain null/newlines to break key parsing?",
    "Variable-Length Key Prefix Attack: Can attacker craft keys that prefix-match others?",
    "Canonicalization Bypass: Can non-canonical representations collide with valid keys?",
    "Unicode Homograph Key Attack: Can homoglyphs create near-identical serialized keys?",
    "Key Space Enumeration: Can attackers iterate all EmailKeys via load calls?",
    "Timing Attack on Key Existence: Does load reveal timing differences between hit/miss?",
    "Range Query Leakage: Can storage ordering reveal account/backup relationships?",
    "Predictable BackupId Patterns: Can predictable values leak account patterns?",
    "Key Metadata Leakage: Does backend expose metadata on keys (size, timestamps)?",

    # III. Data Integrity & Authentication (56–80)
    "No MAC on Stored Values: Can attacker tamper with GuardianShare values?",
    "Missing MskRecord Signature Verification: Can old MskRecords be replayed?",
    "Missing Commitment Verification: Can storage return shares inconsistent with on-chain commitments?",
    "No Merkle Tree: Can attacker corrupt selective values undetected?",
    "Missing Key-Value Binding: Are values not bound to their specific keys?",
    "Temporal Replay: Can old email associations be restored?",
    "Cross-Account Replay: Can shares for one account be replayed to another?",
    "Guardian Share Rollback: Can system use old compromised shares?",
    "State Snapshot Rollback: Can entire storage be replaced with older version?",
    "Cross-Node Replay: Can storage ops be replayed to foreign nodes?",
    "Guardian Share Substitution: Can malicious guardian upload misleading shares?",
    "Share Index Manipulation: Can u32 index in BTreeMap be altered?",
    "Ciphertext Mauling: Can attacker modify MskRecord ciphertext to leak info?",
    "Value Size Manipulation: Can size-skewed values break cryptographic ops?",
    "Partial Value Corruption: Can attacker flip specific bytes to break recovery?",
    "Missing Schema Versioning: Can format changes break old data?",
    "Forward Compatibility: Can new data break older nodes?",
    "Backward Compatibility: Can old data bypass new security checks?",
    "Migration Path Absence: Can upgrades cause data loss?",
    "Type Evolution Security: Can old values bypass new security fields?",
    "Race in load-modify-store: Can concurrent requests cause lost updates?",
    "TOCTOU in share upload: Can backup mutate before store?",
    "Non-Atomic Batch Ops: Can partial writes leave inconsistent state?",
    "Missing Optimistic Locking: Can concurrent stores silently overwrite?",
    "Stale Read After Write: Can load retrieve stale data after store?",

    # IV. Privacy & Information Leakage (81–105)
    "EmailKey Leaks Email Hash: Can attackers infer email from key structure?",
    "Access Pattern Leakage: Can load frequency reveal user behavior?",
    "Email Timing Side Channel: Does load time depend on email properties?",
    "VDRF Output Linkability: Can repeated VDRF outputs correlate accounts?",
    "Email Enumeration via Value Size: Does MskRecord size reveal email traits?",
    "Share Count Leakage: Does BTreeMap size reveal t and n parameters?",
    "Guardian Identity Inference: Do GuardianShare fields leak guardian identity?",
    "Threshold Parameter Leakage: Can number of shares reveal threshold t?",
    "Share Upload Timing: Can timing correlate guardians working together?",
    "Missing Share Detection: Can attacker infer unuploaded shares?",
    "AccountId Correlation: Does AccountId serialization leak identity?",
    "Backup Count Enumeration: Can attackers detect number of backups per account?",
    "Storage Occupancy: Can presence of collections leak feature usage?",
    "Value Size Fingerprinting: Does serialized size reveal account metadata?",
    "Collection Growth Monitoring: Can attackers infer usage patterns from collection size?",
    "Storage Sync Leakage: Does node sync traffic reveal activity?",
    "Node Diff Leakage: Do differences across nodes leak user preferences?",
    "Backend Query Leakage: Do logs reveal which keys are accessed?",
    "Cache Timing Attacks: Do cache hit/miss timings leak key presence?",
    "Key Enumeration: Can backend iteration reveal all users?",
    "Deterministic Serialization Privacy: Can known plaintext attacks identify values?",
    "Padding Pattern Leakage: Does padding reveal structure?",
    "Field Ordering Leakage: Can serialization order leak struct layout?",
    "Serialization Error Leakage: Do errors reveal sensitive info?",
    "Null Field Detection: Does size variation reveal optional fields?",

    # V. Access Control & Authorization (106–120)
    "No Caller Authentication: Can any endpoint call store/load?",
    "OffChainContext Trust Boundary: Can forged contexts bypass access control?",
    "No Key Ownership Check: Can attacker read arbitrary keys?",
    "Missing Write Permission Checks: Can attacker overwrite victim data?",
    "No Collection-Level ACLs: Can any endpoint access any collection?",
    "Cross-Account Write: Can attacker submit shares for wrong AccountId?",
    "Email Association Hijacking: Can attacker overwrite MskRecord for victim?",
    "Privilege Escalation: Can low-privilege code read/write OffchainSecrets?",
    "Guardian Impersonation: Can attacker upload shares without proving guardian identity?",
    "Unauthorized Secret Modification: Can attacker overwrite node secrets?",
    "Cross-Endpoint Access: Can endpoints read irrelevant collections?",
    "Namespace Confusion: Can requests trigger wrong collection loads?",
    "Arbitrary Mapping Implementations: Can malicious code access arbitrary storage?",
    "Forged OffChainContext: Can manipulated context bypass all checks?",

    # I. HTTP Router Dispatch & Routing Logic (1–30)
    "In HttpRouter::dispatch(), can an attacker craft a URI with path traversal sequences (e.g., ../, ./) to bypass route registration and access unintended endpoints, potentially violating access control for sensitive operations like account recovery? mod.rs:88-91",
    "Does the matchit::Router library used in HttpRouter::dispatch() properly canonicalize URIs before matching, or could an attacker use URL-encoded characters, double slashes, or Unicode normalization tricks to access routes that should be restricted? mod.rs:83-86",
    "In register_routes(), what prevents an attacker from registering duplicate or overlapping routes that could shadow legitimate endpoints, potentially redirecting sensitive operations like backup reconstruction to malicious handlers? mod.rs:140-156",
    "Can the router.insert() call in HttpRouter::dispatch() fail with a panic instead of returning an error, causing a denial of service when conflicting routes are detected during runtime? mod.rs:85-86",
    "Does HttpRouter::insert() validate that the route parameter doesn't contain null bytes or other control characters that could cause routing confusion in the underlying matchit library? mod.rs:65-68",
    "In HttpRouter::dispatch(), if request.uri contains query parameters or fragments (e.g., /init?param=value#fragment), are these properly stripped before route matching to prevent bypassing authentication checks? mod.rs:88-91",
    "Could an attacker exploit the Params extraction mechanism to inject malicious parameter values that are not validated by endpoint handlers, leading to unauthorized access to accounts or backups? mod.rs:103-104",
    "Does the routing logic enforce HTTPS-only access for sensitive endpoints like VDRF evaluation and account recovery, preventing man-in-the-middle attacks that could leak email certificates or recovery shares? mod.rs:77-104",
    "Can an attacker send requests with extremely long URIs to exhaust memory during route matching in router.at(), causing denial of service on the off-chain node? mod.rs:89-91",
    "In HttpRouter::dispatch(), if multiple HttpMethod variants are registered for the same route, does the method lookup properly distinguish between GET, POST, and PUT to prevent unintended state modifications? mod.rs:95-101",
    "In HttpMethod::method_type(), the comparison uses to_lowercase() on the request method. Could an attacker send a method with mixed case or non-standard casing to bypass method validation? mod.rs:97-100",
    "Does the HttpMethod enum properly restrict which HTTP verbs are allowed? Could an attacker use HEAD, OPTIONS, TRACE, or CONNECT methods to bypass security checks or leak information? mod.rs:107-117",
    "In the route registration for init endpoint, why is only POST method allowed? Could a malicious node repeatedly initialize the VDRF node by crafting GET requests if the method check is bypassed? mod.rs:149-155",
    "Can an attacker chain multiple HTTP methods (e.g., POST followed by GET) to the same endpoint to bypass idempotency checks or re-execute one-time operations like account initialization? mod.rs:95-101",
    "Does HttpMethod::get_function() return a reference to the dispatch function without additional validation? Could function pointer manipulation lead to calling wrong handlers? mod.rs:130-136",
    "In HttpRouter::dispatch(), when a route is not found, the error message 'Invalid URL' is returned. Does this leak information about which endpoints exist on the contract? mod.rs:89-91",
    "When an invalid HTTP method is used, the error message 'Invalid method' is returned. Could an attacker use timing differences between 'route not found' and 'method not allowed' responses to enumerate valid routes? mod.rs:98-100",
    "In http_dispatch(), errors are converted using unwrap_or_else() to return the error response directly. Could sensitive information from ContractError or ServerError be leaked in HTTP responses? mod.rs:170-171",
    "Does the error handling distinguish between client errors (4xx) and server errors (5xx)? Could an attacker infer internal state by observing which error codes are returned for different malformed requests? error.rs:62-110",
    "When json::json_error() is called with a custom error message, are there any injection vulnerabilities if the error string contains untrusted data from the request? json.rs:27-32",
    "In deserialize_request_body(), the function converts the request body to UTF-8. What happens if a user sends a valid JSON request with non-UTF-8 bytes that could pass through to underlying crypto operations? mod.rs:17-19",
    "Does std::str::from_utf8() properly validate UTF-8 sequences? Could an attacker send overlong UTF-8 encodings or malformed sequences to bypass input validation in endpoint handlers? mod.rs:18-19",
    "In deserialize_request_body(), after UTF-8 validation, the body is deserialized using json::from_str(). Could an attacker exploit differences between JSON parsers (serde-json-wasm vs standard serde_json) to craft payloads that bypass validation? mod.rs:22-23",
    "Does the JSON deserialization enforce maximum depth or recursion limits to prevent stack overflow attacks when parsing deeply nested JSON objects? json.rs:17-24",
    "Can an attacker send JSON with duplicate keys (e.g., {'account_id': 'A', 'account_id': 'B'}) to cause undefined behavior in deserialization, potentially bypassing account ownership checks? mod.rs:13-23",
    "In deserialize_request_body(), if the generic type T implements custom deserialization logic, could an attacker craft inputs that exploit unsafe deserialization patterns in the endpoint types? mod.rs:13-23",
    "Does the InvalidRequestBody error reveal whether the failure was due to non-UTF-8 bytes or invalid JSON structure? Could this help an attacker fingerprint the parsing logic? mod.rs:19-22",
    "When request.body is very large, could the UTF-8 validation or JSON parsing consume excessive memory, causing the off-chain node to crash or become unresponsive? mod.rs:18-22",
    "In create_json_response(), does the serialization of response data properly escape special characters to prevent JSON injection attacks if the response includes user-controlled data? mod.rs:26-32",
    "Could an attacker send a request body that deserializes successfully but contains unexpected fields that are silently ignored, bypassing validation checks that should reject the request? mod.rs:13-23",

    # II. State Management & Contract Interaction (31–60)
    "In http_dispatch(), the ContractState is passed by value to the router. If an endpoint modifies the state but returns an error, are those modifications rolled back, or could partial state updates violate invariants? mod.rs:160-164",
    "Can multiple concurrent HTTP requests access the same ContractState simultaneously? If so, could race conditions allow double-spending of guardian approval votes or duplicate account registrations? mod.rs:77-82",
    "Does the routing logic enforce any transaction ordering or nonce checks to prevent replay attacks where an attacker re-submits a valid recovery request multiple times? mod.rs:170-171",
    "In register_routes(), endpoints for association, account, and reconstruction are registered. Could an attacker exploit the order of registration to shadow critical endpoints with malicious handlers? mod.rs:144-146",
    "When DispatchFunction is called, it receives ContractState by value. Does this mean each request operates on a snapshot of state, or could stale reads lead to time-of-check to time-of-use vulnerabilities? mod.rs:37-42",
    "Can an attacker observe changes to ContractState across requests to infer sensitive information, such as which accounts are being recovered or which guardians have approved recovery requests? mod.rs:103-104",
    "In the init endpoint handler registration, the closure captures ctx, state, request, and params. Could closure capture lead to unintended sharing of state across requests? mod.rs:151-154",
    "Does the OffChainContext passed to dispatch functions contain any authentication information? If not, how do endpoint handlers verify that requests come from authorized nodes? mod.rs:77-82",
    "Can the nodes map in ContractState be modified via HTTP endpoints? If so, could an attacker add malicious nodes or remove honest nodes to compromise threshold security? lib.rs:22-31",
    "Are the swafe_public_key and vdrf_public_key in ContractState properly validated before being used for verification operations in endpoints? Could key substitution attacks occur? lib.rs:26-28",
    "When endpoints access accounts via ContractState::get_account(), could deserialization failures cause panics that crash the off-chain node? lib.rs:34-38",
    "In ContractState::set_account(), serialization is done with expect(), which panics on failure. Could an attacker craft account states that fail serialization to cause denial of service? lib.rs:40-45",
    "Does the HTTP layer enforce that account modifications are atomic? Could partial updates leave accounts in an inconsistent state where backups are registered but guardians are not? mod.rs:170-171",
    "Can an attacker query account information via HTTP endpoints without proving ownership, leaking information about which accounts exist or their guardian configurations? mod.rs:144-146",
    "When multiple backups are registered for the same account, does the routing logic ensure that recovery requests target the correct backup? Could backup ID confusion lead to unauthorized access? mod.rs:103-104",
    "In the init endpoint, off-chain secrets are stored using OffChainContext. Could an attacker access this storage directly to extract VDRF secret shares and compromise email-to-account anonymity? init.rs:44-46",
    "Does the HTTP dispatch layer enforce that only one node can initialize its off-chain secrets? Could a compromised node re-initialize with different secrets to break threshold security? init.rs:44-46",
    "When OffchainSecrets::store() is called, are the secrets encrypted at rest? If not, could physical access to the off-chain node's storage reveal VDRF shares? init.rs:71",
    "Can the routing logic prevent unauthorized nodes from reading secrets stored by other nodes via the OffChainContext? mod.rs:77-82",
    "Does the OffChainContext implement proper isolation between different smart contracts deployed on the same node? Could secrets leak across contracts? mod.rs:77-82",
    "In register_routes(), the init endpoint is registered last. Does registration order matter for security? Could early registration of malicious routes intercept init requests? mod.rs:148-155",
    "The init handler uses a closure that calls init::handler() and converts errors. Could error conversion leak information about whether initialization succeeded or failed? mod.rs:151-154",
    "Does the init endpoint validate that the provided node_id matches the node making the request? Could a malicious node initialize secrets for a different node? init.rs:51-54",
    "When verifying the secret commitment with hash(&secret) != node_config.comm, does the comparison use constant-time operations to prevent timing side-channels that could leak partial secret information? init.rs:58-64",
    "Can an attacker repeatedly send init requests with wrong secrets to brute-force the commitment and discover valid VDRF secret shares? init.rs:48-64",
    "Does the HTTP layer rate-limit init requests to prevent an attacker from flooding the endpoint with invalid secrets? mod.rs:160-172",
    "After successful initialization, can the off-chain secret be updated or rotated? If not, does this create a single point of failure if a secret is compromised? init.rs:71",
    "When ServerError::VdrfNodeAlreadyInitialized is returned, does this reveal that the node has been initialized? Could an attacker use this to map which nodes are active? init.rs:44-46",
    "Does the init endpoint verify that the request comes from the node's owner address? If not, could anyone with network access initialize the node with malicious secrets? init.rs:38-43",
    "Can the init endpoint be called multiple times in rapid succession before the first call completes, causing race conditions in secret storage? init.rs:44-71",

    # III. Cryptographic Operation Security (61–90)
    "When VDRF evaluation endpoints are called via the router, does the HTTP layer verify VDRF proofs before returning results? Could proof verification be bypassed? mod.rs:144-146",
    "Can an attacker request VDRF evaluations for arbitrary inputs to build a database of email-to-VDRF-output mappings, breaking email anonymity? mod.rs:144-145",
    "Does the routing logic enforce that VDRF operations can only be performed after proper initialization? Could uninitialized nodes accept evaluation requests? mod.rs:141-146",
    "When multiple VDRF shares are combined, does the HTTP layer enforce the threshold t? Could an attacker with fewer than t shares still compute valid VDRF outputs? mod.rs:144-145",
    "Can VDRF evaluation requests be replayed to leak information about which users are performing account associations or recoveries? mod.rs:103-104",
    "Does the HTTP layer validate that VDRF inputs are properly domain-separated to prevent cross-protocol attacks where outputs from one application are used in another? mod.rs:141-146",
    "When VDRF proofs are verified, are there timing side-channels that could leak information about secret shares? Does verification use constant-time operations? mod.rs:103-104",
    "Can an attacker send malformed VDRF evaluation requests that cause the off-chain node to perform expensive cryptographic operations, leading to resource exhaustion? mod.rs:170-171",
    "Does the routing logic prevent VDRF nodes from evaluating the same input multiple times? Could repeated evaluations leak secret shares through side-channel analysis? mod.rs:103-104",
    "When VDRF shares are aggregated across nodes, does the HTTP layer verify that shares come from distinct node IDs? Could a malicious node submit multiple shares? mod.rs:141-146",
    "Do HTTP endpoints that accept email certificates verify them against the swafe_public_key stored in ContractState? Could certificate verification be skipped? lib.rs:26",
    "Can an attacker reuse expired email certificates in HTTP requests? Does the routing logic enforce certificate expiration checks? mod.rs:103-104",
    "When an email certificate is presented, does the HTTP layer verify that the certified email matches the email used in the association or recovery request? mod.rs:141-146",
    "Could an attacker present a valid email certificate for email A but request operations on an account associated with email B, bypassing ownership checks? mod.rs:103-104",
    "Does the HTTP dispatch verify that email certificates are signed by the trusted Swafe-io key before allowing account recovery? Could key substitution attacks occur? mod.rs:103-104",
    "Can email certificates be replayed across different accounts or requests? Does the routing logic enforce freshness or nonce checks? mod.rs:103-104",
    "When certificate verification fails, does the error message reveal information about why verification failed, potentially helping an attacker forge certificates? error.rs:62-110",
    "Does the HTTP layer enforce that email certificates cannot be issued for the future? Could certificates with future timestamps bypass time-based security checks? mod.rs:103-104",
    "Can an attacker present an email certificate that was validly issued but has been revoked? Does the routing logic check certificate revocation status? mod.rs:141-146",
    "When multiple email certificates are chained (e.g., for recovery of multiple backups), does the HTTP layer verify the entire chain before allowing operations? mod.rs:103-104",
    "Do HTTP endpoints that handle guardian approvals verify that approval signatures are valid and from registered guardians? Could signature checks be bypassed? mod.rs:146",
    "When counting guardian approvals, does the routing logic enforce the threshold t? Could an attacker with t-1 approvals trick the system into allowing recovery? mod.rs:103-104",
    "Can the same guardian provide multiple approvals for the same recovery request to inflate the approval count above the threshold? mod.rs:146",
    "Does the HTTP layer verify that guardians are not approving their own accounts? Could self-approval bypass the guardian trust model? mod.rs:103-104",
    "When guardian approvals are submitted via HTTP requests, can they be replayed to approve multiple different recovery requests? mod.rs:146",
    "Does the routing logic enforce that guardian approvals must be for specific account IDs and backup IDs? Could approval for one account be used for another? mod.rs:103-104",
    "Can an attacker front-run guardian approval submissions to change the recovery target between when guardians sign and when their approvals are processed? mod.rs:170-171",
    "When the threshold number of approvals is reached, does the HTTP layer immediately trigger recovery? Could this create a race condition where more approvals arrive? mod.rs:103-104",
    "Does the routing logic verify that guardian public keys match those registered in the account's guardian list? Could key substitution allow unauthorized approvals? mod.rs:146",
    "Can guardian approvals expire? If so, does the HTTP layer enforce expiration checks to prevent stale approvals from being used in future attacks? mod.rs:103-104",

    # IV. Privacy & Anonymity Preservation (91–110)
    "When association endpoints are called via the router, could timing analysis of HTTP responses reveal which email addresses are associated with which accounts? mod.rs:144-145",
    "Does the HTTP dispatch layer add random delays or constant-time processing to prevent timing side-channels from leaking association information? mod.rs:170-171",
    "Can an attacker observe the size of HTTP responses from association endpoints to infer information about account configurations or guardian counts? mod.rs:26-32",
    "When errors occur during association operations, does the error handling distinguish between 'email not found' and 'account not found'? Could this leak associations? error.rs:62-110",
    "Does the routing logic prevent HTTP access logs from containing sensitive information like email addresses or account IDs in URL paths or query parameters? mod.rs:88-91",
    "Can an attacker who compromises a minority of off-chain nodes use HTTP request metadata (timestamps, IP addresses, request ordering) to link emails to accounts? mod.rs:77-82",
    "When VDRF evaluations are performed, does the HTTP layer ensure that inputs are committed before outputs are returned to prevent retroactive linkage? mod.rs:103-104",
    "Can the routing logic be exploited to bypass VDRF-based anonymity by directly querying account states via predictable account IDs? mod.rs:144-146",
    "Does the HTTP dispatch add dummy traffic or padding to prevent traffic analysis attacks that could correlate HTTP requests with on-chain transactions? mod.rs:170-171",
    "When an account recovery is initiated, can network observers correlate HTTP requests to off-chain nodes with on-chain account updates to de-anonymize users? mod.rs:160-172",
    "When guardian approval endpoints are accessed, could HTTP request patterns leak which guardians are approving which recovery requests? mod.rs:146",
    "Does the routing logic prevent enumeration of guardian public keys or addresses through error messages or timing differences? mod.rs:103-104",
    "Can an attacker observe HTTP traffic to off-chain nodes to determine which guardians are online or offline, affecting recovery availability? mod.rs:170-171",
    "When recovery shares are distributed to guardians, does the HTTP layer ensure that shares are encrypted in transit to prevent network eavesdropping? mod.rs:146",
    "Could guardian participation in recoveries be tracked across multiple accounts by analyzing HTTP request patterns to off-chain nodes? mod.rs:160-172",
    "Does the HTTP dispatch leak information about which off-chain nodes are storing secrets for which accounts through error messages or response times? mod.rs:170-171",
    "When reconstruction endpoints are called, can an attacker determine which nodes have shares for a particular backup by observing successful vs. failed responses? mod.rs:146",
    "Does the routing logic prevent nodes from fingerprinting each other based on HTTP response headers or error message formats? mod.rs:26-32",
    "Can HTTP metadata like User-Agent strings or custom headers be exploited to track individual nodes or users across multiple requests? mod.rs:77-82",
    "When nodes relay shares to each other, does the HTTP layer anonymize the source node to prevent tracking of share distribution patterns? mod.rs:103-104",

    # V. Input Validation & Injection Attacks (111–130)
    "In json::to_string(), does the serialization properly handle strings with embedded newlines, quotes, or control characters that could break JSON structure? json.rs:7-14",
    "Can an attacker exploit differences between serde_json_wasm and standard serde_json to craft payloads that serialize differently, bypassing validation? json.rs:8-13",
    "In json::from_str(), does the deserializer reject JSON with trailing data after the main object? Could extra data be used to smuggle commands? json.rs:17-24",
    "When error messages are formatted with format!() and included in JSON responses, could format string injection allow command execution or information leakage? json.rs:9-12",
    "Does json::to_string() in the error path handle serialization failures gracefully? Could double-faults cause panics that crash the off-chain node? json.rs:27-32",
    "In create_json_response(), when json::to_string() is called on user-provided data, could circular references or infinite recursion cause hangs? mod.rs:30-31",
    "Can an attacker send JSON with extremely large numbers (e.g., 9e999999) that cause parsing to hang or produce incorrect values? json.rs:17-24",
    "Does the JSON deserialization enforce strict mode to reject unknown fields? Could attackers probe for undocumented features by adding extra fields? mod.rs:22-23",
    "When JSON contains Unicode escape sequences (e.g., \\u0000), are they properly validated to prevent null byte injection into C-style string operations? json.rs:17-24",
    "Can attackers use JSON comments (if supported by the parser) to hide malicious payloads from logging but have them processed by the endpoint? mod.rs:22-23",
    "In HttpRouter::dispatch(), the Params from URL path matching are passed directly to handlers. Could parameter names collide with reserved keywords? mod.rs:103-104",
    "Can an attacker inject parameters with empty strings, null values, or special characters that bypass validation in endpoint handlers? mod.rs:103-104",
    "When route parameters are extracted (e.g., /account/:id), does the router validate that parameter values don't contain path separators or escape sequences? mod.rs:88-91",
    "Could an attacker use URL encoding tricks (e.g., %2e%2e%2f for ../) in path parameters to bypass sanitization in the router? mod.rs:88-91",
    "When multiple parameters are present, does the routing logic enforce ordering or precedence? Could parameter confusion lead to using wrong values? mod.rs:103-104",
    "Does the HTTP dispatch validate request headers to prevent header injection attacks where newlines in headers could add malicious headers? mod.rs:77-82",

    # I. Authentication & Authorization (1–25)
    "Missing Guardian Authentication: The handler function in upload_share.rs does not verify that the caller is an authorized guardian for the specified backup. Can any user upload arbitrary shares for any account/backup pair, potentially allowing unauthorized parties to inject malicious shares that could compromise backup reconstruction? upload_share.rs:33-74",
    "No Account Owner Verification: Does the lack of account owner verification in the upload flow allow malicious actors to upload shares for accounts they don't own, potentially enabling them to participate in unauthorized backup reconstructions? upload_share.rs:41-50",
    "Guardian Index Validation: The share_id returned from backup.verify() determines which guardian slot is being filled, but is there validation that the uploader is actually the guardian corresponding to that share_id, or can any guardian upload shares for other guardian positions? upload_share.rs:52-55",
    "Cross-Account Share Upload: Can an attacker who is a guardian for Account A upload shares for Account B if they know the backup_id, potentially polluting the share collection or enabling unauthorized reconstruction? upload_share.rs:64-67",
    "Off-Chain Node Impersonation: Since the endpoint appears publicly accessible, can a malicious off-chain node or network adversary impersonate legitimate guardians by uploading shares without cryptographic proof of guardian identity? upload_share.rs:33-38",
    "Threshold Bypass via Unauthorized Uploads: If multiple malicious actors can upload valid-looking shares, could they collectively meet the reconstruction threshold without being actual guardians, violating the invariant that 'recovery of a backup only occurs when more than the specified threshold of Guardians has approved'? upload_share.rs:52-67",
    "Session/Context Authentication: The handler receives an OffChainContext but does not appear to extract or verify any authentication credentials. Should guardian identity be validated through digital signatures or other cryptographic proofs? upload_share.rs:33-38",
    "Guardian Approval Mechanism: The comment mentions shares can be 'equivalent' and allows overwriting, but where is the explicit guardian approval mechanism that ensures each guardian has consented to the reconstruction? upload_share.rs:58-63",
    "Account State Check: The code retrieves the account state but only uses it to get the backup. Should there be additional checks on the account status (e.g., recovery mode, locked) before accepting shares? upload_share.rs:44-50",
    "Recovery Initiation Validation: Does the absence of recovery initiation checks allow shares to be uploaded before recovery has been properly initiated by the account owner through email verification? upload_share.rs:33-74",
    "Guardian Revocation: If a guardian has been removed from the backup configuration after the backup was created, can they still upload shares? Is there a mechanism to prevent revoked guardians from participating? upload_share.rs:52-67",
    "Backup Validity Period: Should the endpoint check if the backup is still valid or if it has expired/been superseded before accepting shares? upload_share.rs:48-50",
    "Multiple Backup Disambiguation: An account can have multiple backups. Can confusion between different backups lead to shares being uploaded to the wrong backup's collection? upload_share.rs:41-50",
    "Guardian-to-Account Binding: Could the lack of verifying a guardian's relationship to the account allow arbitrary parties to upload shares as long as they pass cryptographic verification? upload_share.rs:44-55",
    "Concurrent Upload Authorization: If multiple upload requests arrive for the same slot, are there authorization race conditions enabling unauthorized uploads? upload_share.rs:64-67",
    "Request Origin Validation: Should the endpoint validate that requests come from known nodes or authenticated guardians rather than arbitrary HTTP sources? upload_share.rs:33-38",
    "Backup Ownership Transfer: If account ownership transfers, could old guardians still upload shares after transfer, violating access control? upload_share.rs:44-50",
    "Guardian Threshold Manipulation: Can uploading more shares than the guardian count allow threshold manipulation or invalid reconstruction states? upload_share.rs:52-67",
    "Account State Transition Authorization: Should share uploads only be permitted during specific state transitions? upload_share.rs:44-50",
    "Email Verification Bypass: Can shares be uploaded without proving email ownership, enabling recovery without verification? upload_share.rs:33-74",
    "Guardian Signature Verification: Is there an additional guardian signature required on the upload request itself? upload_share.rs:52-55",
    "Off-Chain Context Exploitation: Can the mutable OffChainContext be abused to manipulate authorization checks? upload_share.rs:34-38",
    "Backup Type Differentiation: Does the endpoint distinguish between normal vs recovery backups when storing shares? upload_share.rs:48-50",
    "Guardian List Consistency: If guardian lists differ between backup and current config, which takes precedence, and can attackers exploit discrepancies? upload_share.rs:44-55",
    "Time-Based Authorization: Should uploads only be allowed during defined recovery windows? upload_share.rs:33-74",

    # II. Cryptographic Verification (26–50)
    "Share Verification Depth: Does backup.verify(&request.share.0) fully validate the share, or can a malicious but invalid share pass? upload_share.rs:53-55",
    "Signature Verification Completeness: Does verification ensure the signature matches the correct guardian key, or can signatures from the wrong guardian be accepted? upload_share.rs:53-55",
    "Share Index Bounds: Does the returned share_id fall within valid bounds before indexing the commitments vector? upload_share.rs:52-67",
    "Ciphertext Integrity: Does verification detect ciphertext tampering or only validate signatures? upload_share.rs:53-55",
    "Commitment Binding: Does verification bind the share to this specific backup’s commitments? upload_share.rs:53-55",
    "Key Rotation Impact: If guardian keys are rotated, can outdated shares still pass verification? upload_share.rs:53-55",
    "Batch Verification Vulnerability: Can a malicious guardian upload a share that interferes with verification of other shares? upload_share.rs:64-67",
    "Encryption Context Validation: Are shares bound to the correct backup’s encryption context? upload_share.rs:53-55",
    "Share Freshness: Can shares from previous epochs be replayed due to 'no replay protection' assumption? upload_share.rs:58-63",
    "AAD Verification: Does verification check Additional Authenticated Data matches expected context? upload_share.rs:53-55",
    "Share Malleability: Can ciphertext be modified in transit and still decrypt to malicious content? upload_share.rs:53-55",
    "Public Key Substitution: Can shares encrypted to the wrong key pass verification? upload_share.rs:53-55",
    "Threshold Secret Integrity: Can individually valid malicious shares combine into an incorrect reconstruction? upload_share.rs:53-67",
    "Signature Algorithm Weaknesses: Does the verification rely on a secure signature algorithm? upload_share.rs:53-55",
    "Verification Error Handling: Does verification leak failure reasons useful to attackers? upload_share.rs:53-55",
    "Share Version Mismatch: Can incompatible share versions pass verification? upload_share.rs:53-55",
    "Commitment Hash Collision: Could weak hashes allow share substitution via collisions? upload_share.rs:53-55",
    "Encrypted Share Content: Does verification ensure ciphertext content hasn't been swapped? upload_share.rs:53-55",
    "Guardian Key Compromise: If a guardian key is compromised, can attacker upload malicious shares undetected? upload_share.rs:53-55",
    "Verification Key Substitution: Is the verification key securely bound to the backup’s metadata? upload_share.rs:53-55",
    "Share Index Manipulation: Can attackers manipulate idx in the share to influence share_id output? upload_share.rs:53-55",
    "Serialization Attack on Verification: Can malformed share serialization break verification logic? upload_share.rs:53-55",
    "Timing Attack on Verification: Do timing differences reveal share validity? upload_share.rs:53-55",
    "Backup Ciphertext Versioning: Can mismatched versions between backup and share pass verification? upload_share.rs:48-55",
    "Cryptographic Binding Chain: Is the chain from uploaded share to backup fully cryptographically bound? upload_share.rs:53-67",

    # III. State Management & Storage (51–75)
    "Share Overwriting Security: Can malicious actors overwrite legitimate shares? upload_share.rs:58-67",
    "Storage Key Collision: Can collisions in (account_id, backup_id) cause cross-account share mixing? upload_share.rs:64-67",
    "BTreeMap Ordering Dependency: Could ordering affect reconstruction or cause subtle errors? upload_share.rs:65-66",
    "Storage Capacity Limits: Can attackers store excessive shares to exhaust resources? upload_share.rs:64-67",
    "Share Collection Initialization: Can default-empty collections cause incorrect assumptions? upload_share.rs:65",
    "Concurrent Modification: Are load-modify-store sequences race-condition safe? upload_share.rs:64-67",
    "Storage Transaction Atomicity: Can a crash between load and store corrupt the collection? upload_share.rs:65-67",
    "Share Deletion: Does lack of deletion cause stale or malicious shares to accumulate? upload_share.rs:64-67",
    "Storage Backend Security: Does OffChainContext guarantee secure storage access? upload_share.rs:65-67",
    "Collection Name Uniqueness: Can namespace collisions corrupt data? upload_share.rs:23-31",
    "State Persistence Guarantees: Is stored data guaranteed durable after store()? upload_share.rs:67",
    "Share Retrieval Consistency: Can get_shares.rs observe inconsistent state during uploads? upload_share.rs:64-67",
    "Storage Key Serialization: Can key serialization errors cause wrong map access? upload_share.rs:26-28",
    "Backup ID Immutability: Can backup_id reuse mix old and new shares? upload_share.rs:41-42",
    "Share Count Tracking: Is threshold tracking accurate and secure? upload_share.rs:64-67",
    "Storage Namespace Isolation: Are backup share maps isolated per account? upload_share.rs:64-67",
    "Map Value Mutation: Can partial map updates leave invalid state? upload_share.rs:65-67",
    "Context Mutation Side Effects: Can OffChainContext mutations affect other operations? upload_share.rs:34-67",
    "Share Replacement Notification: Is silent overwriting detectable or logged? upload_share.rs:58-67",
    "Storage Error Propagation: Could silent storage failures hide missing shares? upload_share.rs:67",
    "Collection Lifetime: Are stale collections cleaned up securely? upload_share.rs:23-31",
    "Share Versioning in Storage: Can incompatible share versions coexist in storage? upload_share.rs:64-67",
    "Storage Schema Evolution: Can schema changes corrupt older storage? upload_share.rs:23-31",
    "Idempotency Guarantees: Does overwriting preserve idempotent semantics? upload_share.rs:58-67",
    "Share Index Gaps: Can non-consecutive indices break reconstruction? upload_share.rs:65-66",

    # IV. Input Validation & Deserialization (76–100)
    "Request Body Validation: Are request sizes limited to prevent oversized-body attacks? upload_share.rs:39",
    "StrEncoded Security: Can malformed string encoding bypass validation? upload_share.rs:39-42",
    "Unwrapping Inner Values: Can .0 inner fields be malformed after passing StrEncoded? upload_share.rs:41-42",
    "AccountId Validation: Is extracted account_id.0 checked for existence? upload_share.rs:42",
    "BackupId Validation: Is backup_id.0 verified as existing for the account? upload_share.rs:41",
    "GuardianShare Deserialization: Can crafted share data exploit deserialization logic? upload_share.rs:39-42",
    "Type Confusion: Can GuardianShare versioned enum variants be abused? upload_share.rs:39-42",
    "Field Bounds Checking: Are numeric fields checked for bounds? upload_share.rs:52-55",
    "Null/Empty Input Handling: Can null/empty inputs trigger undefined behavior? upload_share.rs:39-42",
    "Character Encoding Issues: Can unexpected encodings bypass validation? upload_share.rs:39-42",
    "Request Content-Type: Is Content-Type enforced? upload_share.rs:36-39",
    "Deserialization Error Handling: Do errors leak sensitive info? upload_share.rs:39",
    "Canonical Encoding: Can alternative encodings bypass duplicate detection? upload_share.rs:39-42",
    "JSON Injection: Can JSON injection attacks modify parsed values? upload_share.rs:39",
    "Buffer Overflow in Deserialization: Can large requests cause stack/heap exhaustion? upload_share.rs:39",
    "Share Size Validation: Are guardian share sizes properly limited? upload_share.rs:39-42",
    "Request Field Injection: Can extra unexpected fields cause issues? upload_share.rs:39",
    "Encoding Version Compatibility: Can older clients send incompatible encodings? upload_share.rs:39-42",
    "Malformed Hex Encoding: Can malformed hex in IDs cause panics? upload_share.rs:41-42",
    "Request Tampering: Can MITM modify fields if transport security fails? upload_share.rs:36-42",
    "Type Safety in Deserialization: Can runtime type confusion occur? upload_share.rs:39-42",
    "Request Origin Spoofing: Can attackers spoof headers to appear legitimate? upload_share.rs:36-39",
    "Share Metadata Validation: Are metadata fields validated beyond crypto verification? upload_share.rs:39-55",
    "Integer Truncation: Can casting/truncation of share_id corrupt indexing? upload_share.rs:52-66",
    "Serde Configuration: Can unsafe serde settings introduce vulnerabilities? upload_share.rs:39-42",

    # V. Error Handling & Information Leakage (101–120)
    "Account Not Found Disclosure: Does 'Account not found' allow account enumeration? upload_share.rs:44-46",
    "Backup Not Found Disclosure: Does including backup_id leak valid backup existence? upload_share.rs:48-50",
    "Invalid Share Error: Does detailed verification failure leak oracle information? upload_share.rs:54-55",
    "Success Message Disclosure: Does revealing success vs failure leak internal state? upload_share.rs:69-72",
    "Error Type Differentiation: Do distinct error types reveal internal branching logic? upload_share.rs:44-55",
    "Verification Failure Details: Does backup.verify() leak reasons useful to attackers? upload_share.rs:53-55",
    "Panic vs Error: Do any code paths panic and leak stack traces? upload_share.rs:33-74",
    "Deserialization Error Leakage: Does deserialization leak implementation details? upload_share.rs:39",
    "Response Timing: Do timing differences reveal share validity? upload_share.rs:33-74",
    "Storage Operation Errors: Do storage failures leak internal storage details? upload_share.rs:65-67",
    "HTTP Status Code Mapping: Do status codes leak failure reasons? upload_share.rs:73",
    "JSON Serialization Errors: Can serialization failures leak sensitive data? upload_share.rs:69-73",
    "State Query Side Effects: Does failed account retrieval leak account state? upload_share.rs:44-46",
    "Privacy of Guardian Actions: Does success response reveal which guardian uploaded a share? upload_share.rs:69-72",
    "Backup Structure Leakage: Can probing backup IDs reveal backup structure? upload_share.rs:48-50",
    "Share Count Leakage: Does response reveal number of existing shares or threshold state?",

    # =========================
    # I. Authentication & Authorization (1–25)
    # =========================

    "Missing Guardian Authentication: Does the handler in upload_share.rs fail to verify that the caller is an authorized guardian for the backup, allowing arbitrary users to upload shares? upload_share.rs:33-74",
    "No Account Owner Verification: Can malicious actors upload shares for accounts they do not own due to missing owner authentication? upload_share.rs:41-50",
    "Guardian Index Validation: Does the code fail to verify that the uploader is the guardian corresponding to the returned share_id, allowing cross-guardian uploads? upload_share.rs:52-55",
    "Cross-Account Share Upload: Can a guardian for Account A upload shares for Account B by guessing the backup_id? upload_share.rs:64-67",
    "Off-Chain Node Impersonation: Can malicious off-chain nodes impersonate guardians and upload shares without cryptographic identity proofs? upload_share.rs:33-38",
    "Threshold Bypass via Unauthorized Uploads: Can multiple unauthorized actors upload valid-looking shares to meet the reconstruction threshold? upload_share.rs:52-67",
    "Session/Context Authentication: Does OffChainContext fail to authenticate the guardian identity before accepting uploads? upload_share.rs:33-38",
    "Guardian Approval Mechanism: Is there no explicit guardian approval logic ensuring guardians willingly participate in reconstruction? upload_share.rs:58-63",
    "Account State Check: Does the endpoint fail to validate account state (e.g., recovery mode) before accepting shares? upload_share.rs:44-50",
    "Recovery Initiation Validation: Can shares be uploaded before recovery is properly initiated via email or owner approval? upload_share.rs:33-74",
    "Guardian Revocation: Can revoked guardians still upload shares due to missing revocation checks? upload_share.rs:52-67",
    "Backup Validity Period: Does the endpoint fail to verify whether the backup is still active or expired before accepting shares? upload_share.rs:48-50",
    "Multiple Backup Disambiguation: Can guardians upload shares to the wrong backup due to missing backup distinction checks? upload_share.rs:41-50",
    "Guardian-to-Account Binding: Does the endpoint fail to ensure the uploader is a legitimate guardian of the account? upload_share.rs:44-55",
    "Concurrent Upload Authorization: Are there race conditions that allow unauthorized uploads during concurrent operations? upload_share.rs:64-67",
    "Request Origin Validation: Does the endpoint accept uploads from arbitrary sources without verifying trusted nodes? upload_share.rs:33-38",
    "Backup Ownership Transfer: Can old guardians still upload shares after account ownership transfer? upload_share.rs:44-50",
    "Guardian Threshold Manipulation: Can attackers upload more shares than the configured guardian count to manipulate thresholds? upload_share.rs:52-67",
    "Account State Transition Authorization: Does the system fail to restrict share uploads to valid account states? upload_share.rs:44-50",
    "Email Verification Bypass: Can shares be uploaded without validating email ownership required for account recovery? upload_share.rs:33-74",
    "Guardian Signature Verification: Does the endpoint lack verification that the guardian signed the upload request itself? upload_share.rs:52-55",
    "Off-Chain Context Exploitation: Can mutability of OffChainContext be exploited to bypass authorization? upload_share.rs:34-38",
    "Backup Type Differentiation: Does the endpoint fail to distinguish between recovery and normal backups when uploading shares? upload_share.rs:48-50",
    "Guardian List Consistency: If guardian lists differ between backup and account state, can authorization be bypassed? upload_share.rs:44-55",
    "Time-Based Authorization: Should uploads be restricted to specific recovery windows to avoid premature reconstruction attempts? upload_share.rs:33-74",

    # =========================
    # II. Cryptographic Verification (26–50)
    # =========================

    "Share Verification Depth: Does backup.verify() insufficiently validate share correctness, allowing invalid shares to pass? upload_share.rs:53-55",
    "Signature Verification Completeness: Can shares signed with the wrong key pass backup.verify()? upload_share.rs:53-55",
    "Share Index Bounds: Does the code fail to validate that the returned share_id is within expected bounds? upload_share.rs:52-67",
    "Ciphertext Integrity: Does verification fail to confirm integrity of the encrypted ciphertext portion? upload_share.rs:53-55",
    "Commitment Binding: Does verification fail to bind shares to the backup's commitments, enabling substitution attacks? upload_share.rs:53-55",
    "Key Rotation Impact: Could old guardian keys allow replay of stale shares post-rotation? upload_share.rs:53-55",
    "Batch Verification Vulnerability: Can a malicious share interfere with verification of other guardian shares? upload_share.rs:64-67",
    "Encryption Context Validation: Does verification fail to ensure share encryption context matches the backup? upload_share.rs:53-55",
    "Share Freshness: Can old backup epoch shares be reused due to missing replay protection? upload_share.rs:58-63",
    "AAD Verification: Does verification fail to enforce expected AAD for encryption? upload_share.rs:53-55",
    "Share Malleability: Can attackers modify ciphertext without invalidating signature checks? upload_share.rs:53-55",
    "Public Key Substitution: Can shares encrypted to the wrong key still pass verification? upload_share.rs:53-55",
    "Threshold Secret Integrity: Can malicious shares combine into an incorrect reconstructed secret? upload_share.rs:53-67",
    "Signature Algorithm Weaknesses: Could weak signature schemes enable forged shares? upload_share.rs:53-55",
    "Verification Error Handling: Do verification errors leak information useful for crafting valid shares? upload_share.rs:53-55",
    "Share Version Mismatch: Can incompatible share versions bypass verification? upload_share.rs:53-55",
    "Commitment Hash Collision: Could weak hash functions allow share commitment collisions? upload_share.rs:53-55",
    "Encrypted Share Content: Does verification fail to check encrypted Shamir content integrity? upload_share.rs:53-55",
    "Guardian Key Compromise: Can compromised guardian keys still be used to upload valid shares? upload_share.rs:53-55",
    "Verification Key Substitution: Can an attacker substitute the expected verification key? upload_share.rs:53-55",
    "Share Index Manipulation: Can attackers tamper with idx to mislead backup.verify()? upload_share.rs:53-55",
    "Serialization Attack: Can malformed share serialization bypass verification logic? upload_share.rs:53-55",
    "Timing Attack on Verification: Can timing differences leak share validity information? upload_share.rs:53-55",
    "Backup Ciphertext Versioning: Can version mismatches between backup and share bypass verification? upload_share.rs:48-55",
    "Cryptographic Binding Chain: Is the cryptographic binding between share → commit → backup incomplete? upload_share.rs:53-67",

    # =========================
    # III. State Management & Storage (51–75)
    # =========================

    "Share Overwriting Security: Can attackers overwrite legitimate shares after upload? upload_share.rs:58-67",
    "Storage Key Collision: Can hash collisions in (account_id, backup_id) corrupt share storage? upload_share.rs:64-67",
    "BTreeMap Ordering Dependency: Can manipulation of BTreeMap ordering affect reconstruction? upload_share.rs:65-66",
    "Storage Capacity Limits: Can attackers upload excessive shares to exhaust storage? upload_share.rs:64-67",
    "Share Collection Initialization: Can empty guardian share collections lead to unexpected behaviors? upload_share.rs:65",
    "Concurrent Modification: Do simultaneous uploads introduce race conditions in load-modify-store? upload_share.rs:64-67",
    "Storage Atomicity: Can crashes during store() cause corruption between load and store? upload_share.rs:65-67",
    "Share Deletion Absence: Does lack of deletion allow stale/corrupted shares to persist? upload_share.rs:64-67",
    "Storage Backend Security: Does OffChainContext lack access control for stored shares? upload_share.rs:65-67",
    "Collection Name Uniqueness: Can name collision on 'map:guardian_shares' corrupt data? upload_share.rs:23-31",
    "State Persistence Guarantees: Does store() guarantee durable persistence? upload_share.rs:67",
    "Share Retrieval Consistency: Can concurrent reads retrieve inconsistent share states? upload_share.rs:64-67",
    "Storage Key Serialization: Can serialization errors cause incorrect storage access? upload_share.rs:26-28",
    "Backup ID Immutability: Can reused backup_id values mix shares from different backups? upload_share.rs:41-42",
    "Share Count Tracking: Can incorrect share counts enable premature reconstruction? upload_share.rs:64-67",
    "Storage Namespace Isolation: Could shares leak across accounts/backups due to namespace issues? upload_share.rs:64-67",
    "Map Value Mutation: Can partial updates leave the BTreeMap in invalid state? upload_share.rs:65-67",
    "Context Mutation Side Effects: Can OffChainContext mutations affect other operations? upload_share.rs:34-67",
    "Share Replacement Notification: Could silent overwriting hide malicious replacement of shares? upload_share.rs:58-67",
    "Storage Error Propagation: Are store() failures silently swallowed? upload_share.rs:67",
    "Collection Lifetime: Can stale collections persist indefinitely, leaking information? upload_share.rs:23-31",
    "Share Versioning in Storage: Can incompatible share versions coexist? upload_share.rs:64-67",
    "Storage Schema Evolution: Can schema changes corrupt old stored data? upload_share.rs:23-31",
    "Idempotency Guarantees: Does share overwrite behavior cause unexpected inconsistencies? upload_share.rs:58-67",
    "Share Index Gaps: Can non-consecutive indices cause reconstruction failures? upload_share.rs:65-66",

    # =========================
    # IV. Input Validation & Deserialization (76–100)
    # =========================

    "Request Body Validation: Are oversized request bodies properly rejected? upload_share.rs:39",
    "StrEncoded Security: Can malformed StrEncoded values bypass decoding validation? upload_share.rs:39-42",
    "Unwrapping Inner Values: Can decoded inner values be malformed despite valid outer encoding? upload_share.rs:41-42",
    "AccountId Validation: Does the system verify that account_id refers to a valid account? upload_share.rs:42",
    "BackupId Validation: Does backup_id get validated as belonging to the account? upload_share.rs:41",
    "GuardianShare Deserialization: Can malicious share data exploit deserialization behavior? upload_share.rs:39-42",
    "Type Confusion: Can versioned GuardianShare variants be confused to bypass logic? upload_share.rs:39-42",
    "Field Bounds Checking: Are numeric fields like share indices bounds-checked? upload_share.rs:52-55",
    "Null/Empty Input Handling: Does the system reject empty critical fields? upload_share.rs:39-42",
    "Character Encoding Issues: Can unexpected encoding bypass validation? upload_share.rs:39-42",
    "Request Content-Type: Does the endpoint validate Content-Type headers? upload_share.rs:36-39",
    "Deserialization Error Handling: Do deserialization errors leak sensitive details? upload_share.rs:39",
    "Canonical Encoding: Can non-canonical encodings bypass dedup logic? upload_share.rs:39-42",
    "JSON Injection: Can JSON injection manipulate parsed values? upload_share.rs:39",
    "Buffer Overflow: Can large or deeply nested inputs cause overflow or stack exhaustion? upload_share.rs:39",
    "Share Size Validation: Is maximum share size enforced? upload_share.rs:39-42",
    "Request Field Injection: Are unexpected fields silently accepted or harmful? upload_share.rs:39",
    "Encoding Version Compatibility: Can old encodings be misinterpreted as valid? upload_share.rs:39-42",
    "Malformed Hex Encoding: Can invalid hex cause parsing issues? upload_share.rs:41-42",
    "Request Tampering: Can MITM tamper with request values if TLS assumptions break? upload_share.rs:36-42",
    "Type Safety: Can runtime type confusion occur during deserialization? upload_share.rs:39-42",
    "Request Origin Spoofing: Can attackers spoof headers to appear legitimate? upload_share.rs:36-39",
    "Share Metadata Validation: Does metadata like version/timestamp get validated? upload_share.rs:39-55",
    "Integer Truncation: Can casting share indices cause truncation? upload_share.rs:52-66",
    "Serde Configuration: Can unsafe serde configs introduce vulnerabilities? upload_share.rs:39-42",

    # =========================
    # V. Error Handling & Information Leakage (101–120)
    # =========================

    "Account Not Found Disclosure: Does explicit 'Account not found' reveal valid account IDs? upload_share.rs:44-46",
    "Backup Not Found Disclosure: Does backup-specific error leak backup existence? upload_share.rs:48-50",
    "Invalid Share Error: Does 'Invalid guardian share' leak verification failure details? upload_share.rs:54-55",
    "Success Message Disclosure: Do success responses leak share validity or thresholds? upload_share.rs:69-72",
    "Error Type Differentiation: Do different error types reveal internal state? upload_share.rs:44-55",
    "Verification Failure Details: Does backup.verify() leak reasons for failure? upload_share.rs:53-55",
    "Panic vs Error: Can unexpected panics leak stack traces? upload_share.rs:33-74",
    "Deserialization Error Leakage: Do deserialization failures leak details? upload_share.rs:39",
    "Response Timing: Do timing differences reveal share validity or internal operations? upload_share.rs:33-74",
    "Storage Operation Errors: Do storage failures leak backend information? upload_share.rs:65-67",
    "HTTP Status Code Mapping: Do status codes reveal internal logic paths? upload_share.rs:73",
    "JSON Serialization Errors: Can serialization errors leak sensitive internal data? upload_share.rs:69-73",
    "State Query Side Effects: Do failed account queries leak account state distribution? upload_share.rs:44-46",
    "Guardian Action Privacy: Do responses or logs reveal which guardians uploaded shares? upload_share.rs:69-72",
    "Backup Structure Leakage: Can probing different backup IDs leak structure of backups? upload_share.rs:48-50",
    "Share Count Leakage: Can responses leak how many shares exist or the threshold requirement?",

    # === I. Authentication & Authorization (1–25) ===
    "Missing Guardian Authentication: The handler function in upload_share.rs does not verify that the caller is an authorized guardian for the specified backup. Can any user upload arbitrary shares for any account/backup pair, potentially allowing unauthorized parties to inject malicious shares that could compromise backup reconstruction? upload_share.rs:33-74",
    "No Account Owner Verification: Does the lack of account owner verification in the upload flow allow malicious actors to upload shares for accounts they don't own, potentially enabling them to participate in unauthorized backup reconstructions? upload_share.rs:41-50",
    "Guardian Index Validation: The share_id returned from backup.verify() determines which guardian slot is being filled, but is there validation that the uploader is actually the guardian corresponding to that share_id, or can any guardian upload shares for other guardian positions? upload_share.rs:52-55",
    "Cross-Account Share Upload: Can an attacker who is a guardian for Account A upload shares for Account B if they know the backup_id, potentially polluting the share collection or enabling unauthorized reconstruction? upload_share.rs:64-67",
    "Off-Chain Node Impersonation: Since the endpoint appears publicly accessible, can a malicious off-chain node or network adversary impersonate legitimate guardians by uploading shares without cryptographic proof of guardian identity? upload_share.rs:33-38",
    "Threshold Bypass via Unauthorized Uploads: If multiple malicious actors can upload valid-looking shares, could they collectively meet the reconstruction threshold without being actual guardians, violating the invariant that recovery only occurs when more than the threshold approve? upload_share.rs:52-67",
    "Session/Context Authentication: The handler receives an OffChainContext but does not extract authentication info. Should guardian identity be validated with digital signatures? upload_share.rs:33-38",
    "Guardian Approval Mechanism: The comment mentions overwriting equivalent shares but where is the guardian approval mechanism proving the guardian consented to reconstruction? upload_share.rs:58-63",
    "Account State Check: The code retrieves account state but does not validate account recovery status. Should additional checks be required before accepting uploads? upload_share.rs:44-50",
    "Recovery Initiation Validation: Does absence of recovery initiation validation allow share uploads before email-verified recovery initiation? upload_share.rs:33-74",
    "Guardian Revocation: If a guardian is removed from configuration after backup creation, can they still upload shares? upload_share.rs:52-67",
    "Backup Validity Period: Should the endpoint check if the backup is expired or superseded before accepting shares? upload_share.rs:48-50",
    "Multiple Backup Disambiguation: Could confusion between backups allow shares to be uploaded to the wrong backup? upload_share.rs:41-50",
    "Guardian-to-Account Binding: The code doesn't prove the uploader is bound to the account. Could arbitrary parties upload shares that pass cryptographic checks? upload_share.rs:44-55",
    "Concurrent Upload Authorization: If multiple requests race for the same share slot, can unauthorized uploads slip through? upload_share.rs:64-67",
    "Request Origin Validation: Should the endpoint restrict requests to known off-chain nodes instead of public access? upload_share.rs:33-38",
    "Backup Ownership Transfer: After account ownership transfer, can old guardians still upload? upload_share.rs:44-50",
    "Guardian Threshold Manipulation: Could uploading extra or unexpected shares manipulate threshold behavior or create invalid reconstruction states? upload_share.rs:52-67",
    "Account State Transition Authorization: Should share uploads only be accepted in specific account states? upload_share.rs:44-50",
    "Email Verification Bypass: Can shares be uploaded without validating email certificates, allowing recovery without email ownership? upload_share.rs:33-74",
    "Guardian Signature Verification: Does the system require guardian signatures on the upload request itself? upload_share.rs:52-55",
    "Off-Chain Context Exploitation: OffChainContext is mutable. Could manipulation bypass authorization? upload_share.rs:34-38",
    "Backup Type Differentiation: Does the endpoint distinguish between backup vs recovery backup? upload_share.rs:48-50",
    "Guardian List Consistency: If guardian list differs between backup and account config, which one is authoritative? upload_share.rs:44-55",
    "Time-Based Authorization: Should uploads only occur during specific active recovery windows? upload_share.rs:33-74",

    # === II. Cryptographic Verification (26–50) ===
    "Share Verification Depth: What exactly does backup.verify() check, and can a malicious share pass verification while being invalid? upload_share.rs:53-55",
    "Signature Verification Completeness: Does backup.verify() confirm the share was signed by the correct guardian key? upload_share.rs:53-55",
    "Share Index Bounds: Is share_id validated to be within commitment bounds before indexing into comms? upload_share.rs:52-67",
    "Ciphertext Integrity: Does verification also enforce ciphertext integrity, or only signature integrity? upload_share.rs:53-55",
    "Commitment Binding: Is each share bound to this backup’s commitments to prevent substitution attacks? upload_share.rs:53-55",
    "Key Rotation Impact: If guardian keys are rotated, can old shares still pass verification and be replayed? upload_share.rs:53-55",
    "Batch Verification Vulnerability: Can a malicious guardian upload a share that interferes with others’ verification? upload_share.rs:64-67",
    "Encryption Context Validation: Does verification ensure encryption context matches this backup? upload_share.rs:53-55",
    "Share Freshness: Could old shares from previous backup epochs be reused to reconstruct an outdated secret? upload_share.rs:58-63",
    "AAD Verification: Does verification ensure AAD matches expected account/backup context? upload_share.rs:53-55",
    "Share Malleability: Could ciphertext be modified in transit and still decrypt incorrectly while passing signature checks? upload_share.rs:53-55",
    "Public Key Substitution: Does verification ensure the share is encrypted for the correct key? upload_share.rs:53-55",
    "Threshold Secret Integrity: Can individually valid shares combine into an incorrect reconstruction? upload_share.rs:53-67",
    "Signature Algorithm Weaknesses: If backup.verify() uses a weak signature scheme, can shares be forged? upload_share.rs:53-55",
    "Verification Error Handling: Do error messages leak cryptographic details? upload_share.rs:53-55",
    "Share Version Mismatch: Can incompatible share versions bypass verification or cause failure? upload_share.rs:53-55",
    "Commitment Hash Collision: If commitments use weak hashing, can attackers substitute shares? upload_share.rs:53-55",
    "Encrypted Share Content: Is encrypted Shamir share content validated? upload_share.rs:53-55",
    "Guardian Key Compromise: If a guardian key is compromised, can an attacker upload malicious shares? upload_share.rs:53-55",
    "Verification Key Substitution: Is the verification key guaranteed to match the backup’s committed key? upload_share.rs:53-55",
    "Share Index Manipulation: Could attackers manipulate idx to force incorrect share_id? upload_share.rs:53-55",
    "Serialization Attack on Verification: Can malformed share serialization bypass checks? upload_share.rs:53-55",
    "Timing Attack on Verification: Does verification run in constant time? upload_share.rs:53-55",
    "Backup Ciphertext Versioning: Could version mismatches cause incorrect verification results? upload_share.rs:48-55",
    "Cryptographic Binding Chain: Is there a complete cryptographic binding from share → verification → backup? upload_share.rs:53-67",

    # === III. State Management & Storage (51–75) ===
    "Share Overwriting Security: Can attackers overwrite valid guardian shares with malicious ones? upload_share.rs:58-67",
    "Storage Key Collision: Can collisions in (account_id, backup_id) cause cross-account share mixing? upload_share.rs:64-67",
    "BTreeMap Ordering Dependency: Does BTreeMap order affect reconstruction correctness? upload_share.rs:65-66",
    "Storage Capacity Limits: Can attackers fill storage with huge numbers of shares to exhaust resources? upload_share.rs:64-67",
    "Share Collection Initialization: Can empty collections cause logic issues if system expects pre-initialized maps? upload_share.rs:65",
    "Concurrent Modification: Are there race conditions in load/modify/store sequences? upload_share.rs:64-67",
    "Storage Transaction Atomicity: Could a crash between load and store leave inconsistent state? upload_share.rs:65-67",
    "Share Deletion: Without deletion, can stale/compromised shares accumulate indefinitely? upload_share.rs:64-67",
    "Storage Backend Security: Does OffChainContext guarantee integrity/access control? upload_share.rs:65-67",
    "Collection Name Uniqueness: Could hardcoded name map:guardian_shares conflict with other maps? upload_share.rs:23-31",
    "State Persistence Guarantees: After store(), is data durably persisted? upload_share.rs:67",
    "Share Retrieval Consistency: Can get_shares.rs see inconsistent state during uploads? upload_share.rs:64-67",
    "Storage Key Serialization: Can serialization bugs cause incorrect storage locations? upload_share.rs:26-28",
    "Backup ID Immutability: Are backup_ids immutable, preventing mix-up of shares across backups? upload_share.rs:41-42",
    "Share Count Tracking: Is threshold comparison correct given stored share counts? upload_share.rs:64-67",
    "Storage Namespace Isolation: Are different account/backup share sets fully isolated? upload_share.rs:64-67",
    "Map Value Mutation: Could partial updates corrupt BTreeMap? upload_share.rs:65-67",
    "Context Mutation Side Effects: Can OffChainContext mutations leak into other endpoints? upload_share.rs:34-67",
    "Share Replacement Notification: Are share replacements silent, allowing unnoticed attack overwrites? upload_share.rs:58-67",
    "Storage Error Propagation: Do failed store() operations fail loudly or silently? upload_share.rs:67",
    "Collection Lifetime: Are old collections cleaned up, preventing stale data exposure? upload_share.rs:23-31",
    "Share Versioning in Storage: Can incompatible versions exist together? upload_share.rs:64-67",
    "Storage Schema Evolution: Can schema changes break or corrupt stored data? upload_share.rs:23-31",
    "Idempotency Guarantees: Is the upload endpoint idempotent even with overwriting? upload_share.rs:58-67",
    "Share Index Gaps: Do non-consecutive indices affect reconstruction logic? upload_share.rs:65-66",

    # === IV. Input Validation & Deserialization (76–100) ===
    "Request Body Validation: Are there size limits to prevent oversized bodies? upload_share.rs:39",
    "StrEncoded Security: Can malformed string encodings bypass validation? upload_share.rs:39-42",
    "Unwrapping Inner Values: Could inner .0 values be malformed and still pass parsing? upload_share.rs:41-42",
    "AccountId Validation: Does extracted account_id correspond to a real account? upload_share.rs:42",
    "BackupId Validation: Does extracted backup_id correspond to a real backup? upload_share.rs:41",
    "GuardianShare Deserialization: Can malicious share encodings exploit deserialization bugs? upload_share.rs:39-42",
    "Type Confusion: Could GuardianShare enum variant confusion cause issues? upload_share.rs:39-42",
    "Field Bounds Checking: Are numeric fields bounded to prevent overflow? upload_share.rs:52-55",
    "Null/Empty Input Handling: Do null or empty fields cause crashes? upload_share.rs:39-42",
    "Character Encoding Issues: Can encoding issues cause injection or bypass? upload_share.rs:39-42",
    "Request Content-Type: Is content-type validated? upload_share.rs:36-39",
    "Deserialization Error Handling: Do errors leak info? upload_share.rs:39",
    "Canonical Encoding: Does deserialization enforce canonical encoding? upload_share.rs:39-42",
    "JSON Injection: Can JSON injection modify parsed values? upload_share.rs:39",
    "Buffer Overflow: Can large/nested structures exhaust memory? upload_share.rs:39",
    "Share Size Validation: Is there max allowed share size? upload_share.rs:39-42",
    "Request Field Injection: Are unexpected fields ignored or harmful? upload_share.rs:39",
    "Encoding Version Compatibility: Can old encodings result in misinterpretation? upload_share.rs:39-42",
    "Malformed Hex Encoding: Can invalid hex cause issues? upload_share.rs:41-42",
    "Request Tampering: Can MITM tamper with fields? upload_share.rs:36-42",
    "Type Safety: Could deserialized values violate type expectations? upload_share.rs:39-42",
    "Request Origin Spoofing: Can headers/metadata be spoofed? upload_share.rs:36-39",
    "Share Metadata Validation: Are timestamp/version fields checked? upload_share.rs:39-55",
    "Integer Truncation: Could integer truncation cause wrong indexing? upload_share.rs:52-66",
    "Serde Configuration: Could unsafe serde options introduce vulnerabilities? upload_share.rs:39-42",

    # === V. Error Handling & Information Leakage (101–120) ===
    "Account Not Found Disclosure: Does 'Account not found' reveal valid account IDs? upload_share.rs:44-46",
    "Backup Not Found Disclosure: Does error reveal which backups exist? upload_share.rs:48-50",
    "Invalid Share Error: Could invalid share errors leak validation details? upload_share.rs:54-55",
    "Success Message Disclosure: Does successful upload response leak state? upload_share.rs:69-72",
    "Error Type Differentiation: Do different errors allow system mapping? upload_share.rs:44-55",
    "Verification Failure Details: Do detailed verification errors aid attackers? upload_share.rs:53-55",
    "Panic vs Error: Could panics leak stack traces? upload_share.rs:33-74",
    "Deserialization Error Leakage: Do deserialization errors leak internal logic? upload_share.rs:39",
    "Response Timing: Can timing reveal share validity or state? upload_share.rs:33-74",
    "Storage Operation Errors: Do storage errors leak implementation details? upload_share.rs:65-67",
    "HTTP Status Code Mapping: Do status codes leak internal failure reasons? upload_share.rs:73",
    "JSON Serialization Errors: Could serialization errors reveal structure? upload_share.rs:69-73",
    "State Query Side Effects: Could account state queries leak info? upload_share.rs:44-46",
    "Privacy of Guardian Actions: Does endpoint reveal which guardians have uploaded? upload_share.rs:69-72",
    "Backup Structure Leakage: Can probing backup IDs leak structure? upload_share.rs:48-50",
    "Share Count Leakage: Does response leak number of uploaded shares or threshold?",

    # === I. Authentication & Authorization (1–35) ===
    "Missing Authentication Check: The handler function at line 19-35 does not verify the identity of the HTTP request sender. Can an unprivileged attacker query guardian shares for any (account_id, backup_id) pair without proving they own the account, violating the invariant that 'only the owner of an account should be able to request the reconstruction of a backup'?",
    "No Cryptographic Proof of Ownership: Line 25-26 extracts account_id and backup_id from the request without requiring a signature from the account owner's signing key. Can an attacker who learns valid (account_id, backup_id) pairs retrieve shares they should not have access to?",
    "Missing Email Certificate Verification: The handler does not verify that the caller possesses a valid email certificate corresponding to the account's associated email(s). Does this allow recovery without proving email ownership?",
    "Bypass of Recovery Initiation Key (RIK) Check: Unlike the full recovery flow which verifies RIK signatures, this endpoint retrieves shares without RIK validation. Can an attacker obtain shares without proving they initiated recovery?",
    "No Session or Token Validation: The handler includes no session or bearer token validation. Can an attacker replay old requests or reuse stolen credentials?",
    "Missing Account Ownership Verification: Lines 28-29 load shares without checking if the requester is the account owner. Can an attacker enumerate accounts and retrieve shares for accounts they do not own?",
    "No Cross-Reference with Account State: The handler does not call state.get_account(account_id). Can an attacker query shares for deleted or invalid accounts?",
    "Lack of Guardian Authorization Check: The endpoint does not verify whether the caller is an authorized guardian. Can a malicious guardian retrieve shares for backups they are not part of?",
    "Missing Recovery State Validation: The code does not check if the account is in an active recovery state. Can attackers retrieve shares before recovery is initiated?",
    "No Backup ID Validation Against Account: backup_id is used directly without checking if it belongs to the account. Can attackers probe the storage for valid backup structures?",
    "Guardian Privilege Escalation: If a minority guardian can retrieve all shares, can they collaborate to reconstruct a backup without threshold approval?",
    "Off-Chain Node Operator Access: Without identity binding, can a compromised off-chain node operator retrieve shares for any account?",
    "No Proof of Guardian Approval: Shares are returned without any check that guardians approved recovery. Can shares be retrieved before approval?",
    "Bypassing Threshold Enforcement: shares.values().cloned() returns all stored shares without enforcing threshold. Can an attacker reconstruct a backup with fewer than t shares?",
    "Cross-Account Share Leakage: If (account_id, backup_id) is guessable, can an attacker enumerate active recovery attempts?",
    "Trust Model Weakening: Retrieving shares without authorization may reduce required corruption from t guardians to only storage compromise.",
    "Off-Chain Node Minority Corruption Impact: Does this endpoint leak account-to-recovery linkage when a minority node is corrupted?",
    "Swafe-io Trust Dependency Bypass: Skipping certificate checks bypasses Swafe-io's role as CA.",
    "No Multi-Party Authorization: Does returning shares to any caller break the required multi-party recovery model?",
    "Lack of Time-Based Restrictions: If time locks exist elsewhere, does this endpoint bypass them?",
    "Missing IP or Geographic Restrictions: If enforced elsewhere, does this endpoint ignore them?",
    "No Two-Factor Authentication Check: Does share retrieval bypass 2FA settings?",
    "Guardian Notification Bypass: Guardians may not be alerted to unauthorized share retrieval.",
    "Request Replay Attacks: No nonce or timestamp means an attacker can replay requests to collect shares repeatedly.",
    "Man-in-the-Middle Share Interception: If HTTPS is weak, can an attacker intercept shares?",
    "Parameter Injection: Can malformed (account_id, backup_id) probe storage internals?",
    "Cross-Origin Request Forgery (CSRF): If CORS allows, can browsers request shares unknowingly?",
    "Header Manipulation: Can attackers bypass IP filtering via forged headers?",
    "Race Condition in Authorization Checks: If checks happen elsewhere, is TOCTOU possible?",
    "Delegation or Proxy Attacks: Are revoked delegates still able to retrieve shares?",
    "Child Account or Sub-Account Confusion: Does hierarchy lead to cross-account leakage?",
    "Guardian Rotation Timing Attack: Can old guardians retrieve shares during rotation?",
    "Backup Version Confusion: Are old backup versions leaked unintentionally?",
    "Multi-Tenant Isolation Failure: Does CollectionName allow cross-tenant reads?",
    "Authorization Bypass via Error Handling: Can malformed inputs skip checks and still trigger share retrieval?",

    # === II. Privacy & Anonymity Violations (36–65) ===
    "Account-to-Backup Linkage Exposure: Can attackers map which accounts have which backups via queries?",
    "Guardian Set Size Inference: Does returning a vector of shares leak the number of guardians?",
    "Threshold Parameter Leakage: Can attackers infer threshold t by analyzing uploaded shares over time?",
    "Share Index Exposure: Does sending GuardianShare.idx leak guardian ordering?",
    "Temporal Correlation Attack: Can attackers correlate share uploads with recovery attempts?",
    "Network Traffic Analysis: Can attackers infer account activity via response size?",
    "Cross-Account Recovery Pattern Recognition: Can similar share sets reveal common users?",
    "Backup ID as Deterministic Identifier: Can attackers correlate on-chain backup IDs with off-chain shares?",
    "Account ID Correlation: Can attackers identify which accounts are under recovery?",
    "Guardian Identity Leakage via Ciphertext: Does ciphertext format link to guardians?",
    "Email-To-Account Linkage: Can attackers correlate email verification timing with recovery attempts?",
    "VDRF Output Correlation: Can minority corrupted nodes correlate VDRF with share retrieval?",
    "Certificate Authority Timing Attack: Can issued certificates be correlated to share retrievals?",
    "Guardian Identity Exposure via Share Metadata: Does ShareComm leak guardian keys?",
    "Guardian Behavioral Pattern Leakage: Does share upload timing expose guardian habits?",
    "Guardian Set Overlap Analysis: Can attackers detect overlapping guardian sets across accounts?",
    "Ciphertext Leakage: Does ciphertext structure leak guardian identity or share patterns?",
    "Signature Pattern Recognition: Can repeated guardian signatures fingerprint guardians?",
    "Batch Ciphertext Structure Leakage: Does batch format leak guardian ordering?",
    "Off-Chain Storage Enumeration: Can attackers enumerate storage keys and discover active recoveries?",
    "Storage Key Predictability: Can attackers brute-force storage key space?",
    "Database Query Timing Side Channel: Does query timing reveal existence of shares?",
    "Storage Compaction Leakage: Can storage GC timing reveal share lifecycle?",
    "StrEncoded Format Analysis: Does base64 length leak share size or count?",
    "JSON Response Structure Leakage: Does JSON formatting leak versioning or metadata?",
    "Error Message Information Disclosure: Do errors leak existence of accounts or backups?",
    "Empty Response Distinguishability: Can attackers distinguish invalid vs. empty backup IDs?",
    "Multi-Node Query Correlation: Can attackers correlate inconsistencies across nodes?",
    "Request Frequency Analysis: Can attackers identify accounts with active recovery attempts?",
    "Concurrent Request Fingerprinting: Can attackers fingerprint user devices via timing patterns?",

    # === III. Backup/Recovery Security & Threshold Enforcement (66–90) ===
    "Premature Share Retrieval: Can attackers reconstruct a secret before t shares are uploaded?",
    "No Threshold Validation Before Serving Shares: Does this break Shamir security guarantees?",
    "Incremental Share Accumulation Attack: Can attackers accumulate partial shares over time?",
    "Threshold Metadata Absence: Does failure to check threshold parameters enable bypasses?",
    "Guardian Approval Verification Gap: Are shares retrievable without guardian approval?",
    "No Share Verification: Are invalid shares served without re-verification?",
    "Missing Cryptographic Binding to Backup: Can mismatched shares be served?",
    "Share Hash Commitment Bypass: Are shares served without verifying commitments?",
    "Signature Verification Omission: Can unsigned or invalid signatures be served?",
    "Share Index Consistency: Can attackers serve incorrect indices to break reconstruction?",
    "On-Chain vs Off-Chain State Mismatch: Can recovered accounts still serve shares?",
    "Stale Share Retrieval: Can cancelled or outdated shares still be retrieved?",
    "Recovery PKE Mismatch: Are shares served encrypted to wrong keys?",
    "Concurrent Recovery Attempts: Can shares from different recovery sessions mix?",
    "Backup Deletion Not Reflected: Are deleted backups still reconstructable?",
    "BTreeMap Overwrite Semantics: Can attackers observe overwritten shares?",
    "Duplicate Share Handling: Does the endpoint leak information from duplicate uploads?",
    "Partial Share Set Retrieval: Can guardians’ upload order be inferred?",
    "Share Collection Deletion Semantics: Can old shares be reconstructed indefinitely?",
    "Nonexistent Backup ID Handling: Does empty response leak backup validity?",
    "Wrong Account ID for Backup ID: Can attackers detect backup reuse across accounts?",
    "Backup ID Hash Collision: Can collisions enable cross-backup access?",
    "Account ID Type Confusion: Can malformed IDs bypass checks?",
    "Bypass of Recovery Initiation: Does endpoint allow skipping steps 1–3 of recovery?",
    "Guardian Approval Recording Missing: Can attackers claim approval without signatures?",

    # === IV. Input Validation & Serialization (91–110) ===
    "Malicious Request Body Parsing: Can attackers exploit serde_json parsing?",
    "Type Confusion in StrEncoded: Can base64 decode into adversarial AccountId or BackupId?",
    "Base64 Decoding Errors: Are decode errors handled securely?",
    "Bincode Deserialization Exploits: Can crafted payloads cause overflows or memory abuse?",
    "Version Compatibility Issues: Do unsupported versions cause panics?",
    "Response Serialization Errors: Can malformed shares crash JSON serialization?",
    "StrEncoded Serialization Consistency: Can corrupted values break client decoding?",
    "JSON Escaping Vulnerabilities: Are special characters properly escaped?",
    "Large Response Handling: Can attackers cause OOM by uploading many shares?",
    "Serialization Timing Side-Channel: Does serialization time leak share count?",
    "Account ID Serialization to Storage Key: Can inconsistent serialization cause mismatch?",
    "Backup ID Serialization Canonicalization: Can attackers probe inconsistencies?",
    "Tuple Serialization Order Issues: Can attackers exploit key ordering confusion?",
    "Deserialization Error Messages Leak Info: Do error messages expose secrets?",
    "Missing Error Context: Does generic error handling mislead clients?",
    "Silent Storage Corruption Handling: Does load().ok() hide corrupted state?",
    "JSON Error Response Leakage: Do errors leak stack traces?",
    "Empty Account or Backup IDs: Do empty IDs cause abnormal behavior?",
    "Maximum Size Input: Can huge IDs cause overflows?",
    "Special Character Injection in IDs: Can serialization be corrupted via special characters?",

    # === V. State Management & Consistency (111–130) ===
    "Storage Read Consistency: Can concurrent reads produce inconsistent share sets?",
    "Storage Write-Read Race Condition: Can stale data be returned after upload?",
    "Multi-Node Storage Divergence: Can attackers collect shares from multiple inconsistent nodes?",
    "Storage Corruption Handling: Does silent corruption allow exploitation?",
    "Storage Transaction Boundaries: Are reads atomic or inconsistent?",
    "Account State Desync: Are shares served when account state is finalized?",
    "Backup Ciphertext Update Race: Are outdated shares returned after on-chain updates?",
    "Guardian Set Change Not Reflected: Are removed guardians still serving shares?",
    "Recovery Completion Not Propagated: Are shares preserved indefinitely?",
    "Account Deletion Semantics: Can deleted accounts yield shares?",
    "Concurrent Get Requests: Can requests interfere with each other?",
    "Upload-Get Interleaving: Can attackers observe intermediate states?",
    "Cross-Backup Interference: Can share retrieval bleed over across backups?",
    "Unbounded Storage Growth: Can attackers fill storage by initiating many recoveries?",
    "Share Expiration Missing: Are old shares always retrievable?",
    "Garbage Collection Timing Attack: Can attackers infer cleanup events?",
    "Monotonicity of Share Count Violated: Can attackers detect decreasing share counts?",
    "Idempotency Violations: Can inconsistent responses leak information?",
    "State Finalization Ignored: Are shares available post-finalization?",
    "Cross-Contract State Consistency Issues: Does off-chain mismatch on-chain state?",

    # === VI. Cross-Module Security & Integration (131–145) ===
    "Upload-Get Asymmetry: Are shares validated on upload but not on retrieval?",
    "Share ID Mapping Consistency: Does retrieval preserve share_id mapping?",
    "Overwrite Attack: Can corrupted shares replace valid ones?",
    "Account State Access Missing: Are nonexistent accounts allowed?",
    "Backup Ciphertext Unavailability: Can invalid shares be retrieved without loading backup?",
    "Account Recovery State Mismatch: Are shares served to wrong recovery keys?",
    "Storage Collection Name Collision: Can cross-collection collisions leak data?",
    "Storage Serialization Format Mismatch: Can serialization mismatch prevent access?",
    "Storage Backend Semantics: Does eventual consistency break assumptions?",
    "GuardianShare Cryptographic Binding Missing: Can shares be substituted?",
    "Shamir Secret Sharing Threshold Bypass: Does retrieval skip threshold checking?",
    "PKE Decryption Key Mismatch: Are shares encrypted to wrong keys returned?",
    "Signature Verification Bypass: Are invalid signatures ignored?",
    "Routing Collision: Can alternative routes trigger unintended access?",
    "CORS and Origin Validation Issues: Can cross-origin attackers retrieve shares?",

    # === VII. Cryptographic Correctness (146–150) ===
    "Lack of Authenticated Encryption Context: Can shares be misused across contexts?",
    "Share Commitment Verification Missing: Can attackers serve shares with wrong commitments?",
    "Guardian Signature Freshness Missing: Can old signatures be replayed?",
    "PKE Ciphertext Malleability: Can attackers modify ciphertext stored in storage?",
    "Threshold Secret Reconstruction Outside Module: Are incorrect parameters allowed during reconstruction?",

    # ================================
    # I. Input Validation & Deserialization (25)
    # ================================
    "Malformed Node ID Attack: In the handler function at line 51, can an attacker supply a request.node_id that doesn't conform to the NodeId format (e.g., missing 'node:' prefix, invalid characters) and bypass validation to cause the endpoint to fail after partially modifying state? init.rs:51-54",
    "Type Confusion in StrEncoded Deserialization: The Request type uses StrEncoded<NodeId> and StrEncoded<OffchainSecret>. Can an attacker craft a base64-encoded payload that deserializes successfully as NodeId but contains extra data that corrupts subsequent operations? init.rs:19-20",
    "Secret Deserialization Bounds Check: At line 57, request.secret.0 is directly used without validating the internal structure of OffchainSecret. Can an attacker supply malformed VdrfPublicKey, VdrfSecretKeyShare, or randomizer fields that pass deserialization but cause crashes or undefined behavior in VDRF operations? init.rs:57-58",
    "Empty Node ID Attack: Can an attacker submit an empty string as node_id that passes the parse() operation but causes the state.nodes.get() lookup to fail silently or return an unintended node configuration? init.rs:51-54",
    "Oversized Secret Payload: The OffchainSecret structure contains cryptographic elements. Can an attacker submit an extremely large serialized secret that consumes excessive memory during deserialization at line 48, even if it's eventually rejected? init.rs:48",
    "Invalid UTF-8 in Request Body: The deserialize_request_body function requires UTF-8 body. If the body contains invalid UTF-8 sequences, does the error handling at line 48 leak information about the internal state of the node? init.rs:48",
    "Null Byte Injection in Node ID: Can an attacker inject null bytes or other control characters into the node_id field that pass NodeId parsing but cause mismatches during the state.nodes.get() lookup at line 52? init.rs:52-54",
    "Duplicate Field Exploitation in JSON: If the JSON request body contains duplicate fields (e.g., two node_id fields), which value does deserialize_request_body use, and can this be exploited to bypass validation? init.rs:48",
    "Case Sensitivity in Node ID Lookup: The node_id is converted to string for the state.nodes.get() lookup at line 52. If node IDs are case-insensitive during setup but case-sensitive during lookup, can an attacker initialize with a different casing to bypass the existing node check? init.rs:52-54",
    "Extra Fields in Request: If the request JSON contains extra, unexpected fields beyond node_id and secret, does the deserialization silently ignore them or could they interfere with the initialization process? init.rs:48",
    "Invalid VdrfPublicKey Group Elements: The OffchainSecret.public_key contains elliptic curve points. Can an attacker supply points not on the curve or the identity element that pass deserialization but break VDRF security assumptions? init.rs:57-68",
    "Zero Secret Share Attack: Can an attacker provide a VdrfSecretKeyShare with value zero that hashes to match the commitment but breaks the threshold security of VDRF evaluation in downstream endpoints? init.rs:57-68",
    "Randomizer Field Validation: The OffchainSecret contains a 32-byte randomizer. Is this randomizer validated for uniqueness or randomness quality, or can an attacker supply all zeros/predictable values that weaken cryptographic operations? init.rs:57-68",
    "Bincode Version Incompatibility: The deserialization uses bincode with BINCODE_CONFIG. If the config changes between versions, can old serialized secrets be replayed to initialize nodes with deprecated formats? init.rs:48",
    "Node ID String Encoding Mismatch: The NodeId is stored as StrEncoded<NodeId> but also compared as a string at line 52. Can encoding differences (e.g., Unicode normalization) cause the same logical node ID to be treated as different? init.rs:51-54",
    "Request Body Size Limits: Is there a maximum size enforced on the HTTP request body before deserialization begins at line 48, or can an attacker submit arbitrarily large requests? init.rs:48",
    "Recursive Structure in OffchainSecret: Can the serialization format support recursive or deeply nested structures that cause stack overflow during deserialization at line 48? init.rs:48",
    "Tagged Separator Collision: The OffchainSecret implements Tagged with a specific separator. Can an attacker craft a payload that collides with this separator to confuse the hash verification at line 58? init.rs:58-64",
    "Partial Deserialization Attack: If deserialization of Request partially succeeds but leaves some fields uninitialized, can this lead to use of uninitialized memory in subsequent operations? init.rs:48",
    "Node ID Homoglyph Attack: Can an attacker use Unicode homoglyphs (e.g., Cyrillic 'a' vs Latin 'a') in the node ID to create visually identical but distinct IDs that bypass duplicate checks? init.rs:51-54",
    "Secret Field Order Dependency: Does the bincode deserialization depend on field order in OffchainSecret? Can reordering fields in the serialized form bypass validation? init.rs:57-68",
    "Invalid G1/G2 Point Encoding: The VdrfPublicKey contains elliptic curve points. Are compressed vs uncompressed point encodings both accepted, and can this lead to non-canonical representations passing verification? init.rs:57-68",
    "Infinite/NaN in Field Elements: Can an attacker supply floating-point special values (Inf, NaN) in any numeric fields that pass deserialization but cause arithmetic errors? init.rs:57-68",
    "Params Injection via URL: The handler receives _params: Params but doesn't use them. Can URL path parameters be injected to affect routing or cause unexpected behavior? init.rs:38-43",
    "JSON Number Precision Loss: If numeric fields in OffchainSecret exceed JSON number precision, can deserialization silently truncate values leading to commitment mismatch? init.rs:48",

    # ================================
    # II. Commitment Verification & Cryptographic Correctness (30)
    # ================================
    "Commitment Timing Attack: At lines 58-64, the hash comparison uses != operator. Is this constant-time, or can an attacker use timing differences to learn information about the committed secret? init.rs:58-64",
    "Hash Function Collision Resistance: The hash(&secret) uses SHA3-256. If a collision is found, can an attacker initialize with a different secret that has the same hash? init.rs:57-64",
    "Preimage Attack on Commitment: Can an attacker who observes node_config.comm derive the original OffchainSecret through preimage attacks on the hash function? init.rs:58-64",
    "Tagged Hash Domain Separation: The hash() function should use domain separation via the Tagged trait. If OffchainSecret doesn't properly implement Tagged, can hashes collide with other data types? init.rs:58-64",
    "Second Preimage Attack: Given node_config.comm, can an attacker find a second OffchainSecret that hashes to the same value, allowing them to initialize with incorrect VDRF parameters? init.rs:58-64",
    "Commitment Malleability: Can the commitment node_config.comm be malleated such that two different representations verify against the same hash? init.rs:58-64",
    "VdrfPublicKey Consistency: The submitted secret.public_key is not verified against state.vdrf_public_key. Can an attacker submit a secret with a different public key that still satisfies the hash commitment but breaks VDRF correctness? init.rs:57-68",
    "Secret Share Validity: Is the VdrfSecretKeyShare validated to be a proper share of the VDRF secret polynomial? init.rs:57-68",
    "Threshold Parameter Tampering: The VdrfPublicKey.ci vector length determines the threshold. If the submitted public key has incorrect length, does this break threshold security assumptions? init.rs:57-68",
    "Polynomial Degree Mismatch: Can an attacker submit a VdrfPublicKey with degree different from the global state.vdrf_public_key, passing commitment but causing reconstruction to fail? init.rs:57-68",
    "Randomizer Reuse Across Nodes: If multiple nodes use the same randomizer, does this weaken any cryptographic properties or enable correlation attacks? init.rs:57-68",
    "Hash Length Extension Attack: Does the hash implementation prevent length extension attacks? init.rs:58-64",
    "Cross-Protocol Hash Collision: Can the hash of an OffchainSecret collide with hashes used elsewhere, creating ambiguity? init.rs:58-64",
    "Commitment Binding to Node ID: The commitment only binds to the secret, not the node_id. Can an attacker initialize node A with node B's secret? init.rs:58-64",
    "Pairing-Friendly Curve Attack: If the submitted secret share exploits pairing properties incorrectly, can it break the VDRF security proof? init.rs:57-68",
    "G1/G2 Subgroup Membership: Are public key elements verified to be in the correct subgroups? init.rs:57-68",
    "Cofactor Attack on Public Key: Can an attacker exploit cofactor multiplication to create valid commitments with invalid secrets? init.rs:57-68",
    "Secret Share Additive Homomorphism: Can an attacker initialize with a share that's a linear combination of multiple honest shares? init.rs:57-68",
    "Evaluation Point Collision: Can two different node IDs map to the same evaluation point, letting one node impersonate another? init.rs:51-68",
    "Serialization Canonicalization: Does the hash computation use canonical serialization? init.rs:58-64",
    "Public Key Generator Verification: Is c0 verified to be derived from the correct generator? init.rs:57-68",
    "Zero Knowledge Property Violation: Does storing raw VdrfSecretKeyShare violate ZK properties? init.rs:66-71",
    "Commitment Verification Order: Can attacker exploit the ordering of operations to corrupt state? init.rs:52-64",
    "Hash Input Ambiguity: Can field ordering or padding create distinct secrets with the same hash? init.rs:58-64",
    "Cryptographic Agility Downgrade: If multiple hash functions are added later, can weaker hashes be used? init.rs:58-64",
    "Side-Channel Leakage in Hash: Does hashing leak timing/cache info? init.rs:58-64",
    "Public Key Blinding Attack: Can attacker blind the public key in a way that passes commitment but breaks evaluation? init.rs:57-68",
    "Randomizer Purpose Validation: The randomizer is stored but never validated. Can this weaken security? init.rs:57-68",
    "Polynomial Commitment Consistency: Are ci verified to match the secret at the evaluation point? init.rs:57-68",
    "Field Element Serialization Attack: Can multiple representations of field elements be exploited? init.rs:57-68",

    # ================================
    # III. Storage & State Management (25)
    # ================================
    "Race Condition in Initialization Check: Between checking OffchainSecrets::load() at line 44 and storing at line 71, can concurrent requests initialize the same node twice? init.rs:44-71",
    "Storage Overwrite Attack: Can OffchainSecrets::store() overwrite legitimate data after initialization? init.rs:71",
    "Singleton Storage Key Collision: OffchainSecrets uses () as key. Can nodes collide? init.rs:31-36",
    "Storage Persistence Failure: If storage fails but state is updated, does node remain inconsistent? init.rs:71",
    "Off-Chain Storage Corruption: Can attacker modify stored secret directly in storage backend? init.rs:71",
    "Storage Serialization Mismatch: If serialization format changes, can old stored values break logic? init.rs:22-26",
    "Node ID Mismatch in Storage: StoredOffchainSecret stores node_id redundantly. Can mismatch cause failures? init.rs:66-69",
    "Mapping Collection Name Collision: Could other modules use same collection name 'map:node-secret'? init.rs:28-36",
    "Storage Transaction Atomicity: If crash occurs mid-way, can node get stuck? init.rs:44-71",
    "Clone Semantics in Storage: Can shallow vs deep clone bugs corrupt stored data? init.rs:22-26",
    "Storage Quota Exhaustion: Can attacker exhaust quota by repeated init/de-init? init.rs:71",
    "Key Serialization in Mapping: Is key () serialized deterministically? init.rs:31-36",
    "Value Deserialization Failure: What happens if stored secret corrupts and load() fails? init.rs:31-36",
    "Storage Backend Assumptions: Does logic assume incompatible backend behavior? init.rs:71",
    "Concurrent Read-Write Hazard: Can other endpoints read partial data during init? init.rs:44-71",
    "Storage Metadata Leakage: Does backend expose metadata that leaks secret info? init.rs:71",
    "OffChainContext Mutability: Can multiple storage calls cause unintended state changes? init.rs:39-71",
    "Storage Key Enumeration: Can attacker enumerate stored secrets? init.rs:31-36",
    "Default Value Semantics: Can default OffchainSecrets be mistaken as real? init.rs:28-29",
    "Storage Rollback Scenario: If error occurs after storing, is change rolled back? init.rs:71-81",
    "StrEncoded Storage Overhead: Does encoding overhead cause storage issues? init.rs:24",
    "Secret Immutability After Storage: Can stored secrets be modified by any means? init.rs:71",
    "Storage Compression Side-Channel: Can compressed size leak entropy? init.rs:71",
    "Collection Name Injection: Can name contain malicious characters? init.rs:35",
    "Storage Read Amplification: Does load() cause excessive reads? init.rs:44-46",

    # ================================
    # IV. Authentication & Authorization (20)
    # ================================
    "Endpoint Authentication: No caller identity verification—can anyone initialize nodes? init.rs:38-43",
    "Node Ownership Verification: No check requester owns node_id. Can attacker init others' nodes? init.rs:51-54",
    "IP Address Filtering: Should init only be allowed from specific IP? init.rs:38-43",
    "Signature-Based Authentication: Should request be signed? Missing currently. init.rs:48",
    "Replay Attack on Request: Can old requests be replayed after restarts? init.rs:48-71",
    "Timestamp Validation: No timestamps or nonces—can requests be replayed indefinitely? init.rs:48",
    "TLS Client Certificate: Should endpoint require client certificates? init.rs:38-43",
    "Partisia Address Verification: Should requester be validated against stored address? init.rs:52-54",
    "Cross-Node Initialization: Can attacker use node A's secret to init node B? init.rs:51-71",
    "Admin Privilege Escalation: Can admin override and initialize arbitrary nodes? init.rs:38-43",
    "Public Key-Based Authentication: Should submitter sign request using node's private key? init.rs:52-54",
    "Session Management: Is CSRF possible if operator is logged in somewhere? init.rs:38-43",
    "API Key Validation: Should initialization require API key or bearer token? init.rs:38-43",
    "Multi-Factor Authentication: Should MFA be required? init.rs:38-43",
    "Origin Header Validation: Can Origin/Referer be used to prevent unauthorized access? init.rs:38-43",
    "Challenge-Response Protocol: Should node prove possession of private key? init.rs:38-71",
    "Network Segmentation: Should endpoint only be internal to private network? init.rs:38-43",
    "Rate Limiting Per Node: Can attacker brute-force initialization attempts? init.rs:38-43",
    "Authorization Bypass via State: Can modified ContractState bypass checks? init.rs:40-43",
    "Trust on First Use (TOFU): Is TOFU acceptable? init.rs:44-71",

    # ================================
    # V. Error Handling & Information Leakage (20)
    # ================================
    "Error Message Distinguishability: Are errors unique enough to be used for probing? init.rs:44-64",
    "Node ID Enumeration: Error reveals which node IDs exist. init.rs:52-54",
    "Commitment Mismatch Error: Can timing analysis leak info about commitment? init.rs:59-63",
    "Serialization Error Details: Does deserialization error expose field names or structure? init.rs:48",
    "Success Message Leakage: Does fixed success message leak state? init.rs:75-78",
    "Error Code Mapping: Do varied HTTP codes allow fingerprinting? init.rs:44-81",
    "Stack Trace Exposure: Are stack traces exposed on panic? init.rs:38-81",
    "Timing Side-Channel in Error Paths: Do different errors take different time? init.rs:44-81",
    "Error Recovery State: Does error reveal partial state after failure? init.rs:44-81",
    "Debug Logging: Do debug logs leak sensitive info? init.rs:38-81",
    "Panic Handling: If panic occurs in hash/storage, is sensitive data exposed? init.rs:38-81",

    # I. Email Certificate Verification & Authentication (1–25)
    "Certificate Time Validation: In the handler function, does EmailCert::verify at line 55 properly validate certificate timestamps using ctx.current_time(), and could a malicious user replay an expired certificate if off-chain node clocks are manipulated?",
    "Certificate Signature Verification: At line 55, if the Swafe public key deserialization at lines 41-43 produces a corrupted but valid curve point, could EmailCert::verify accept forged certificates that violate the invariant 'only the owner of an email should be able to request recovery'?",
    "User Signature on Node ID: Does the EmailCert::verify call at line 55 properly check that the user's signature covers the specific node_id extracted at line 52, preventing an attacker from reusing a token meant for a different node?",
    "Swafe Public Key Integrity: At lines 41-43, if state.swafe_public_key is corrupted in storage, could deserialization succeed with an invalid key that allows forged email certificates to pass verification?",
    "Certificate Validity Period: Does EmailCert::verify at line 55 enforce the 5-minute validity period correctly, and could an attacker exploit timezone differences or clock skew to extend certificate lifetime?",
    "Email Extraction: After EmailCert::verify returns (email, user_pk) at line 55, is the extracted email string properly validated before parsing into EmailInput at line 57, preventing injection attacks?",
    "User Public Key Binding: At line 55, does verification ensure the certificate's embedded user public key matches the one used in AssociationRequestEmail.verify at line 63, preventing key substitution attacks?",
    "Token Replay Across Nodes: Could an attacker intercept a valid EmailCertToken from line 55 and replay it to multiple off-chain nodes simultaneously, creating duplicate MskRecord entries for the same email?",
    "Certificate Revocation: Does the handler support any revocation mechanism for compromised email certificates, or would a leaked certificate remain valid until expiration at line 55?",
    "Future-Dated Certificates: At line 55, if ctx.current_time() returns a timestamp earlier than the certificate's issue time, does verification properly reject it with CertificateFromFuture error?",
    "Node ID Verification: At line 52, if stored_secret.node_id.0 is extracted from off-chain storage, could a compromised minority node substitute a different node ID before passing it to EmailCert::verify at line 55?",
    "Email Parsing Failures: At line 57, if email.parse::<EmailInput>() fails due to malformed email format, does the error handling prevent leaking information about which emails are already registered?",
    "User Public Key Substitution: Between extracting user_pk at line 55 and using it in verify at line 63, could an attacker manipulate the value to bind a different user's public key to their email?",
    "Certificate Message Integrity: Does EmailCert::verify at line 55 check that the certificate message hasn't been modified after signing, specifically the email and user_pk fields?",
    "Timestamp Overflow: At line 55, if the certificate timestamp is near u64::MAX, could ctx.current_time() calculations overflow when checking expiration?",
    "Email Case Sensitivity: When email.parse() at line 57 creates an EmailInput, does it normalize email casing to prevent duplicate registrations with different capitalizations?",
    "Swafe Key Rotation: If Swafe-io rotates their signing key, how does line 41-43's deserialization of state.swafe_public_key handle verification of certificates signed with old keys?",
    "Certificate Time Window: Does the 5-minute validity period enforced at line 55 prevent race conditions where multiple users try to associate the same email simultaneously?",
    "Node Context Time Source: At line 55, is ctx.current_time() resistant to manipulation by the executing off-chain node, ensuring accurate certificate expiration?",
    "Signature Algorithm Changes: If the signature scheme used by EmailCert::verify at line 55 is upgraded in a future version, how are old certificates handled?",
    "Email Canonicalization: Before line 57's parse operation, is the email string canonicalized to prevent 'user@example.com' and 'user+tag@example.com' from being treated as different?",
    "User Key Type Validation: Does EmailCert::verify at line 55 validate that user_pk is a well-formed curve point on the correct curve before using it?",
    "Certificate Binding Scope: At line 55, does the certificate bind the email to the specific node_id, or could a malicious user reuse the same certificate across multiple nodes with different associations?",
    "Time Source Consistency: If different off-chain nodes have clock drift, could line 55's ctx.current_time() lead to inconsistent certificate acceptance across nodes?",
    "Email Privacy in Errors: If certificate verification fails at line 55, do error messages leak the email address being verified, violating privacy assumptions? upload_msk.rs:41-58",

    # II. VDRF Evaluation & EmailKey Generation (26–50)
    "VDRF Public Key Integrity: At lines 48-50, if state.vdrf_public_key deserialization produces a corrupted public key, could EmailKey::new at line 58 create colliding email tags for different emails?",
    "VDRF Evaluation Verification: Does EmailKey::new at line 58 properly verify the VDRF evaluation proof before accepting it, preventing attackers from providing arbitrary email tags?",
    "Email Tag Collision: Could two different valid emails hash to the same EmailKey at line 58, allowing one user to overwrite another's association in storage?",
    "VDRF Evaluation Freshness: At line 58, is there any mechanism to prevent replay of old VDRF evaluations, allowing attackers to re-associate emails with stale data?",
    "Threshold Enforcement: Does Vdrf::verify called within EmailKey::new at line 58 enforce the correct threshold t, ensuring minority nodes cannot forge evaluations?",
    "VDRF Input Binding: When EmailKey::new is called at line 58, does it verify the VDRF evaluation was computed over the exact email from line 57, preventing input substitution?",
    "Evaluation Share Validation: At line 58, does the verification check that the VDRF evaluation combines shares from at least t distinct nodes, preventing Sybil attacks?",
    "VDRF Determinism: If the same email and VDRF public key are used twice at line 58, will EmailKey::new produce identical tags, or could non-determinism allow storage overwrites?",
    "Email Tag Truncation: Does EmailKey::new at line 58 produce a 32-byte tag from a larger VDRF output, and could truncation lead to collisions?",
    "VDRF Public Key Version: At lines 48-50, if the VDRF public key is upgraded during protocol operation, how does line 58 handle evaluations computed under old keys?",
    "Evaluation Format Validation: Before passing to EmailKey::new at line 58, is request.vdrf_eval.0 validated as a well-formed G2 point on the correct curve?",
    "VDRF Domain Separation: Does the VDRF evaluation at line 58 include proper domain separation tags to prevent cross-protocol attacks?",
    "Email Input Encoding: At line 57, does the EmailInput encoding match the encoding expected by VDRF evaluation at line 58, preventing verification failures?",
    "Off-Chain Node Collusion: If a minority of corrupted nodes provide partial evaluations, could line 58's EmailKey::new be tricked into accepting invalid combinations?",
    "VDRF Proof Binding: Does the VDRF verification at line 58 check that the evaluation is cryptographically bound to both the email and the VDRF public key?",
    "EmailKey Uniqueness: At line 58, if two users register the same email to different accounts, does the second call properly fail or overwrite, violating the invariant 'an email should be associated to at most one account at a time'?",
    "Evaluation Precomputation: Could an attacker precompute VDRF evaluations for common emails before line 58's verification to frontrun legitimate users?",
    "VDRF Public Key Commitment: At lines 48-50, is the deserialized VDRF public key verified against an on-chain commitment to prevent substitution?",
    "Email Tag Overwrite: When MskRecordCollection::store is called at line 60-64, does it check if an EmailKey already exists, preventing silent overwrites of existing associations?",
    "VDRF Evaluation Malleability: At line 58, if the VDRF evaluation signature is malleable, could an attacker create multiple valid evaluations for the same email?",
    "EmailInput Serialization: Between line 57's parse and line 58's VDRF verification, is the EmailInput serialization canonical to prevent different byte representations?",
    "VDRF Zero Evaluation: At line 58, if the VDRF evaluation produces a zero output, could this create a trivial EmailKey that collides with other inputs?",
    "Partial Evaluation Ordering: Does the VDRF combine operation within line 58's verification care about share ordering, and could attackers manipulate ordering to change outputs?",
    "VDRF Lagrange Interpolation: At line 58, does the verification check that Lagrange interpolation was performed correctly over the correct evaluation points?",
    "EmailKey Storage Key: At line 58, does the 32-byte EmailKey provide sufficient collision resistance given the birthday paradox for the expected number of users? upload_msk.rs:48-58",

    # III. AssociationRequestEmail Verification (51–75)
    "User Public Key Mismatch: At line 63, does association.verify(user_pk, &node_id) properly check that the embedded user_pk matches the one from the email certificate at line 55?",
    "Node ID Substitution: Between line 52 (node_id extraction) and line 63 (verify call), could a compromised node substitute a different node_id to affect secret share computation?",
    "Secret Share Verification: Does verify at line 63 check that share is consistent with the Pedersen commitments for the given node_id, preventing share forgery?",
    "Commitment Count Validation: At line 63, does the verification ensure the number of Pedersen commitments matches the threshold t, preventing invalid threshold configurations?",
    "SoK Proof Verification: Within the verify call at line 63, is the Signature of Knowledge proof properly validated against the user's public key and commitments?",
    "Share Randomness: Does line 63's verification check that the secret share's randomness component is properly committed, preventing share malleability?",
    "Pedersen Generator Consistency: At line 63, does verification use the same Pedersen generators across all nodes, preventing different nodes from accepting incompatible shares?",
    "Commitment Binding: Does verify at line 63 check that commitments are cryptographically bound to the ciphertext, preventing commitment-ciphertext mismatches?",
    "Zero Share Detection: At line 63, if the provided share is zero, does verification reject it as invalid since zero breaks secret sharing security?",
    "Evaluation Point Collision: At line 63, if two node IDs hash to the same evaluation point, could both nodes accept the same share, violating threshold assumptions?",
    "Ciphertext Integrity: Does verify at line 63 check that the encrypted MSK ciphertext hasn't been tampered with before accepting the association?",
    "Commitment Curve Validation: At line 63, are all Pedersen commitments validated as points on the correct elliptic curve before verification?",
    "SoK Message Binding: Does the SoK proof verified at line 63 bind to the user's public key specifically, preventing proof reuse across different users?",
    "Share Value Range: At line 63, is the secret share validated to be within the valid field element range, preventing out-of-bounds values?",
    "Threshold Consistency: If line 63's verification succeeds with threshold t, does it ensure the same threshold is used across all nodes for the same email?",
    "Commitment Zero Check: At line 63, if any Pedersen commitment is the point at infinity, does verification reject it as invalid?",
    "Node-Specific Shares: Does line 63's verification ensure the share is computed specifically for the calling node's ID, preventing share reuse across nodes?",
    "Ciphertext Version: At line 63, if the EncryptedMsk has a version tag, does verification check compatibility with the current protocol version?",
    "Share Polynomial Degree: Does line 63's verification check that shares correspond to a polynomial of degree t-1, enforcing correct threshold semantics?",
    "User Key Authority: At line 63, how does verification ensure the user_pk has authority over the email, beyond just certificate possession?",
    "Commitment Opening Validity: At line 63, does verification check that the share could be a valid opening to the commitments without fully opening them?",
    "Fixed Fields Consistency: Within the AssociationRequestEmail verified at line 63, are all 'fixed' fields checked for consistency across nodes?",
    "SoK Proof Freshness: Does the SoK proof verified at line 63 include any freshness guarantees, or could old proofs be replayed?",
    "Share Lagrange Coefficient: At line 63, is the correct Lagrange coefficient for the node's evaluation point used in share verification?",
    "Verification Error Handling: If verify at line 63 fails, does it return a generic error or leak information about which specific check failed? upload_msk.rs:60-64",

    # IV. Storage Operations & State Management (76–100)
    "Storage Overwrite Race: At lines 60-64, if two concurrent requests store MskRecord for the same EmailKey, which value persists and could this violate uniqueness?",
    "Storage Serialization: When MskRecordCollection::store is called at line 60-64, are there any size limits on the serialized MskRecord to prevent storage exhaustion?",
    "Storage Key Collision: At line 60-64, does the Mapping trait's key serialization ensure EmailKey values produce unique storage keys?",
    "Storage Atomicity: Is the store operation at line 60-64 atomic, or could partial writes leave storage in an inconsistent state if the node crashes?",
    "Collection Name Conflict: The collection name 'map:associations' at line 30—could other endpoints accidentally access this collection and corrupt data?",
    "Storage Retrieval: If MskRecordCollection::load is called elsewhere for the EmailKey created at line 58, will it successfully deserialize the stored MskRecord?",
    "Storage Key Uniqueness: At line 60-64, does the email tag serve as a unique identifier across all users, or could different users with different VDRFs collide?",
    "Storage Version Migration: If the MskRecord structure changes in a future version, how does line 60-64's storage handle deserialization of old records?",
    "Storage Deletion: Is there any mechanism to delete a MskRecord from storage after it's stored at line 60-64, and could this be abused?",
    "Storage Read-After-Write: Can the same handler read back the value immediately after line 60-64's store operation, and is the value guaranteed to be visible?",
    "Storage Encoding: Does the Mapping trait use consistent serialization for both key (EmailKey) and value (MskRecord) at line 60-64?",
    "Off-Chain Storage Durability: After line 60-64 stores the record, is it immediately durable or could a node crash lose the data?",
    "Storage Namespace Isolation: At line 30, does COLLECTION_NAME = 'map:associations' ensure isolation from other storage collections used by different endpoints?",
    "Storage Capacity Limits: Could an attacker fill storage by creating many associations at line 60-64, causing storage exhaustion for legitimate users?",
    "EmailKey Serialization: When the EmailKey from line 58 is serialized as a storage key at line 60-64, is the serialization canonical and collision-free?",
    "MskRecord Cloning: At line 60-64, is the MskRecord value copied or moved into storage, and could this affect the original data?",
    "Storage Context Safety: Does MskRecordCollection::store at line 60-64 properly use the OffChainContext without introducing side effects?",
    "Collection Initialization: Is the MskRecordCollection at line 24 properly initialized before first use, or could uninitialized state cause issues?",
    "Storage Transaction Semantics: If multiple storage operations occur in the handler, does line 60-64's store participate in any transaction that could roll back?",
    "Storage Key Parsing: When loading an EmailKey from storage, does deserialization properly validate the 32-byte format to prevent corruption?",
    "Default Values: At line 24, MskRecordCollection derives Default—could this introduce uninitialized state bugs when loading non-existent keys?",
    "Storage Error Propagation: If storage fails at line 60-64, how is the error communicated back, and could failures be silently ignored?",
    "EmailKey Uniqueness Guarantee: Across all off-chain nodes, does storing at line 60-64 with the same EmailKey guarantee the same MskRecord is stored?",
    "Storage Concurrent Access: If two nodes store different MskRecord values for the same EmailKey at line 60-64, how is the conflict resolved?",
    "Collection Trait Safety: Does the Mapping trait implementation at lines 26-31 properly handle generic type parameters without type confusion? upload_msk.rs:23-31",

    # V. Request Deserialization & Input Validation (101–115)
    "Request Body Parsing: At line 39, does deserialize_request_body validate the JSON structure before attempting deserialization, preventing malformed input?",
    "Request Size Limits: Is there a maximum size enforced on the HTTP request body before line 39's deserialization to prevent memory exhaustion?",
    "JSON Injection: At line 39, could specially crafted JSON in the request body cause the deserializer to execute unintended code paths?",
    "Field Validation: After line 39 deserializes the Request, are all three fields (token, vdrf_eval, association) validated for correct structure?",
    "StrEncoded Deserialization: At line 39, when StrEncoded<T> types are deserialized, does the base64 decoding properly validate input length and format?",
    "Token Deserialization: In request.token.0 used at line 55, could invalid base64 or bincode data cause deserialization to panic or produce corrupted data?",
    "VDRF Eval Deserialization: At line 58, when accessing request.vdrf_eval.0, does deserialization validate the G2 point encoding to prevent invalid curve points?",
    "Association Deserialization: At line 63, when accessing request.association.0, could deserialization produce an invalid AssociationRequestEmail structure?",
    "UTF-8 Validation: Before line 39's JSON parsing, is the request body validated as UTF-8, or could invalid encoding cause issues?",
    "Request Method Validation: Does the endpoint only accept POST requests, and are other HTTP methods properly rejected before reaching line 39?",
    "Content-Type Validation: Is the Content-Type header validated as application/json before attempting deserialization at line 39?",
    "Bincode Version: At line 39, when StrEncoded fields are decoded from bincode, is version compatibility checked to prevent format mismatches?",
    "Base64 Padding: When StrEncoded types decode base64 at line 39, does URL-safe no-padding mode match the encoding used by clients?",
    "Deserialization Errors: If line 39's deserialization fails, does the error message leak information about the expected request structure?",
    "Request Ordering: Does the handler at line 33 enforce any ordering on fields within the request, or could reordering affect behavior? upload_msk.rs:33-39",

    # VI. Off-Chain Secret Management (116–125)
    "Secret Loading Failure: At lines 45-46, if OffchainSecrets::load returns None, is the VdrfNodeNotInitialized error appropriate, or could this hide other issues?",
    "Node ID Extraction: At line 52, when stored_secret.node_id.0 is extracted, is the NodeId validated as matching the expected node for this contract?",
    "Secret Persistence: After OffchainSecrets::load at line 45, is the loaded secret protected from being leaked via error messages or logs?",
    "Secret Verification: At line 45-46, does the loaded secret include any integrity checks to detect if storage was tampered with?",
    "Initialization Race: Could multiple handlers call OffchainSecrets::load at line 45 concurrently, and is the returned secret consistent across calls?",
    "Secret Storage Location: At line 45, is the off-chain storage for secrets isolated from the MskRecordCollection storage to prevent cross-contamination?",
    "Node ID Mismatch: If the node_id at line 52 doesn't match the node actually executing the handler, what security properties break?",
    "Secret Rotation: If an off-chain node needs to rotate its secret, how does line 45's load operation handle transitions?",
    "Secret Deserialization: When OffchainSecrets::load returns at line 45, does it validate the deserialized structure to prevent corruption?",
    "Context Mutation: At line 45, does load mutate the ctx parameter, and could this affect subsequent operations in the handler? upload_msk.rs:45-52",

    # VII. State Deserialization & Cryptographic Key Loading (126–140)
    "Swafe Key Deserialization Error: At lines 41-43, if encode::deserialize fails, does the custom error message leak information about the key structure?",
    "VDRF Key Deserialization Error: At lines 48-50, does the error handling distinguish between corrupted keys and missing keys, potentially leaking state?",
    "Key Format Validation: At lines 41-43, after deserializing swafe_public_key, is it validated as a well-formed signature verification key on the correct curve?",
    "VDRF Key Format Validation: At lines 48-50, after deserializing vdrf_public_key, are the G1 commitments validated as points on the BLS12-381 curve?",
    "Key Storage Integrity: How does the handler detect if state.swafe_public_key at line 41 or state.vdrf_public_key at line 48 was corrupted in storage?",
    "State Sharing: Is the ContractState at line 35 read-only within this handler, or could mutations affect concurrent handlers?",
    "Key Version Compatibility: At lines 41-50, if the stored keys were serialized with an older version of the code, does deserialization handle version differences?",
    "Deserialization Side Effects: Do the deserialize operations at lines 41-43 and 48-50 have any side effects that could affect handler behavior?",
    "Key Commitment Verification: After deserializing keys at lines 41-50, should they be verified against on-chain commitments to prevent substitution?",
    "Bincode Configuration: At lines 41-50, does encode::deserialize use a consistent bincode configuration across all endpoints?",
    "Key Size Limits: Are there maximum sizes enforced on state.swafe_public_key and state.vdrf_public_key before deserialization at lines 41-50?",
    "Error Message Information Leak: At lines 42 and 49, do the 'Failed to deserialize' error messages reveal information about key formats that aids attackers?",
    "State Access Patterns: Does accessing state.swafe_public_key at line 41 and state.vdrf_public_key at line 48 cause excessive state reads?",
    "Key Caching: Should the deserialized keys at lines 41-50 be cached to avoid repeated deserialization in subsequent requests?",
    "State Consistency: Between lines 41 and 48, could the state parameter change, leading to inconsistent key usage within the same handler? upload_msk.rs:41-50",

    # VIII. Response Handling & Error Propagation (141–150)
    "Success Response: At lines 66-72, does the JSON response leak any sensitive information about the stored association?",
    "Error Conversion: At line 73, does .map_err(|e| e.into()) properly convert all error types without losing security-relevant information?",
    "Response Status Code: Is the 200 status code at line 67 appropriate for all successful stores, or should 201 (Created) be used for new associations?",
    "Error Response Format: If any operation fails, do error responses follow a consistent format that doesn't leak implementation details?",
    "Response Serialization: At lines 66-72, could create_json_response fail to serialize the response, and how is that error handled?",
    "Success Message Generic: At lines 69-70, is 'Association uploaded successfully' generic enough to not reveal information about the association?",
    "Response Timing: Could the time taken to generate a response at lines 66-73 reveal information about whether the association already existed?",
    "Handler Return Type: At line 38, does the Result<HttpResponseData, ContractError> properly map all possible errors to appropriate HTTP responses?",
    "Error Context Loss: When errors are converted at line 73, is enough context preserved for debugging without leaking sensitive data?",
    "Response Content-Type: Does create_json_response at line 66 set proper Content-Type: application/json headers for client parsing? upload_msk.rs:66-74",

    # ================================
    # Email Certificate Verification (1–25)
    # ================================
    "Certificate Timestamp Validation Bypass: In eval.rs:40-45, can an attacker manipulate ctx.current_time() or exploit clock skew to bypass the 5-minute validity window defined in email_cert.rs:7?",
    "Certificate Reuse Across Nodes: Does the endpoint prevent reuse of the same EmailCertToken across multiple nodes eval.rs:29, enabling email enumeration?",
    "Node ID Mismatch Exploitation: Is node_id extracted from stored_secret eval.rs:38 verified to match the node_id signed in the certificate?",
    "Swafe Public Key Deserialization Attack: Can malformed state.swafe_public_key eval.rs:30-32 deserialize successfully but bypass cryptographic validity checks?",
    "Email Certificate Signature Malleability: Does verification eval.rs:40-45 reject malleable signatures that could appear valid?",
    "Future-Dated Certificate Attack: Can timestamp skew between contract time and real-world time bypass future-certificate checks email_cert.rs:101-104?",
    "Email Extraction Information Leakage: After verification eval.rs:40-45, can timing or side channels leak email content despite being discarded?",
    "Certificate Verification Key Confusion: Can an attacker swap swafe_public_key eval.rs:30-32 with a different key to validate forged certificates?",
    "User Public Key Verification Bypass: Does verification ensure token.cert.msg.user_pk truly belongs to the email owner?",
    "Expired Certificate Grace Period Exploit: Does a grace window exist email_cert.rs:107-113 that lets expired tokens pass?",
    "Certificate Chain Validation Missing: Is a certificate chain enforced, or can attackers inject intermediate CA certificates?",
    "Email Normalization Bypass: Is email normalized eval.rs:49 (lowercasing, trimming) to prevent equivalent emails producing distinct results?",
    "Certificate Revocation Check Missing: Is certificate revocation checked before VDRF processing?",
    "Token Binding to Request Missing: Is EmailCertToken cryptographically bound to request parameters to prevent cross-context reuse?",
    "Certificate Timestamp Precision Attack: Can attackers generate multiple certificates in the same second using timestamp precision gaps?",
    "Email Certificate Clone Attack: Can multiple legitimate users of a shared mailbox both authenticate and misuse shared email certificates?",
    "Certificate Deserialization DoS: Can malformed request.token.0 eval.rs:29 cause high CPU usage during parsing?",
    "User PK Verification Skip: Is token.cert.msg.user_pk validated against expected user identity for this request?",
    "Certificate Time Source Manipulation: Can attackers manipulate ctx.current_time() through consensus influence?",
    "Email Case Sensitivity Bypass: Are email case variants treated consistently to avoid binding collisions?",
    "Certificate Nonce Replay: Does the certificate include a nonce to prevent replay of identical tokens?",
    "Multi-Email Certificate Attack: Can certificates bind multiple emails simultaneously?",
    "Certificate Timestamp Rollback: Can old but still-valid certificates be reused to replay evaluation requests?",
    "Email Validation Bypass: Does certificate verification enforce RFC-compliant email formatting?",
    "Certificate Signature Algorithm Confusion: Can attackers exploit signature algorithm confusion or downgrade attacks?",

    # ================================
    # VDRF Cryptographic Security (26–55)
    # ================================
    "Partial Evaluation Verification Missing: Does Vdrf::partial_eval eval.rs:50 verify secret_share is valid for this node?",
    "VDRF Public Key Type Confusion: Can malformed state.vdrf_public_key eval.rs:48 deserialize but remain invalid?",
    "Secret Share Extraction via Timing: Does partial_eval leak secret_share via timing differences?",
    "VDRF Input Domain Separation Missing: Is EmailInput domain-separated v0.rs:46-48 to prevent cross-protocol replay?",
    "Hash-to-Curve Weakness: Does hashing email to a curve point vdrf.rs:139-142 resist collisions?",
    "Evaluation Share Malleability: Can evaluation_result eval.rs:50 be manipulated before encoding?",
    "Secret Share Zero Check Missing: Is secret_share verified non-zero eval.rs:47 as required by vdrf.rs:107-111?",
    "VDRF Public Key Threshold Mismatch: Can threshold in vdrf_public_key vdrf.rs:36-39 be manipulated?",
    "Evaluation Point Collision: Can node_id.eval_point() collide with another node’s evaluation point?",
    "G2 Point Validity Check: Does partial evaluation verify returned G2 points are on-curve?",
    "VDRF Input Canonicalization: Is email canonicalized before hashing eval.rs:49?",
    "Secret Share Polynomial Degree Leakage: Can attackers infer polynomial degree from multiple evaluations?",
    "Evaluation Share Uniqueness: Is returning repeated shares prevented to block statistical leakage?",
    "VDRF Commitment Verification: Is vdrf_public_key verified against expected commitments?",
    "Partial Evaluation Batch Attack: Can attackers batch many email requests to extract algebraic info?",
    "Evaluation Share Encoding Attack: Can StrEncoded eval.rs:55 introduce encoding-level malleability?",
    "VDRF Generator Point Manipulation: Can attackers modify generator points used in evaluation?",
    "Email Input Length Limitation: Is email length capped to prevent hash-to-curve DoS?",
    "VDRF Evaluation Determinism: Are identical emails guaranteed identical partial evaluations?",
    "Secret Share Format Validation: Is secret_share validated for correct size/format?",
    "Evaluation Share Compression: Is compression canonical and non-malleable?",
    "VDRF Public Key Version Confusion: Can mismatched protocol versions produce invalid shares?",
    "Email Hash Preimage Resistance: Is hashing strong enough to prevent preimage discovery?",
    "Evaluation Share Aggregation Attack: Can evaluation shares from nodes leak VDRF private key?",
    "VDRF Input Injection: Can special characters modify VDRF computation paths?",
    "Pairing-Based Attack: Are pairing checks resistant to subgroup or invalid-curve attacks?",
    "Secret Share Refresh Missing: Are secret shares refreshed periodically?",
    "Evaluation Context Binding: Are outputs bound to node + timestamp to prevent replay?",
    "VDRF Output Uniqueness: Are different emails guaranteed distinct VDRF outputs?",
    "Threshold Security Degradation: Can t-1 corrupted nodes infer VDRF secrets combined with metadata?",

    # ================================
    # State & Secret Management (56–80)
    # ================================
    "Off-Chain Secret Initialization Check: Can initialization be raced to insert malicious secrets eval.rs:34-35?",
    "Secret Share Persistence Attack: Can stored_secret.secret.secret_share eval.rs:47 leak via storage side channels?",
    "Node ID Binding Weakness: Does stored_secret.node_id.0 eval.rs:38 match executing node?",
    "State Deserialization Race Condition: Can concurrent deserialization cause inconsistent swafe/vdrf public keys?",
    "Off-Chain Storage Tampering: Can compromised nodes modify OffchainSecrets init.rs:28-36?",
    "Secret Share Leakage via Errors: Do partial_eval errors leak secret_share content?",
    "State Serialization Malleability: Can serialized state be crafted to deserialize into unintended values?",
    "Node Configuration Mismatch: Does state.nodes reflect real node configuration?",
    "Off-Chain Secret Rotation: Can old secrets still be used after rotation?",
    "Storage Collection Name Collision: Can COLLECTION_NAME collide with other namespaces init.rs:35?",
    "Secret Share Zero Value: Can secret_share be forced to zero via initialization?",
    "State Consistency Check Missing: Are swafe_public_key and vdrf_public_key validated for consistency?",
    "Off-Chain Context Manipulation: Can OffChainContext be manipulated to retrieve wrong secrets?",
    "Secret Share Backup Weakness: Are backups accessible or poorly protected?",
    "Node Decommissioning Attack: Are secrets deleted when nodes are removed?",
    "State Version Mismatch: Can outdated serialized state coexist silently?",
    "Secret Share Distribution Verification: Is distribution ceremony verified?",
    "Storage Key Derivation Weakness: Is storage key derivation predictable or guessable?",
    "Concurrent Secret Access: Can concurrent reads leak info about access patterns?",
    "State Migration Attack: Are migrations secure during upgrades?",
    "Off-Chain Storage Overflow: Can an attacker fill storage and block writes?",
    "Secret Share Metadata Leakage: Do metadata leaks expose secret sizes or timing?",
    "Node Identity Proof Missing: Does node prove ownership of secret_share?",
    "State Rollback Attack: Can state rollback re-enable old secrets?",
    "Secret Share Export Vulnerability: Can shares be extracted via API endpoints?",

    # ================================
    # Serialization & Encoding Issues (81–100)
    # ================================
    "Base64 Encoding Attack: Does StrEncoded eval.rs:55 validate base64 correctly?",
    "Deserialization Bomb: Can compressed request.token.0 expand massively?",
    "Type Confusion in Deserialization: Can deserialize_request_body eval.rs:29 parse wrong types?",
    "Bincode Configuration Mismatch: Is BINCODE_CONFIG encode.rs:6 consistent across modules?",
    "Email Token Deserialization Attack: Can malformed StrEncoded<EmailCertToken> crash deserialization?",
    "Serialization Length Prefix Attack: Can attackers manipulate length prefixes causing overflows?",
    "Evaluation Share Encoding Malleability: Can evaluation shares be encoded multiple valid ways?",
    "JSON vs Bincode Confusion: Are boundaries between formats strictly enforced?",
    "Deserialization Resource Exhaustion: Can nested structures cause stack overflow?",
    "String Encoding Validation: Does str_to_bytes encode.rs:46-50 validate UTF-8?",
    "Canonical Encoding Violation: Is encoding canonical to prevent signature malleability?",
    "Deserialization Version Mismatch: Can older protocol versions be accepted silently?",
    "Tagged Encoding Bypass: Can Tagged::encode() encode.rs:20-37 be bypassed?",
    "Serialization Error Information Leak: Do errors leak sensitive fields?",
    "Base64 Padding Attack: Can padding modifications create malformed but accepted data?",
    "Deserialization Backdoor: Could dependency deserializers execute unintended code?",
    "Response Encoding Race: Can concurrent encoding corrupt responses?",
    "Encoded Data Size Limit: Are encoded responses size-limited?",
    "Deserialization Error Handling: Are sensitive buffers wiped after errors?",
    "Encoding Format Confusion: Can hex-encoded data be interpreted as base64?",

    # ================================
    # Privacy & Anonymity Issues (101–125)
    # ================================
    "Email Anonymity Breach via Timing: Does eval time vary with email content?",
    "Node Correlation Attack: Can queries across nodes deanonymize users?",
    "Email Hash Collision: If two emails hash identically, does binding break?",
    "VDRF Output Linkability: Can shares be linked across nodes?",
    "Request Pattern Analysis: Do request patterns reveal email usage?",
    "Email Domain Leakage: Does computation leak domain (@gmail.com vs others)?",
    "Statistical Analysis Attack: Can collected shares reveal email structure?",
    "Network Traffic Analysis: Do packet sizes leak email metadata?",
    "Error Message Email Leakage: Do errors distinguish valid vs invalid emails?",
    "VDRF Determinism Exploitation: Can attackers build email-output rainbow tables?",
    "Cross-Node Email Enumeration: Does querying nodes confirm account associations?",
    "Email Certificate Metadata: Does certificate embed identifying metadata?",
    "VDRF Public Key Observation: Does public key leak email usage patterns?",
    "Evaluation Share Aggregation: Can aggregated shares over time reveal usage patterns?",
    "Email Anonymity Set Size: Is the anonymity set sufficiently large?",
    "On-Chain State Leakage: Does storing vdrf_public_key leak email usage?",
    "Email Normalization Inconsistency: Do inconsistent normalization rules deanonymize users?",
    "VDRF Output Distinguishability: Can attackers distinguish outputs without knowing emails?",
    "Traffic Correlation with On-Chain: Can requests be correlated with on-chain actions?",
    "Email Certificate Timing Attack: Does issuance time leak user activity?",
    "Node Selection Bias: Does selecting specific nodes leak identity info?",
    "VDRF Evaluation Frequency: Does frequency reveal active email accounts?",
    "Email Privacy During Recovery: Does recovery flow leak emails?",
    "Cross-Protocol Email Linkage: Can Swafe email be linked to other protocols?",
    "Anonymity Revocation Attack: Can compromised nodes deanonymize users?",

    # ================================
    # Error Handling & Information Leakage (126–140)
    # ================================
    "Error Type Enumeration: Do EmailCert::verify errors eval.rs:40-45 reveal detailed failure reasons?",
    "Serialization Error Details: Does SerializationError eval.rs:31-32 leak serialized contents?",
    "Node Uninitialized Timing: Can timing distinguish initialized vs uninitialized nodes?",
    "HTTP Status Code Leakage: Do status codes reveal auth failures vs permission failures?",
    "Error Message Standardization: Are messages uniform to prevent leakage?",
    "Stack Trace Exposure: Can internal stack traces be returned?",
    "Partial Success Errors: Do partial evaluation errors leak intermediate data?",
    "Deserialization Failure Context: Does encode::deserialize eval.rs:48 reveal expected types?",
    "Error Recovery Side Effects: Are sensitive buffers wiped after errors?",
    "Concurrent Error Amplification: Can simultaneous requests amplify leakage?",
    "Error Rate Limiting: Is error rate limited to block error-based enumeration?",
    "Cryptographic Error Details: Do crypto errors reveal key-related details?",
    "JSON Response Errors: Does JSON error structure leak metadata?",
    "Error Logging Sensitivity: Are errors logged securely?",
    "Panic Handling: Are panics sanitized to prevent leakage?",

    # ================================
    # Request Validation & Authentication (141–150)
    # ================================
    "Request Body Size Limit: Is request.token eval.rs:29 size-limited to prevent memory exhaustion?",
    "HTTP Method Validation: Is endpoint restricted to POST?",
    "Content-Type Verification: Is Content-Type checked to enforce JSON-only requests?",
    "Request Origin Validation: Are cross-origin requests blocked?",
    "Duplicate Request Prevention: Can attackers repeat requests for timing analysis?",
    "Request Parameter Injection: Can extra request params alter logic?",
    "Authentication Token Binding: Is token bound to requester session?",
    "Authorization Bypass: Can request fields bypass node authorization?",
    "Request Timestamp Validation: Are request timestamps validated to prevent replay?",
    "Multi-Node Query Attack: Can attacker query all nodes simultaneously to accelerate secret reconstruction?",

    # I. Email Certificate Token Verification & Authentication (25 questions)
    "In the handler function at line 43, does EmailCert::verify properly validate that the certificate timestamp is not from the future, preventing attackers from creating certificates with future timestamps to extend their validity window? get_secret_share.rs:43",
    "Does EmailCert::verify at line 43 enforce the 5-minute validity period defined in the email certificate specification, or can an attacker reuse an expired certificate to repeatedly access MSK records? get_secret_share.rs:43",
    "Can an attacker exploit a time synchronization vulnerability where ctx.current_time() at line 43 returns an incorrect timestamp, allowing expired certificates to pass verification? get_secret_share.rs:43",
    "At line 43, if the swafe_pk deserialization succeeds but contains a malformed or zero public key, will EmailCert::verify fail safely or could it allow unauthorized access? get_secret_share.rs:31-43",
    "Does the handler verify that the user_pk extracted from the email certificate at line 43 matches any expected user public key, or can any valid certificate grant access regardless of the user identity? get_secret_share.rs:43",
    "Can an attacker who compromises a minority of off-chain nodes reuse the same token across multiple nodes to retrieve the same MSK record multiple times, violating the invariant that 'Only the owner of an email should be able to request the recovery of an account'? get_secret_share.rs:29-43",
    "At line 43, does the verification check that the node_id signature in the token matches stored_secret.node_id.0, preventing cross-node token reuse attacks? get_secret_share.rs:42-43",
    "If EmailCert::verify returns the email string at line 43, is there proper sanitization to prevent injection attacks when the email is later parsed into EmailInput? get_secret_share.rs:43-45",
    "Can an attacker submit a certificate where the email string contains control characters, null bytes, or Unicode normalization tricks to bypass the email-to-EmailKey binding at lines 45-46? get_secret_share.rs:45-46",
    "Does line 43's verification ensure that the Swafe signature covers the exact node_id value, preventing attackers from using a certificate signed for node A to access data on node B? get_secret_share.rs:42-43",
    "At line 43, if the certificate is valid but was issued for a different email than the one used to generate the VDRF evaluation, can an attacker gain unauthorized access to another user's MSK record? get_secret_share.rs:43-46",
    "Can replay attacks occur where an attacker captures a valid token and VDRF evaluation pair from network traffic and resubmits them within the 5-minute validity window to retrieve the MSK record? get_secret_share.rs:29-49",
    "Does the handler implement any nonce or unique request identifier mechanism to prevent replay attacks on the email certificate token used at line 43? get_secret_share.rs:43",
    "If the user_pk returned at line 43 is used elsewhere in the recovery flow, can an attacker substitute their own public key by manipulating the certificate verification process? get_secret_share.rs:43",
    "At line 43, does the verification properly handle the case where multiple certificates are issued for the same email to different users, preventing one user from accessing another's MSK record? get_secret_share.rs:43",
    "Can an attacker exploit a time-of-check-time-of-use (TOCTOU) race condition between certificate verification at line 43 and MSK record retrieval at line 48-49? get_secret_share.rs:43-49",
    "Does line 43's verification properly reject certificates with timestamps exactly at the boundary of the 5-minute validity period to prevent timing-based attacks? get_secret_share.rs:43",
    "If EmailCert::verify at line 43 throws an error due to signature verification failure, does the error message leak information about which component failed (Swafe signature vs user signature)? get_secret_share.rs:43",
    "Can an attacker forge a certificate by exploiting potential malleability in the signature scheme used by EmailCert::verify at line 43? get_secret_share.rs:43",
    "At line 43, if the certificate contains an email that normalizes to multiple different EmailInput values, can an attacker access MSK records under different EmailKeys? get_secret_share.rs:43-46",
    "Does the handler validate that the token parameter at line 29 has not been revoked or blacklisted before passing it to EmailCert::verify at line 43? get_secret_share.rs:29-43",
    "Can an attacker who obtains a valid certificate for their own email manipulate the vdrf_eval parameter to derive EmailKeys for other users' emails and access their MSK records? get_secret_share.rs:29-46",
    "At line 43, does the verification ensure that the certificate's user public key is properly bound to the email, preventing an attacker from using a certificate for email A with a public key for email B? get_secret_share.rs:43",
    "If an attacker compromises the time source for ctx.current_time() at line 43, can they extend or shorten the certificate validity window to bypass access controls? get_secret_share.rs:43",
    "Does the handler enforce any rate limiting or throttling on certificate verification attempts at line 43 to prevent brute-force attacks on expired certificates? get_secret_share.rs:43",

    # II. VDRF Evaluation & EmailKey Generation (25 questions)
    "At line 46, does EmailKey::new properly verify that the vdrf_eval corresponds to the email input before creating the EmailKey, or can an attacker provide mismatched inputs? get_secret_share.rs:46",
    "Can an attacker who knows the VDRF evaluation for email A reverse-engineer the VDRF secret key shares to compute evaluations for other emails, violating email privacy? get_secret_share.rs:46",
    "At line 46, if the vdrf_eval is computed with a different VDRF public key than vdrf_pk, will EmailKey::new detect this mismatch and reject the request? get_secret_share.rs:38-46",
    "Does the VDRF verification in EmailKey::new at line 46 check the pairing equation correctly to prevent attackers from forging valid-looking evaluations? get_secret_share.rs:46",
    "Can an attacker exploit malleability in the VDRF evaluation representation at line 46 to generate multiple EmailKeys that map to the same storage location? get_secret_share.rs:46",
    "At line 45, if email.parse() performs Unicode normalization, can an attacker use homoglyphs or normalization differences to access MSK records for similar-looking emails? get_secret_share.rs:45",
    "Does EmailKey::new at line 46 ensure that the VDRF output is derived from the correct VDRF public key commitment c0, preventing cross-instance attacks? get_secret_share.rs:46",
    "Can a compromised off-chain node with access to VDRF secret key shares at line 42 precompute EmailKeys for known email addresses to deanonymize users? get_secret_share.rs:42-46",
    "At line 46, if the vdrf_eval parameter is reused across multiple requests for the same email, does this create a linkability vulnerability that compromises email anonymity? get_secret_share.rs:46",
    "Does line 46's EmailKey::new validate that the VDRF evaluation was computed with the threshold number of shares, preventing partial evaluations from being accepted? get_secret_share.rs:46",
    "Can an attacker exploit the deterministic nature of VDRF to correlate EmailKeys across different requests if they can observe the vdrf_eval values? get_secret_share.rs:46",
    "At line 46, if the email input contains trailing whitespace or case differences from what was used during upload, will EmailKey::new generate a different key leading to 'MSK record not found' errors? get_secret_share.rs:45-46",
    "Does EmailKey::new at line 46 perform constant-time operations to prevent timing side-channels that could leak information about the email content? get_secret_share.rs:46",
    "Can an attacker who corrupts a minority of off-chain nodes manipulate the VDRF public key at line 38 to redirect EmailKey lookups to different storage locations? get_secret_share.rs:38-46",
    "At line 46, if vdrf_eval.0 is serialized/deserialized incorrectly, can this lead to EmailKey mismatches that permanently lock users out of their MSK records? get_secret_share.rs:46",
    "Does the VDRF verification at line 46 check that the evaluation point used matches the expected hash-to-curve output for the email, preventing evaluation substitution attacks? get_secret_share.rs:46",
    "Can an attacker exploit the domain separation tag in VDRF evaluation at line 46 to confuse the system between different types of inputs (email vs other data)? get_secret_share.rs:46",
    "At line 46, if the KDF used inside EmailKey::new has weak collision resistance, can an attacker find two different emails that map to the same EmailKey? get_secret_share.rs:46",
    "Does EmailKey::new at line 46 validate that the VDRF evaluation is not the identity element or other degenerate group elements? get_secret_share.rs:46",
    "Can an attacker who compromises the VDRF setup ceremony keys manipulate the VDRF public key at line 38 to break the email anonymization without full corruption of Swafe-io? get_secret_share.rs:38-46",
    "At line 45-46, if the email parsing and EmailKey generation use different string representations (UTF-8 vs ASCII), can this create inconsistencies? get_secret_share.rs:45-46",
    "Does line 46 ensure that the VDRF evaluation has been correctly combined from partial evaluations, preventing attacks where an attacker submits only their own node's partial evaluation? get_secret_share.rs:46",
    "Can an attacker exploit differences in email canonicalization between certificate issuance and VDRF evaluation to access MSK records for emails they don't control? get_secret_share.rs:43-46",
    "At line 46, if multiple VDRF public keys exist in the system due to key rotation, does the handler verify it's using the correct key for the stored MSK record? get_secret_share.rs:38-46",
    "Does EmailKey::new at line 46 prevent attacks where an attacker provides a VDRF evaluation from a different cryptographic group or curve to confuse the verification? get_secret_share.rs:46",

    # III. State Deserialization & Initialization (20 questions)
    "At line 31, if state.swafe_public_key contains malformed data that deserializes to an invalid public key, will this be detected before it's used in verification at line 43? get_secret_share.rs:31-33",
    "Can an attacker who compromises contract state replace state.swafe_public_key at line 31 with their own public key to issue fake email certificates? get_secret_share.rs:31-33",
    "At line 38, does the deserialization of state.vdrf_public_key validate that the threshold value is consistent with the system setup, preventing threshold manipulation attacks? get_secret_share.rs:38-40",
    "If the bincode deserialization at lines 31 and 38 fails partway through, are there partial state updates that could corrupt the contract state? get_secret_share.rs:31-40",
    "Can an attacker exploit version mismatches in serialization formats between upload_msk and get_secret_share to cause deserialization errors at lines 31 or 38? get_secret_share.rs:31-40",
    "At line 35-36, does the handler properly handle the case where the off-chain node has been deinitialized or the stored secret has been deleted? get_secret_share.rs:35-36",
    "If OffchainSecrets::load at line 35-36 returns None, does the error message leak information about whether the node was ever initialized? get_secret_share.rs:35-36",
    "Can a malicious actor who gains write access to off-chain storage overwrite the OffchainSecrets at line 35-36 to impersonate a different node? get_secret_share.rs:35-36",
    "At line 42, does the handler validate that stored_secret.node_id.0 matches the expected node ID for this specific off-chain node instance? get_secret_share.rs:42",
    "If state.swafe_public_key at line 31 has been rotated since the MSK record was uploaded, will verification at line 43 fail even for legitimate users? get_secret_share.rs:31-43",
    "Can an attacker exploit concurrent modifications to state.vdrf_public_key at line 38 between deserialization and use at line 46 to cause inconsistencies? get_secret_share.rs:38-46",
    "At lines 31-32, does the error message for deserialization failure expose sensitive information about the internal structure of state.swafe_public_key? get_secret_share.rs:31-33",
    "If the bincode configuration used at lines 31 and 38 differs from that used during serialization, can this lead to silent data corruption? get_secret_share.rs:31-40",
    "Does the handler verify at line 42 that the node_id stored in OffchainSecrets hasn't been tampered with since initialization? get_secret_share.rs:42",
    "At line 35-36, if multiple threads/requests concurrently access OffchainSecrets::load, are there race conditions that could lead to inconsistent state? get_secret_share.rs:35-36",
    "Can an attacker who corrupts the off-chain storage layer inject a malicious StoredOffchainSecret that passes loading at line 35-36 but causes failures later? get_secret_share.rs:35-36",
    "At lines 38-40, does the error handling for VDRF public key deserialization distinguish between corrupt data vs incompatible versions? get_secret_share.rs:38-40",
    "If the contract state is migrated or upgraded, will the deserialization at lines 31 and 38 handle legacy formats correctly? get_secret_share.rs:31-40",
    "Can an attacker exploit the error message at line 36 to determine whether specific nodes are initialized or not, leaking topology information? get_secret_share.rs:35-36",
    "At line 42, if stored_secret.node_id is a StrEncoded<NodeId>, does the .0 access properly unwrap it without losing validation checks? get_secret_share.rs:42",

    # IV. Storage Access Control & MSK Record Retrieval (20 questions)
    "At lines 48-49, does MskRecordCollection::load properly validate the email_tag parameter to prevent directory traversal or storage injection attacks? get_secret_share.rs:48-49",
    "Can an attacker who knows an EmailKey value directly query the storage at line 48-49 without going through proper email certificate verification? get_secret_share.rs:48-49",
    "At line 48-49, if multiple MSK records exist under the same email_tag due to a collision or malicious upload, which one is returned and how does this affect security? get_secret_share.rs:48-49",
    "Does the storage layer used by MskRecordCollection::load at line 48-49 enforce any access control policies beyond what's implemented in this handler? get_secret_share.rs:48-49",
    "Can an attacker who compromises off-chain storage enumerate all stored EmailKeys at line 48-49 to deanonymize email-to-account associations? get_secret_share.rs:48-49",
    "At line 49, does the error message 'MSK record not found' leak information about whether an email has been associated with an account? get_secret_share.rs:48-49",
    "If MskRecordCollection::load at line 48-49 uses caching, can an attacker exploit cache poisoning to retrieve stale or incorrect MSK records? get_secret_share.rs:48-49",
    "Does the handler verify at line 48-49 that the retrieved msk_record has not been tampered with since it was uploaded via upload_msk? get_secret_share.rs:48-49",
    "At line 48-49, if the storage backend has been compromised, can an attacker inject a malicious MSK record that exploits vulnerabilities in downstream recovery logic? get_secret_share.rs:48-49",
    "Can an attacker exploit timing differences in MskRecordCollection::load at line 48-49 to determine whether records exist for specific EmailKeys? get_secret_share.rs:48-49",
    "At line 48-49, does the collection name 'map:associations' properly namespace the storage to prevent conflicts with other contract data? get_secret_share.rs:48-49",
    "If multiple contracts on the same blockchain use the same collection name at line 48-49, can cross-contract storage access occur? get_secret_share.rs:48-49",
    "Does the handler at line 48-49 enforce any limits on the size or structure of the retrieved MSK record to prevent storage exhaustion attacks? get_secret_share.rs:48-49",
    "Can an attacker who uploaded a malformed MSK record exploit deserialization vulnerabilities when it's loaded at line 48-49? get_secret_share.rs:48-49",
    "At line 48-49, if the storage layer experiences data corruption, will the error be properly caught and reported, or will it be silently returned as a valid MSK record? get_secret_share.rs:48-49",
    "Does MskRecordCollection::load at line 48-49 validate that the retrieved record's internal structure matches expected formats before returning it? get_secret_share.rs:48-49",
    "Can an attacker who gains read access to off-chain storage bypass the email certificate check by directly deserializing stored MSK records at line 48-49? get_secret_share.rs:48-49",
    "At line 48-49, if the EmailKey collides with a key used by a different user due to weak VDRF output, can one user access another's MSK record? get_secret_share.rs:46-49",
    "Does the handler ensure at line 48-49 that the loaded MSK record belongs to the user specified in the email certificate, not just any user with that EmailKey? get_secret_share.rs:43-49",
    "Can an attacker exploit the ok_or_else error handling at line 49 to distinguish between 'record not found' vs 'record exists but access denied' scenarios? get_secret_share.rs:48-49",

    # V. Error Handling & Information Leakage (15 questions)
    "At line 32-33, does the error message 'Failed to deserialize Swafe public key' leak information about the internal state or structure of the contract? get_secret_share.rs:31-33",
    "Can an attacker use the different error types returned by the handler to enumerate which nodes are initialized vs which have stored specific MSK records? get_secret_share.rs:35-49",
    "At line 36, does returning ServerError::VdrfNodeNotInitialized allow an attacker to determine the initialization status of off-chain nodes? get_secret_share.rs:35-36",
    "If an error occurs during email certificate verification at line 43, do the error messages distinguish between expired certificates, invalid signatures, and wrong node IDs? get_secret_share.rs:43",
    "Can timing differences in error responses reveal information about which validation step failed (certificate verification vs VDRF verification vs storage lookup)? get_secret_share.rs:29-49",
    "At line 39-40, does the error message for VDRF public key deserialization expose details about the expected format or structure? get_secret_share.rs:38-40",
    "If email.parse() fails at line 45, does the error message reveal information about email validation rules that could help attackers craft bypass attempts? get_secret_share.rs:45",
    "Can an attacker use error responses to determine whether a particular email has been associated with an account, violating privacy invariants? get_secret_share.rs:43-49",
    "At line 49, does the error message 'MSK record not found' leak information about the storage structure or key derivation process? get_secret_share.rs:48-49",
    "If multiple validation failures occur in sequence, which error is reported and does this leak information? get_secret_share.rs:43-46",
    "Does the handler implement constant-time error handling to prevent timing side-channels from leaking information about authentication outcomes? get_secret_share.rs:23-57",
    "At line 57, does converting errors with map_err(|e| e.into()) properly sanitize error messages before they're returned to clients? get_secret_share.rs:51-57",
    "Can an attacker exploit verbose error messages to learn about the internal architecture, node topology, or cryptographic parameters of the system? get_secret_share.rs:29-57",
    "If deserialization errors occur at lines 31, 38, or 48-49, do stack traces or debug information leak in production error responses? get_secret_share.rs:31-49",
    "Does the error handling properly distinguish between user errors and system errors without leaking sensitive information? get_secret_share.rs:29-57",

    # VI. Serialization & Deserialization Vulnerabilities (15 questions)
    "At line 29, does deserialize_request_body properly validate that the Request structure contains no unexpected fields that could exploit parser vulnerabilities? get_secret_share.rs:29",
    "Can an attacker send a malformed JSON request at line 29 with deeply nested structures to trigger stack overflow or excessive memory consumption? get_secret_share.rs:29",
    "At lines 31 and 38, does the bincode deserialization properly handle endianness to prevent cross-platform inconsistencies? get_secret_share.rs:31-40",
    "If the StrEncoded<VdrfEvaluation> at line 29 contains base64-encoded data, is there proper validation against padding oracle attacks? get_secret_share.rs:29",
    "Can an attacker exploit type confusion by providing a StrEncoded value that deserializes to the wrong type at line 29? get_secret_share.rs:29",
    "At line 54, does encode::StrEncoded(msk_record) ensure canonical encoding to prevent multiple representations of the same data? get_secret_share.rs:54",

    # I. Threshold Correctness & Validation (1–30)
    "Missing Threshold Upper Bound Validation: In the share() function, can a malicious caller set t > n to create an unrecoverable secret sharing where the number of required shares exceeds the total number of shares generated, permanently locking user funds?",
    "Zero Threshold Security: When t=0 in share(), the function returns Secret(pp::Fr::ZERO) and empty shares - does this allow an attacker to bypass guardian approval by creating backups with zero threshold that anyone can recover to a known zero value?",
    "Threshold-One Vulnerability: With t=1, each individual share can independently recover the secret - can a single compromised guardian steal all backup secrets without cooperation?",
    "Integer Overflow in Threshold: Can an attacker pass a t value near usize::MAX to cause integer overflow in the coefficient-generation loop?",
    "Recovery Threshold Bypass: recover() does not validate that the shares slice contains at least t shares - can an attacker attempt recovery with insufficient shares and leak information through interpolation side channels?",
    "Mismatch Between Share and Recover Thresholds: Can an attacker combine shares from different thresholds to violate the t-of-n guarantee?",
    "Threshold Zero Recovery Inconsistency: recover(&[]) returns Secret(pp::Fr::ZERO) - can this be abused to claim recovery of any t=0 backup without authorization?",
    "Guardian Count Validation Gap: n is not validated against actual number of guardians - can this cause orphaned or mismatched shares?",
    "Threshold Exceeding Field Size: Can setting t close to the field modulus create interpolation instability?",
    "Empty Share Vector Attack: share() with n=0 produces zero shares but a non-zero secret - does this permanently brick recovery?",
    "Insufficient Shares Silent Failure: Recovery with < t shares returns a wrong secret instead of an error - can this confuse systems relying on correct outputs?",
    "Exact Threshold Enforcement: Does recover() ensure exactly t unique shares are required?",
    "Threshold Metadata Loss: Share and Secret do not store threshold metadata - can this cause mismatched recovery logic?",
    "Dynamic Threshold Manipulation: Can an attacker alter stored threshold values in BackupCiphertextV0 to weaken recovery requirements?",
    "Guardian Threshold vs SSS Threshold Mismatch: Can inconsistent thresholds between metadata and SSS logic cause unintended bypasses?",
    "Threshold Greater Than Guardians: What happens if share() is invoked directly with t > n?",
    "Single Guardian System: With n=1, t=1, does this degenerate into a single point of failure?",
    "Maximum Threshold Security: With t=n, is DoS possible if one guardian becomes unavailable?",
    "Threshold One Share Distribution: With t=1, distributing n independent shares increases attack surface - is this acceptable?",
    "Zero Coefficient Polynomial: If cs[0] becomes zero, does this create a zero secret that breaks backup encryption?",
    "Cross-Backup Threshold Interference: Does knowing one backup's threshold leak information about others?",
    "Threshold Downgrade Attack: When changing thresholds, can old shares be used to bypass new security settings?",
    "Partial Threshold Information Leak: Does number of shares stored reveal guardian count n?",
    "Threshold Verification Gap: recover() does not return which shares were used - can this hide misuse?",
    "Guardian Approval vs SSS Threshold: Which takes precedence if inconsistent, and can this be exploited?",
    "Threshold Storage Integrity: How is t protected from tampering between storage and recovery?",
    "Minimum Viable Threshold: Is t >= 2 enforced to avoid trivial single-share recovery?",
    "Threshold Serialization: Is threshold information preserved during share/secret serialization?",
    "Fractional Threshold Truncation: Can rounding errors introduce off-by-one threshold vulnerabilities?",
    "Threshold Evolution: Can old shares be mixed with new thresholds in multi-update systems?",

    # II. Share Generation & Randomness (31–55)
    "Weak RNG Seeding: Can predictable RNG seeds allow attackers to precompute polynomial coefficients?",
    "RNG State Reuse: If the same RNG instance is reused, can correlations leak relationships between secrets?",
    "Coefficient Generation Bias: Does rng.gen() produce unbiased Fr elements?",
    "Zero Coefficient Probability: What is the impact if cs[0] or other coefficients are zero?",
    "Deterministic RNG Testing: Could deterministic test RNGs leak into production?",
    "Polynomial Degree Mismatch: Is degree t-1 correctly implemented?",
    "Coefficient Ordering: Does reversing coefficients alter the intended polynomial structure?",
    "Constant Polynomial for t=1: Does coefficient generation correctly produce a degree-0 polynomial?",
    "High-Degree Polynomial Instability: Does large t create interpolation instability?",
    "Coefficient Vector Memory: Are polynomial coefficients zeroized after share generation?",
    "Share Value Uniqueness: Can share collisions occur and affect recovery?",
    "Share Value Distribution: Do shares appear uniformly random or leak polynomial structure?",
    "Zero Share Detection: Does a zero share leak information about the polynomial?",
    "Share Value Correlation: Are share values truly independent?",
    "Small Share Values: Can unusually small shares be brute-forced?",
    "Index Offset-by-One: Is there an index mismatch between generation and recovery?",
    "Index Zero Handling: What happens if a share is assigned index 0?",
    "Index Overflow: Can saturating_add cause index collisions?",
    "Non-Sequential Index Support: share() creates sequential indices only - is this limiting or exploitable?",
    "Index Type Conversion: Does usize → u64 → Fr conversion risk overflow?",
    "Secret Entropy vs Coefficient Entropy: Does low-entropy secrets remain hidden?",
    "Coefficient Reuse Across Sharings: Can repeated share() calls leak correlations?",
    "Share Entropy Measurement: Do shares preserve full field entropy?",
    "Randomness Exhaustion: Can large n exhaust entropy sources?",
    "Entropy Source Validation: Is cryptographic RNG enforced or can attackers inject weak RNG?",

    # III. Recovery Logic & Interpolation (56–80)
    "Interpolation Numerical Stability: Can division-by-zero occur in Lagrange interpolation?",
    "Interpolation Point Selection: Why evaluate at zero, and can alternative points leak data?",
    "Duplicate Share Handling: Do duplicates break interpolation?",
    "Share Index Validation: Are indices validated before interpolation?",
    "Vanishing Polynomial Calculation: Can crafted shares break vanishing polynomial computation?",
    "Linear Combination Manipulation: Can t-1 shares produce partial leakage via interpolation math?",
    "Share Substitution: Are injected fake shares detected?",
    "Share Permutation Invariance: Is recovery invariant under share ordering?",
    "Partial Recovery Information: Does incorrect output leak partial information?",
    "Share Interpolation at Non-Zero Points: Can attackers compute polynomial values at other points?",
    "Share Authenticity: Does recover() verify share authenticity?",
    "Share Integrity: Can shares be tampered with undetected?",
    "Share Completeness: Can shares from different origins be mixed?",
    "Share Version Compatibility: Can future versions mix incompatible shares?",
    "Share Index Tampering: Can attackers alter index values?",
    "Empty Share List Handling: Should empty recovery be an error?",
    "Insufficient Share Silent Failure: Can wrong results bypass upstream checks?",
    "Recovery Error Information Leak: Do errors leak threshold or secret info?",
    "Repeated Recovery Attempts: Can attackers learn by differential attempts?",
    "Recovery Timing Variation: Does timing depend on share properties?",
    "Index Consistency Between Generation and Recovery: Is there an off-by-one?",
    "Zero Index Exploitation: What happens if index zero is accepted?",
    "Index Gap Handling: Do gaps (1,3,7) break interpolation?",
    "Index Overflow in Field Conversion: Can large indices misbehave?",
    "Negative Index Attack: Can wrapped-around indices manipulate interpolation?",

    # IV. Serialization & Encoding (81–100)
    "Share Serialization Format: Is the custom fr serializer canonical and non-malleable?",
    "Secret Serialization Security: Does serializing Secret leak metadata?",
    "Deserialization Validation: Are deserialized field elements checked for validity?",
    "Serialization Version Compatibility: Will old shares still decode after format changes?",
    "Serialization Side Channels: Can encode/decode timing leak secret info?",
    "Field Element Canonical Representation: Are Fr elements stored in reduced form?",
    "Field Element Padding: Does padding leak magnitude information?",
    "Out-of-Field Deserialization: Are >modulus values rejected?",
    "Deserialization Malleability: Can multiple encodings map to same share?",
    "Endianness Consistency: Is encoding cross-platform consistent?",
    "SEPARATOR Collision: Can Tagged separators collide?",
    "Separator Injection: Can separators be injected into serialized data?",
    "Version Prefix Enforcement: Is the v0: prefix validated?",
    "Tagged Trait Security: Does Tagged prevent type confusion?",
    "Separator Length Attacks: Can long separators cause DoS?",
    "Zeroization Timing: Does ZeroizeOnDrop run before page swap?",
    "Zeroization Bypass: Can compiler optimizations remove zeroization?",
    "Partial Zeroization: Is zeroization guaranteed during panics?",
    "Clone and Zeroization: Are cloned secrets zeroized independently?",
    "Move Semantics and Zeroization: Is old memory wiped after move?",

    # V. Integration with Backup System (101–125)
    "Share Distribution Security: Can plaintext shares leak during BackupCiphertextV0::new()?",
    "Guardian Shuffle Randomness: Can predictable shuffling leak mapping guardian→share?",
    "Share Index Assignment: Are indices 0..len() mismatched with SSS 1..=n expectations?",
    "Commitment Binding: Are share commitments binding and binding to the correct share?",
    "Share Encryption Key Derivation: If guardian keys are compromised, are multiple backups exposed?",
    "Share Decryption Timing: Can decryption timing leak share values?",
    "Share Verification in Recovery: Is verification before or after SSS, and can timing leak info?",
    "Threshold Enforcement in Backup System: Is threshold validation consistent with SSS?",
    "Share Truncation: Why limit shares to exactly threshold instead of using all?",
    "Secret to Key Derivation: Does kdfn() preserve entropy?",
    "Guardian Share Replay: Can guardians replay shares across attempts?",
    "Guardian Collusion Detection: Can colluding guardians detect insufficiency without revealing info?",
    "Guardian Share Verification: Are share values checked against commitments?",
    "Honest Guardian Assumption: What if exactly t guardians go offline?",
    "Guardian Key Compromise: Can compromised guardian keys retroactively expose shares?",
    "Share Reuse Across Backups: Can shares be correlated across backups?",
    "Multi-Backup Guardian Collusion: Do multi-backup colluding guardians gain more info?",
    "Backup Metadata Correlation: Can metadata reveal user patterns?",
    "Guardian Set Intersection: Can overlapping guardian sets leak info?",
    "Temporal Correlation: Can timing of share generation leak relationships?",
    "KDF Entropy Preservation: Does recovered secret produce strong keys?",
    "KDF Domain Separation: Is domain separation enforced?",
    "Recovered Secret Reuse: Are recovered secrets zeroized afterwards?",
    "Partial Recovery Exploitation: If key derivation fails, is secret wiped?",
    "Recovery State Machine: Is recovery only allowed in valid system states?",

    # VI. Cryptographic Soundness (126–145)
    "Field Order Security: Is the field large enough to resist brute-force?",
    "Additive Group Operations: Are all field ops done in the correct group?",
    "Field Element Reduction: Are elements always reduced modulo modulus?",
    "Zero Element Handling: Is zero a safe secret?",
    "Field Inversion Security: Are inversions constant-time?",
    "Polynomial Degree Leakage: Can share patterns leak t?",
    "Polynomial Coefficient Recovery: Can t-1 shares reveal more than allowed?",
    "Polynomial Evaluation Security: Does evaluation leak extra information?",
    "Degree-Reduction Attack: Can crafted shares reduce the effective threshold?",
    "Multi-Point Evaluation: Does evaluating polynomial at extra points weaken security?",
    "Perfect Secrecy for t-1 Shares: Is information-theoretic secrecy preserved?",
    "Computational Security Assumptions: Are any computational assumptions unsafe?",
    "Share Independence: Are shares independent as required?",
    "Entropy Leakage Through Operations: Do field operations leak through side channels?",
    "Statistical Independence: Are shares IID as required by proofs?",
    "Timing Side-Channels in Recovery: Is execution time constant?",
    "Cache Side-Channels: Can memory access patterns leak info?",
    "Power Analysis Resistance: Does hardware implementation leak via power?",
    "Branch-Timing Leakage: Do branches leak threshold or share properties?",
    "Constant-Time Operations: Is critical math constant-time?",

    # VII. Edge Cases & Error Conditions (146–150)
    "Maximum n Value: Can extremely large n cause overflow or memory exhaustion?",
    "Minimum Viable Parameters: Are insecure parameter combinations rejected?",
    "Field Size Boundary: Do large indices wrap around field modulus?",
    "Empty Guardian List: Does threshold=0 + no guardians produce a publicly recoverable backup?",
    "Concurrent Recovery Attempts: Can concurrent recoveries cause race conditions or inconsistent secrets?",

    # Category 1: Polynomial Evaluation Correctness (15 questions)
    "In the eval function, the polynomial is evaluated with 'most significant coefficient first.' poly.rs:3-8 If a caller mistakenly passes coefficients in reversed order (least significant first), could this result in reconstructing an incorrect secret in Shamir secret sharing, potentially allowing unauthorized account recovery or backup reconstruction?",
    "The eval function uses a fold operation starting from F::ZERO. poly.rs:6-8 If the iterator is empty, does returning zero break the security model when used in SSS recovery, potentially allowing trivial reconstruction without any shares?",
    "When eval is called with an iterator that gets exhausted mid-evaluation due to an implementation bug elsewhere, could partial polynomial evaluation lead to incorrect share generation in sss::share, compromising the threshold property?",
    "The eval function performs field arithmetic without checking for overflow or underflow in the accumulator. poly.rs:7 In finite field implementations, could repeated multiplication and addition operations lead to incorrect results that violate the 'only the owner can reconstruct backups' invariant?",
    "If a malicious off-chain node provides manipulated coefficients to eval during share generation, could the function silently produce shares that don't satisfy the threshold property, allowing reconstruction with fewer than t shares?",
    "The eval function accepts any Field type implementing the ark_ff::Field trait. Could using a field with insufficient security parameters (small modulus) allow an attacker to brute-force polynomial coefficients and reconstruct secrets without proper authorization?",
    "When evaluating a polynomial at x = F::ZERO in eval, does this reveal information about the constant term (secret) that could be exploited by a minority of corrupted guardians to bypass threshold security?",
    "If the iterator passed to eval contains duplicate coefficient values, could this reduce the effective degree of the polynomial, weakening the threshold security property in Shamir secret sharing?",
    "The fold operation in eval uses acc * x + coeff. poly.rs:7 Could the order of operations (multiplication before addition) create numerical precision issues in certain field implementations that lead to incorrect secret reconstruction?",
    "If eval is called with coefficients containing F::ZERO values in non-constant positions, does this reduce the effective degree of the polynomial below t-1, compromising the threshold security model?",
    "When eval is used in sss::share to generate shares at evaluation points 1..=n, sss.rs:44-46 could choosing consecutive integer evaluation points create algebraic relationships between shares that a malicious guardian could exploit?",
    "If the coefficient iterator in eval is cloned or reused multiple times, could iterator state corruption lead to generating multiple different shares for the same index, breaking SSS security?",
    "The eval function does not validate that the evaluation point x is non-zero. Could evaluating at x = 0 in share generation inadvertently reveal the secret (constant term) to unauthorized parties?",
    "If a corrupted off-chain node calls eval repeatedly with the same coefficients but different evaluation points to extract share patterns, could timing differences or computation patterns leak information about the polynomial structure?",
    "When eval processes coefficients in reverse order (most significant first), could an implementation error in the calling code that doesn't properly reverse coefficients result in evaluating a completely different polynomial, leading to irrecoverable secrets?",

    # Category 2: Vanishing Polynomial Security (15 questions)
    "The vanish function computes the product ∏(x - root) starting from F::ONE. poly.rs:11-13 If called with an empty iterator of roots, it returns F::ONE. Could this be exploited in Lagrange interpolation to create a trivial denominator that bypasses threshold security?",
    "When vanish is called with roots containing x itself, the result is zero. poly.rs:11-13 If this zero value is used in a denominator in lagrange, could it cause a division by zero panic that leads to denial of service during backup reconstruction?",
    "The vanish function iterates through roots and multiplies (x - root). If the iterator contains duplicate roots, does this change the multiplicity of zeros in a way that could break Lagrange interpolation correctness?",
    "If a malicious guardian provides a root set to vanish that includes very large field elements close to the field modulus, could overflow in the subtraction (x - root) lead to incorrect vanishing polynomial evaluation?",
    "When vanish is used in lagrange to compute both numerator and denominator, poly.rs:17-19 could providing carefully crafted root sets cause the numerator and denominator to have common factors, reducing the degree and violating interpolation uniqueness?",
    "The vanish function does not validate that all roots are distinct. Could duplicate roots in the input cause the Lagrange basis polynomial to be computed incorrectly, leading to wrong secret reconstruction?",
    "If vanish is called with roots that are all equal to F::ZERO, does this create a vanishing polynomial of the form x^n that could have unexpected properties when used in Lagrange interpolation?",
    "When vanish computes the product, could the order in which roots are processed affect the final result due to floating-point precision issues (even though we're in a finite field), or could iterator ordering affect side-channel timing?",
    "If an attacker can control the order of roots passed to vanish during VDRF evaluation, vdrf.rs:1-100 could they use timing side-channels to infer which roots are being used, leaking information about guardian participation?",
    "The vanish function evaluates at point x. Could evaluating at special field elements (like primitive roots of unity) create algebraic structures that a malicious minority of guardians could exploit to bypass threshold security?",
    "When vanish is used to compute the denominator in lagrange, if the denominator evaluates to zero (meaning px is in the roots), does this represent a catastrophic failure in the interpolation logic?",
    "If vanish is called with roots that are not in canonical form (e.g., different representations of the same field element), could this lead to incorrect equality checks and wrong polynomial evaluation?",
    "The fold operation in vanish starts with F::ONE and multiplies iteratively. Could accumulated rounding errors (even in exact finite field arithmetic) due to implementation details cause different results when the same computation is performed in different orders?",
    "If the root iterator passed to vanish is lazily evaluated and has side effects, could multiple evaluations of the same vanishing polynomial produce different results, breaking interpolation determinism?",
    "When vanish computes x - root, if x and root are equal but represented differently in memory (e.g., normalized vs. non-normalized forms), could the subtraction fail to produce exactly zero, causing incorrect Lagrange basis computation?",

    # Category 3: Lagrange Basis Vulnerabilities (25 questions)
    "The lagrange function divides zero / norm without checking if norm is zero. poly.rs:16-20 If px is included in the roots array, division by zero will panic. Could a malicious guardian inject px into the roots during backup reconstruction to cause a DoS?",
    "In lagrange, if roots is empty, both zero and norm would be F::ONE, returning 1. poly.rs:16-20 Could this trivial Lagrange basis be exploited in single-share reconstruction to bypass the threshold requirement?",
    "The lagrange function computes the vanishing polynomial at x and px. poly.rs:17-18 If an attacker can make x == px, the result would be 0/0 (undefined). Could this be triggered during reconstruction to cause protocol failure?",
    "When lagrange evaluates the vanishing polynomial, it clones the iterator twice. poly.rs:17-18 Could iterator cloning introduce subtle bugs where the two evaluations use different root sets, breaking Lagrange basis properties?",
    "If the roots slice contains duplicate values, does lagrange compute an incorrect basis polynomial that could allow unauthorized secret reconstruction with manipulated shares?",
    "The Lagrange basis should satisfy L_i(x_i) = 1 and L_i(x_j) = 0 for i ≠ j. If lagrange is called with roots that don't represent all other interpolation points, could this violate the basis property and corrupt secret reconstruction?",
    "When computing norm = vanish(roots.iter().cloned(), px), if px is very close to (but not equal to) one of the roots due to field element representation issues, could the denominator be very small, causing numerical instability?",
    "If lagrange is called with px being F::ZERO, and F::ZERO is also in roots, does this create a division by zero that could be exploited to DoS the reconstruction process?",
    "The lagrange function does not validate that px is distinct from all elements in roots. Could a programming error in the calling code lead to including px in roots, causing a panic during critical backup reconstruction?",
    "When lagrange computes the basis polynomial, could the order of roots in the slice affect the computation due to non-associativity of operations, leading to different results in different contexts?",
    "If an attacker can control the roots array passed to lagrange during VDRF evaluation, could they provide roots that create a malformed basis, leaking information about the VDRF secret key shares?",
    "The lagrange function performs field division, which is typically implemented as multiplication by the modular inverse. If the field implementation has bugs in the inversion algorithm, could this lead to incorrect Lagrange basis computation?",
    "When lagrange is used in interpolate_eval, the roots are filtered to exclude px. poly.rs:28 If the filter condition x != px fails due to representation issues, could this lead to division by zero?",
    "If lagrange is called with a very large roots array (approaching the guardian limit), could the repeated multiplication in the vanishing polynomial computation accumulate errors that violate interpolation correctness?",
    "The lagrange function does not check if all elements in roots are valid field elements. Could out-of-range values or improperly deserialized field elements cause incorrect basis computation?",
    "When computing the Lagrange basis at evaluation point x, if x is chosen to be a special value (like a root of unity), could this create algebraic relationships that a malicious guardian could exploit to learn information about other shares?",
    "If lagrange is used in a context where px represents a share index (1..n) and x represents the secret evaluation point (0), could evaluating at these specific points leak the polynomial degree information?",
    "The lagrange function returns a single field element. Could accumulated precision loss in the division operation (even in exact arithmetic) cause small errors that compound in interpolate_eval when summing multiple basis polynomials?",
    "If the roots slice is mutated by another thread while lagrange is executing (violating Rust's borrowing rules elsewhere), could this race condition lead to computing an incorrect Lagrange basis?",
    "When lagrange computes the vanishing polynomial at px, if px is extremely large or small in the field, could this cause the denominator to have special properties that weaken security?",
    "If lagrange is called with roots containing the additive identity (F::ZERO), and px is also zero, does this create a trivial denominator that breaks interpolation?",
    "The Lagrange basis computed by lagrange should be a rational function. Could the division operation introduce denominators that don't cancel properly, leading to incorrect interpolation results?",
    "When lagrange clones the iterator for vanish evaluation, if the iterator has side effects (e.g., logging, state updates), could this leak information about which guardians are participating in reconstruction?",
    "If an attacker provides roots where all elements are equal (but not equal to px), does lagrange produce a well-defined result, or could this degenerate case be exploited?",
    "The lagrange function computes (x - r_1)(x - r_2)...(x - r_n) / ((px - r_1)(px - r_2)...(px - r_n)). If the field characteristic is small, could overflow in the multiplications cause wrapping that produces incorrect basis polynomials?",

    # Category 4: Interpolation Attack Vectors (30 questions)
    "The interpolate_eval function asserts that points is non-empty but does not validate minimum threshold. poly.rs:24-31 If called with fewer than t points in Shamir secret sharing, could it still produce a result that appears valid but is actually incorrect, allowing unauthorized reconstruction?",
    "In interpolate_eval, the xs vector is collected from all points, then filtered for each Lagrange basis. poly.rs:26-28 Could a malicious guardian provide duplicate x-coordinates in the points to manipulate the interpolation result?",
    "The interpolate_eval function does not check if all x-coordinates in points are distinct. If duplicate x-coordinates are provided with different y-values, does this create an over-determined system that could leak information or produce incorrect results?",
    "When interpolate_eval filters roots as xs.iter().cloned().filter(|&x| x != px), if the comparison fails due to field element representation differences, could px remain in roots, causing division by zero in lagrange? poly.rs:28",
    "The interpolate_eval function evaluates the interpolating polynomial at point x. If a malicious party can choose x to equal one of the points' x-coordinates, does the interpolation correctly return the corresponding y-value, or could implementation details cause errors?",
    "In interpolate_eval, the fold accumulates eval + py * lagrange(...). poly.rs:27-30 Could accumulated rounding errors in the field arithmetic cause the final result to differ from the true polynomial evaluation, compromising secret reconstruction?",
    "When interpolate_eval is used in sss::recover to reconstruct secrets, sss.rs:51-63 if the share indices are manipulated (e.g., using saturating_add), could this lead to reconstructing a different polynomial than intended?",
    "The interpolate_eval function creates a new roots vector for each point in the fold. poly.rs:28 Could this O(n²) complexity be exploited by a malicious guardian providing a large number of shares to cause DoS during reconstruction?",
    "If interpolate_eval is called with points where some y-values are zero, does this reduce the effective degree of the polynomial in a way that could weaken threshold security?",
    "When interpolate_eval processes points, if an attacker can inject points with y-values that are multiples of each other, could this create linear dependencies that reveal information about the underlying secret?",
    "The interpolate_eval function assumes all points lie on a unique polynomial of degree < n. If more than n points are provided, does the function still produce a result, and if so, is it correct according to polynomial interpolation theory?",
    "In interpolate_eval, if the x-coordinates span a very large range in the field, could this cause numerical issues in the vanishing polynomial computation that lead to incorrect interpolation?",
    "When interpolate_eval is used to reconstruct a secret at x = F::ZERO, sss.rs:62 could evaluating at this special point leak information about the polynomial structure to observing adversaries?",
    "If interpolate_eval is called with points where all x-coordinates are consecutive integers (1, 2, 3, ...), could this regular structure be exploited by a malicious guardian to compute additional shares without authorization?",
    "The interpolate_eval function does not validate that the degree of the interpolating polynomial is exactly points.len() - 1. Could this allow reconstruction with fewer points than the threshold by carefully choosing point coordinates?",
    "When interpolate_eval constructs the xs vector, if memory allocation fails (in an out-of-memory scenario), could partial vector construction lead to incorrect interpolation that violates the 'only owner can reconstruct' invariant?",
    "If interpolate_eval is called with points containing the same x-coordinate but different y-coordinates, the mathematical system is inconsistent. Does the function detect this or silently produce an incorrect result?",
    "In the fold operation of interpolate_eval, each iteration computes a Lagrange basis and multiplies by py. Could the order of processing points affect the final result due to non-commutativity of operations?",
    "When interpolate_eval is used in association reconstruction, v0.rs:1-628 if a malicious off-chain node provides manipulated share data, could the interpolation still succeed but reconstruct an incorrect recovery key?",
    "The interpolate_eval function evaluates at a single point x. If multiple evaluations are needed (e.g., for verification), could repeated calls with different x values leak information about the polynomial coefficients through timing or computational patterns?",
    "If interpolate_eval is called with points where some y-values are the multiplicative identity (F::ONE), could this create special algebraic relationships that a malicious guardian could exploit?",
    "When interpolate_eval filters to create roots, the filter predicate is |&x| x != px. If this comparison is not constant-time, could a timing side-channel leak information about which shares are being used in reconstruction?",
    "If interpolate_eval is used to evaluate a polynomial at multiple points sequentially, could caching or memoization of intermediate results in the calling code introduce bugs that violate interpolation correctness?",
    "The interpolate_eval function performs Lagrange interpolation, which is mathematically equivalent to solving a Vandermonde system. Could numerical stability issues in the field arithmetic cause the interpolation to fail for certain point configurations?",
    "When interpolate_eval is called with points representing guardian shares in backup reconstruction, if one guardian provides a corrupted share (below threshold), does the function fail gracefully or produce an incorrect result that appears valid?",
    "If interpolate_eval is called with the maximum possible number of points (equal to the field characteristic), could overflow or wraparound in the Lagrange basis computation cause incorrect results?",
    "The interpolate_eval function does not verify that the points actually lie on a polynomial of the expected degree. Could a malicious guardian inject inconsistent points to cause reconstruction to fail or produce incorrect results?",
    "When interpolate_eval collects xs into a vector, if the iterator is corrupted or produces duplicate values, could this lead to incorrect root filtering and division by zero in Lagrange basis computation?",
    "If interpolate_eval is used in a multi-threaded context where different threads reconstruct different secrets, could shared state in the field arithmetic implementation cause race conditions that corrupt interpolation results?",
    "The interpolate_eval function evaluates the polynomial at x by summing Lagrange basis polynomials. Could the order of summation (due to iterator ordering) affect the result in a way that violates mathematical correctness?",

    # Category 5: Input Validation & Edge Cases (20 questions)
    "The interpolate_eval function only asserts that points is non-empty. poly.rs:25 Could calling with a single point (insufficient for any meaningful threshold) allow trivial reconstruction that bypasses guardian approval requirements?",
    "None of the functions in poly.rs validate that field elements are in their canonical form. Could non-canonical representations cause equality checks to fail, leading to incorrect polynomial operations?",
    "The functions accept generic field types via the Field trait. Could using a field with weak cryptographic properties (e.g., small characteristic) allow an attacker to break the threshold security model?",
    "If a caller passes an infinite iterator to eval or vanish, could the function hang indefinitely, causing DoS during critical backup reconstruction?",
    "None of the functions check for the additive or multiplicative identity in their inputs. Could special field elements (zero, one) in unexpected positions create degenerate cases that violate security properties?",
    "The interpolate_eval function does not limit the number of points that can be provided. Could an attacker provide an extremely large point set to cause memory exhaustion when collecting xs?",
    "If negative values are used as field elements (in fields supporting negative representation), could sign handling bugs in arithmetic operations cause incorrect polynomial evaluation?",
    "None of the functions validate that the field characteristic is prime. Could using a composite field allow an attacker to exploit subfield structures to bypass threshold security?",
    "The functions do not check if the field order is sufficient for the security level. Could using a small field (e.g., F_p with small p) allow brute-force attacks on the polynomial coefficients?",
    "If the iterator passed to eval or vanish produces values that are not valid field elements (e.g., from unsafe deserialization), could this cause undefined behavior or security violations?",
    "The lagrange function accepts a slice of roots but doesn't validate its length. Could an empty slice cause unexpected behavior when used in interpolation?",
    "If field elements are represented in Montgomery form or other optimized representations, could conversion bugs between representations cause incorrect polynomial operations?",
    "None of the functions perform bounds checking on field element magnitudes. Could extremely large or small values (near field boundaries) cause overflow or underflow in arithmetic operations?",
    "The functions assume that field operations (addition, multiplication, subtraction, division) are correctly implemented in the ark_ff library. If the library has bugs, could this compromise the security of secret reconstruction?",
    "If the field has a small characteristic and polynomials have high degree, could coefficient wrapping cause the degree to reduce unexpectedly, weakening threshold security?",
    "None of the functions validate that the x-coordinates in interpolation are within a valid range (e.g., 1..n for Shamir secret sharing). Could out-of-range coordinates cause incorrect reconstruction?",
    "If the points array in interpolate_eval is mutated during iteration (violating Rust's safety guarantees elsewhere), could this race condition lead to using inconsistent data for interpolation?",
    "The functions do not check if the field supports the required number of distinct evaluation points. Could insufficient field size limit the maximum number of shares, affecting availability?",
    "If field elements are serialized and deserialized between function calls, could serialization format inconsistencies cause different representations of the same value, breaking equality checks?",
    "None of the functions validate that the polynomial degree is appropriate for the security level. Could low-degree polynomials be exploited to bypass threshold requirements through algebraic attacks?",

    # Category 6: Field Arithmetic & Mathematical Properties (15 questions)
    "The field arithmetic operations in poly.rs rely on the ark_ff::Field trait. If the field has characteristic 2, could XOR-based arithmetic create unexpected behaviors in polynomial evaluation?",
    "When dividing in lagrange, the function computes zero / norm. poly.rs:19 If the field implementation uses extended Euclidean algorithm for inversion, could timing variations leak information about the denominator's structure?",
    "In finite fields, a * b = 0 does not imply a = 0 or b = 0 if the field is not an integral domain. Could this cause the vanishing polynomial to be zero at non-root points, breaking interpolation correctness?",
    "The polynomial evaluation uses Horner's method implicitly in eval. poly.rs:7 Could this method accumulate errors differently than other evaluation methods, causing inconsistencies in different parts of the codebase?",
    "If the field is an extension field (e.g., F_p^2), could the polynomial operations inadvertently leak information about the field extension structure that helps an attacker?",
    "The Lagrange interpolation assumes the field has sufficient multiplicative subgroups. If the field structure is special (e.g., has small subgroups), could this enable attacks on the threshold property?",
    "When computing x - root in vanish, if both are at field boundaries, could modular reduction create unexpected results that violate vanishing polynomial properties?",
    "The field inverse operation in division could fail if the divisor is zero, causing a panic. Are there any code paths where this panic could be triggered by malicious input during reconstruction?",
    "If the field uses lazy reduction (computing modulo only when necessary), could intermediate values grow large enough to cause overflow before reduction, corrupting results?",
    "The polynomial operations assume associativity and commutativity of field operations. If the field implementation has bugs violating these properties, could this cause non-deterministic behavior in interpolation?",
    "When multiplying many field elements in vanish, could the product approach zero due to field structure, even though individual factors are non-zero, causing numerical issues?",
    "If the field has roots of unity with special properties, could evaluating polynomials at these roots create exploitable patterns in the shares?",
    "The Lagrange basis computation requires computing products of many field elements. Could accumulated floating-point errors (even in exact arithmetic) from repeated operations cause result corruption?",
    "If the field modulus is not prime but a prime power, could the polynomial operations have unexpected behaviors in the presence of zero divisors?",
    "When summing Lagrange basis polynomials in interpolate_eval, could the order of addition affect the final result if the field operations are not truly associative due to implementation bugs?",

    # Category 7: Side-Channel & Timing Attacks (10 questions)
    "The eval function iterates through coefficients and performs multiplications and additions. Could the number of iterations leak information about the polynomial degree, revealing the threshold t?",
    "In vanish, the fold operation performs a different number of iterations depending on the number of roots. Could timing this operation reveal how many guardians are participating in reconstruction?",
    "The lagrange function performs field division, which typically uses modular inversion. Could timing variations in the inversion algorithm leak information about the denominator value?",
    "When interpolate_eval filters roots, the filter predicate compares field elements. If comparison is not constant-time, could timing reveal which x-coordinates are being used in interpolation?",
    "The interpolate_eval function performs a different number of Lagrange basis computations depending on points.len(). Could timing this reveal the number of shares being used, leaking information about guardian participation?",
    "If field multiplication in eval and vanish is not constant-time, could power analysis or timing attacks recover polynomial coefficients or roots?",
    "The fold operations process iterators sequentially. Could memory access patterns during iteration create cache-timing side-channels that leak information about input values?",
    "When lagrange computes two vanishing polynomials at different points, could differential timing analysis reveal information about the relationship between x and px?",
    "If the field arithmetic implementation uses lookup tables for certain operations, could cache-timing attacks on these lookups reveal share values during reconstruction?",
    "The interpolate_eval function performs multiple Lagrange basis computations. Could measuring total execution time reveal information about the point coordinates or y-values being interpolated?",

    # Category 8: Integration with SSS/VDRF/Recovery (20 questions)
    "In sss::share, polynomial evaluation points are chosen as 1..=n. sss.rs:44-46 Could this predictable choice allow a malicious guardian to pre-compute attack patterns before participating in the protocol?",
    "The sss::recover function uses saturating_add(1) when converting share indices. sss.rs:60 Could integer overflow in share indexing cause incorrect x-coordinates in interpolate_eval, reconstructing the wrong secret?",
    "When sss::recover calls interpolate_eval at F::ZERO, sss.rs:62 could malicious shares be crafted such that interpolation at zero produces an attacker-controlled value instead of the original secret?",
    "The SSS implementation generates t random coefficients where cs[0] is the secret. sss.rs:43-47 If eval is called with coefficients in the wrong order, could the wrong coefficient be used as the secret, leaking the actual secret through shares?",
    "In VDRF evaluation using poly::lagrange, vdrf.rs:1-100 could a malicious minority of off-chain nodes provide manipulated Lagrange coefficients that still pass verification but produce an incorrect VDRF output?",
    "When backup reconstruction uses sss::recover, which relies on interpolate_eval, if fewer than threshold shares are provided, does the system properly reject reconstruction, or could it produce an incorrect secret that appears valid?",
    "In association recovery using interpolate_eval, v0.rs:1-628 if a corrupted off-chain node provides shares with manipulated x-coordinates, could this cause reconstruction of a different recovery key than intended?",
    "The SSS implementation evaluates the polynomial at points 1, 2, 3, .... Could this sequential pattern be exploited by a malicious guardian who observes multiple reconstruction sessions to learn the underlying polynomial?",
    "When interpolate_eval is used in recovery, if the same set of shares is used multiple times with different evaluation points, could this leak information about the polynomial structure?",
    "In VDRF combine operations, if the Lagrange coefficients computed by lagrange are not validated, could a malicious off-chain node provide coefficients that reconstruct an incorrect VDRF evaluation?",
    "The sss::share function generates shares using eval with reversed coefficients. sss.rs:45 Could confusion about coefficient ordering between share generation and recovery lead to reconstructing incorrect secrets?",
    "When multiple secrets are shared and recovered in parallel, could interference between polynomial evaluations (through shared state or caches) cause one reconstruction to affect another?",
    "If the threshold t is set to zero, sss::share returns a zero secret and empty shares. sss.rs:37-40 Could this degenerate case be exploited to create 'backups' that are trivially recoverable, bypassing guardian requirements?",
    "In backup ciphertext recovery, shares are collected from guardians and fed to interpolate_eval. If a malicious guardian provides shares for a different backup, could the interpolation still succeed but decrypt the wrong data?",
    "The polynomial functions don't verify that share indices correspond to the expected guardian identities. Could an attacker use shares from different backups with the same indices to forge reconstruction?",
    "When interpolate_eval is used in account recovery, if the email-to-account association uses VDRF with Lagrange interpolation, could a malicious minority of nodes manipulate the association to link incorrect emails to accounts?",
    "If polynomial evaluation is used in zero-knowledge proofs or commitments elsewhere in the system, could incorrect evaluation in poly.rs cause proof verification to pass for invalid statements?",
    "When shares are transmitted between nodes and stored before reconstruction, could serialization/deserialization of field elements cause subtle changes that make interpolation fail or produce incorrect results?",
    "If the backup system stores encrypted shares, and the encryption key is derived from polynomial evaluation, could incorrect evaluation in poly.rs cause the wrong key to be derived, making backups permanently irrecoverable?",
    "In the threshold security model, if exactly t shares are provided to interpolate_eval, could numerical precision issues cause the reconstruction to occasionally fail, violating the availability guarantee that 'at least t honest guardians' ensure recovery?",

    # Category 1: Key Generation & Distribution (15 questions)
    "In VdrfSecretKey::gen() vdrf.rs:92-97 , the function generates random coefficients using rng.gen(). Can an attacker exploit weak randomness from a compromised RNG to predict the secret polynomial and break the VDRF's privacy guarantees for email-to-account associations?",
    "The threshold parameter t in VdrfSecretKey::gen() vdrf.rs:92-97 determines the polynomial degree. Can a malicious caller pass t=0 or t=1 to create a trivially reconstructable secret key, violating the security invariant that requires threshold honest nodes?",
    "In VdrfSecretKey::gen() vdrf.rs:92-97 , there is no upper bound check on threshold t. Can an attacker provide an extremely large t value to cause resource exhaustion during key generation or later operations?",
    "The deal() function vdrf.rs:100-103 evaluates the polynomial at node_id.eval_point(). If two different NodeId values hash to the same evaluation point (collision), could this allow share replay attacks across different nodes?",
    "In VdrfSecretKey::deal() vdrf.rs:100-103 , the function calls node_id.eval_point() which hashes the NodeId vdrf.rs:16-22 . Can a malicious node controller craft a NodeId that produces a zero eval_point despite the assertion, potentially through integer overflow in subsequent operations?",
    "The share() function vdrf.rs:106-116 uses Horner's method for polynomial evaluation. Can rounding errors or field arithmetic overflow cause share values to differ from expected results, breaking threshold reconstruction?",
    "In VdrfSecretKey::public_key() vdrf.rs:119-128 , commitments are computed as generator * coefficient. Can the conversion from G1Projective to G1Affine fail or produce the point at infinity for certain coefficients, breaking verification?",
    "The VdrfPublicKey struct vdrf.rs:26-33 stores c0 and ci separately. If an attacker can craft mismatched lengths between these fields during deserialization, can they cause a mismatch between the claimed threshold and actual commitment count?",
    "In VdrfPublicKey::threshold() vdrf.rs:36-38 , the threshold is computed as self.ci.len() + 1. Can an attacker provide an empty ci vector to create a threshold-1 system where only c0 is required, bypassing threshold security?",
    "The VdrfSecretKey structure vdrf.rs:56-63 stores polynomial coefficients in 'most significant first' order. Can coefficient order confusion between key generation and evaluation lead to different shares being computed than expected?",
    "In deal() vdrf.rs:100-103 , shares are dealt to nodes identified by NodeId. Can an attacker register multiple NodeIds that evaluate to evaluation points forming a malicious subset, allowing easier threshold bypass?",
    "The VdrfSecretKeyShare vdrf.rs:42-43 is a simple wrapper around a field element. Can an attacker forge a valid-looking share by directly constructing this struct with an arbitrary field element, bypassing proper dealing?",
    "In share() vdrf.rs:106-116 , the function evaluates f(xi) = c0 + xi * (c1 + xi * (c2 + ...)). Can numerical instability in field operations for very large or very small xi values lead to incorrect share values?",
    "The public key generation vdrf.rs:119-128 commits each coefficient independently. Can a malicious key generator create commitments that don't correspond to a valid polynomial, breaking the binding property?",
    "In VdrfSecretKey::gen() vdrf.rs:92-97 , the function generates t coefficients total (c0 plus t-1 others). Is the degree of this polynomial t-1 or t? Can confusion about polynomial degree lead to threshold mismatch between key generation and reconstruction?",

    # Category 2: Polynomial Evaluation & Horner's Method (20 questions)
    "In share() vdrf.rs:113-115 , Horner's method is implemented as fold(zero, |acc, c| xi * acc + c). Can the order of operations cause precision issues or allow timing attacks to leak information about coefficients?",
    "The polynomial evaluation in share() vdrf.rs:113-115 processes coefficients in most-significant-first order. Can reversing this order (either accidentally or maliciously) lead to completely different share values that still appear valid?",
    "In compute_commitment_at_point() vdrf.rs:249-255 , the function evaluates the commitment polynomial using the same Horner pattern. Can inconsistencies between this function and share() allow invalid shares to pass verification?",
    "The compute_commitment_at_point() function vdrf.rs:249-255 multiplies group elements by field elements. Can point addition operations fail or produce unexpected results for edge cases like the identity element?",
    "In share() vdrf.rs:114-115 , the final result is xi * result + c0. Can the multiplication xi * result overflow or wrap around the field modulus in a way that compromises share security?",
    "The polynomial evaluation uses fold() iterator operations vdrf.rs:114 . Can the iterator be empty, causing fold to return zero incorrectly, or can iterator ordering be manipulated?",
    "In compute_commitment_at_point() vdrf.rs:251-253 , the function uses G1Projective::zero() as the initial accumulator. Can this lead to incorrect results if the polynomial's highest degree coefficient commitment is the identity element?",
    "The evaluation in share() vdrf.rs:114 assumes the ci vector contains exactly t-1 elements. Can a mismatch between vector length and expected threshold cause out-of-bounds access or incorrect evaluation?",
    "In compute_commitment_at_point() vdrf.rs:251-254 , the final step is (result * x + c0).into(). Can the conversion to affine coordinates fail for certain projective points, causing panics or incorrect results?",
    "The polynomial evaluation in share() processes coefficients from most significant to least vdrf.rs:114 . Can an attacker craft a polynomial where this ordering reveals information about the secret through timing or power analysis?",
    "In NodeId::eval_point() vdrf.rs:16-22 , the function uses from_le_bytes_mod_order to convert hash output to a field element. Can this deterministic conversion create bias in the evaluation point distribution, making some points more likely than others?",
    "The assertion assert_ne!(x, pp::Fr::zero()) in eval_point() vdrf.rs:20 claims finding zero requires ~2^256 operations. Is this estimate accurate given that from_le_bytes_mod_order may reduce modulo a smaller field order?",
    "In share() vdrf.rs:113-115 , the polynomial is evaluated at point xi. Can an attacker choose or manipulate xi values during dealing to create shares that leak information about the polynomial coefficients?",
    "The Horner's method implementation in both share() vdrf.rs:114 and compute_commitment_at_point() vdrf.rs:251-253 uses multiplication by x. Can consecutive multiplications lead to exponential growth in intermediate values that cause timing variations?",
    "In share(), the function explicitly checks for zero evaluation points vdrf.rs:107-111 . Can an attacker bypass this check by providing a field element that becomes zero after certain operations but passes the initial check?",
    "The polynomial evaluation in compute_commitment_at_point() vdrf.rs:251-253 operates on group elements rather than field elements. Can different group operation implementations between nodes cause consensus failures in share verification?",
    "In share() vdrf.rs:114 , the fold operation accumulates intermediate results. Can attackers observe these intermediate values through side channels (cache, timing) to reconstruct polynomial coefficients?",
    "The share() function wraps the final result in VdrfSecretKeyShare vdrf.rs:115 . Can this wrapping step fail or be manipulated during serialization to produce shares that appear valid but aren't?",
    "In both evaluation functions, the result depends on the order of coefficients in the vectors vdrf.rs:114 and vdrf.rs:251-253 . Can vector reordering attacks during serialization cause shares and commitments to be computed for different polynomials?",
    "The polynomial degree determines the threshold security. If ci has length t-1 but the actual polynomial has a different degree due to zero coefficients, can this reduce the effective threshold below t?",

    # Category 3: Partial Evaluation Security (20 questions)
    "In Vdrf::partial_eval() vdrf.rs:133-146 , the function hashes to G2 using VdrfKPoint containing public_key.c0 and the hashed input vdrf.rs:139-142 . Can an attacker craft two different inputs that hash to the same G2 point, breaking VDRF uniqueness for email bindings?",
    "The VdrfKPoint struct used in partial_eval() vdrf.rs:66-70 includes both c0 and input. Can omitting either field from the hash allow cross-key or cross-input attacks where evaluations can be reused?",
    "In partial_eval() vdrf.rs:139-142 , the input is first hashed via hash(input) before being included in VdrfKPoint. Can this double-hashing pattern create collisions or reduce entropy?",
    "The partial_eval() function vdrf.rs:145 multiplies the G2 point by secret_share.0. Can a corrupted node provide a share that's a scalar multiple of the correct share, passing verification but breaking reconstruction?",
    "In partial_eval() vdrf.rs:133-137 , the function signature uses a generic T: Tagged for the input. Can type confusion attacks allow an attacker to provide different types that serialize to the same bytes but have different semantic meanings?",
    "The VdrfKPoint struct implements Tagged with separator 'v0:vdrf-input' vdrf.rs:79-81 . Can an attacker craft inputs that when encoded produce the same bytes as valid VdrfKPoint instances, bypassing domain separation?",
    "In partial_eval() vdrf.rs:139 , the function calls pp::hash_to_g2(). Can the hash-to-curve implementation have non-uniform distribution, making some outputs more likely and reducing VDRF security?",
    "The partial evaluation returns VdrfEvaluationShare vdrf.rs:145 which is a G2 element. Can an attacker substitute this with a different valid G2 point that still passes group membership checks but represents a different evaluation?",
    "In partial_eval() vdrf.rs:145 , the function converts from G2Projective to G2Affine using .into(). Can this conversion fail for edge cases like the point at infinity, or can it introduce malleability?",
    "The partial_eval() function vdrf.rs:133-146 doesn't verify that secret_share corresponds to the provided public_key. Can a corrupted node use a share from a different VDRF instance to create evaluations that look valid but aren't?",
    "In partial_eval() vdrf.rs:139-142 , the hash input includes public_key.c0. Can two different public keys with the same c0 but different ci coefficients produce identical partial evaluations?",
    "The VdrfEvaluationShare struct vdrf.rs:50-53 has no additional metadata beyond the G2 point. Can shares from different inputs, nodes, or VDRF instances be mixed together in the combination phase?",
    "In partial_eval() vdrf.rs:133-137 , there's no check that the public_key matches the secret_share. Can an attacker provide a mismatched pair to generate evaluations that fail verification later, causing denial of service?",
    "The generic parameter T: Tagged in partial_eval() vdrf.rs:133-137 allows any tagged type. Can this flexibility allow cross-protocol attacks where VDRF evaluations from one context (e.g., email binding) are reused in another?",
    "In partial_eval() vdrf.rs:139 , the conversion pp::G2Projective::from(pp::hash_to_g2(...)) may involve point operations. Can this introduce non-determinism or rounding errors that cause different nodes to compute different results?",
    "The partial_eval() function vdrf.rs:145 performs scalar multiplication pnt * secret_share.0. Can this operation leak information about the secret share through timing, power, or cache side channels?",
    "In partial_eval() vdrf.rs:141 , the hash(input) function is called on the Tagged input. Can this hash function have weaknesses that allow preimage or second-preimage attacks on email addresses?",
    "The VdrfKPoint includes c0 from the public key vdrf.rs:139-142 . If c0 is the identity element, can this reduce the hash-to-curve output space and create collisions?",
    "In partial_eval() vdrf.rs:133-146 , there's no verification that the input hasn't been used before. Can replay attacks using old inputs allow an attacker to generate multiple email bindings for the same account?",
    "The partial evaluation result vdrf.rs:145 is deterministic for a given input and share. Can this determinism be exploited to track user activities across different sessions or contexts?",

    # Category 4: Share Combination & Lagrange Interpolation (25 questions)
    "In Vdrf::combine() vdrf.rs:149-205 , the function accepts a slice of (NodeId, VdrfEvaluationShare) pairs. Can an attacker provide duplicate NodeIds with different shares to manipulate which shares are used in reconstruction?",
    "The combine() function vdrf.rs:161-167 filters duplicates using uniq_shares.contains_key(&xi). Can an attacker exploit the iteration order to ensure their malicious share is selected first when there are duplicates?",
    "In combine() vdrf.rs:170-177 , share verification uses a pairing check e(G1, eval_i) * e(-E_i, K) = 1. Can an attacker craft evaluation shares that pass this check but don't correspond to valid polynomial evaluations?",
    "The pairing verification in combine() vdrf.rs:170-176 uses compute_commitment_at_point() vdrf.rs:173 . Can mismatches between the commitment computation and share computation allow invalid shares to pass verification?",
    "In combine() vdrf.rs:178-180 , the function breaks early once it has exactly threshold valid shares. Can an attacker provide threshold malicious shares first, then honest shares, to force acceptance of the malicious set?",
    "The combine() function vdrf.rs:185-187 checks if exactly threshold shares were collected. Can an attacker provide threshold-1 valid shares plus invalid shares to trigger the insufficient shares error, causing denial of service?",
    "In combine() vdrf.rs:155-158 , the hash-to-curve operation is repeated. Can computing this outside the loop and reusing the result introduce vulnerabilities, or is recomputation necessary for security?",
    "The Lagrange interpolation in combine() vdrf.rs:192-201 evaluates at point zero vdrf.rs:199 . Can this special evaluation point create edge cases or degeneracies in the interpolation formula?",
    "In combine() vdrf.rs:196-200 , the Lagrange coefficient is computed using poly::lagrange(). Can numerical errors in this computation cause the final result to differ from the expected VDRF evaluation?",
    "The combine() function vdrf.rs:192-202 sums weighted evaluation shares. Can the summation order affect the final result due to rounding, or can an attacker exploit associativity to manipulate outcomes?",
    "In combine() vdrf.rs:197-198 , the roots are filtered to exclude xi itself. Can an empty filter result (if all xs are identical despite uniqueness checks) cause division by zero in Lagrange computation?",
    "The pairing check in combine() vdrf.rs:170-176 uses negation on the second G2 element. Can sign flips or negation errors in the pairing library cause valid shares to be rejected or invalid shares to be accepted?",
    "In combine() vdrf.rs:161-182 , the function uses a HashMap for deduplication. Can hash collisions in the HashMap implementation allow two different evaluation points to be treated as identical?",
    "The combine() function vdrf.rs:190-191 converts the deduplicated shares to a vector. Can the ordering of this vector affect Lagrange interpolation results due to numerical precision issues?",
    "In combine() vdrf.rs:194-201 , evaluation shares are multiplied by Lagrange coefficients. Can overflow in this multiplication produce incorrect results that still pass as valid G2 points?",
    "The combine() function accepts a const generic N vdrf.rs:149-153 for output size but doesn't use it directly. Can mismatches between this parameter and later verification in verify() cause issues?",
    "In combine() vdrf.rs:163 , the function calls id.eval_point() for each share. Can expensive hash computations in this function be exploited for denial of service by providing many NodeIds?",
    "The pairing verification vdrf.rs:170-176 computes check_pairing for each share individually. Can batching these verifications introduce vulnerabilities, or is individual verification necessary?",
    "In combine() vdrf.rs:204 , the final result is converted to affine using .into(). Can this conversion fail or introduce malleability for certain projective coordinates?",
    "The combine() function vdrf.rs:178-180 uses early termination once threshold is reached. Can an attacker exploit this by ordering inputs so that invalid shares are never checked?",
    "In combine() vdrf.rs:194-201 , the Lagrange interpolation evaluates at zero. Can malicious shares that evaluate correctly at zero but incorrectly at other points pass verification but produce wrong results?",
    "The poly::lagrange() function called in combine() vdrf.rs:196-200 computes a fraction. Can zero denominators occur if evaluation points aren't properly validated, causing panics?",
    "In combine() vdrf.rs:192-202 , the sum uses .sum() on an iterator of G2 projective points. Can the identity element being included or excluded affect whether this produces the expected result?",
    "The combine() function vdrf.rs:165 checks uniq_shares.contains_key(&xi) before inserting. Can race conditions in concurrent calls to combine() cause share substitution, or is this function expected to be called sequentially?",
    "In combine() vdrf.rs:191 , the xs vector is created by extracting keys from the HashMap. Can the non-deterministic ordering of HashMap iteration cause different results across invocations?",

    # Category 5: Verification & Pairing Operations (20 questions)
    "In Vdrf::verify() vdrf.rs:208-246 , the pairing check verifies e(G1, evaluation) = e(C_0, pnt). Can an attacker provide an evaluation that satisfies this equation but wasn't derived from the correct VDRF evaluation process?",
    "The verify() function vdrf.rs:225-229 uses check_pairing with negation on the second G2 element. Can implementation bugs in pairing negation cause incorrect verification results?",
    "In verify() vdrf.rs:214 , the input is hashed before being used in pairing. Can an attacker provide two inputs with the same hash but different semantics to reuse VDRF evaluations across different emails?",
    "The verify() function vdrf.rs:234-237 , serializes the evaluation using serialize_compressed. Can the serialization produce different byte representations for equivalent G2 points, causing KDF output variations?",
    "In verify() vdrf.rs:239-245 , the KDF uses both the serialized evaluation and a VdrfOutputInfo struct. Can omitting either component from the KDF allow cross-context attacks?",
    "The VdrfOutputInfo struct vdrf.rs:72-77 includes c0 and input. Can a malicious public key with a specially crafted c0 cause KDF collisions across different VDRF instances?",
    "In verify() vdrf.rs:217-220 , VdrfKPoint and VdrfOutputInfo are separate structs with the same fields. Can mixing these types during hashing or KDF cause domain separation failures?",
    "The verify() function vdrf.rs:225-229 returns an error if pairing fails, but doesn't log which input failed. Can this allow an attacker to slowly grind for valid-looking evaluations without detection?",
    "In verify() vdrf.rs:234-237 , serialization errors are mapped to VdrfEvaluationVerificationFailed. Can this generic error hide underlying issues like malformed G2 points?",
    "The pairing check in verify() vdrf.rs:225-228 uses generator, c0, evaluation, and -pnt. Can any of these being the identity element cause the check to pass incorrectly?",
    "In verify() vdrf.rs:217-219 , the point K is computed using hash_to_g2 with VdrfKPoint. Can weaknesses in the hash-to-curve implementation allow finding collisions or preimages?",
    "The verify() function vdrf.rs:239-245 calls kdfn to derive the final output. Can weak KDF parameters or implementation allow rainbow table attacks on VDRF outputs?",
    "In verify() vdrf.rs:208-212 , the function accepts a generic T: Tagged input and const generic N for output size. Can mismatches between caller expectations and actual parameters cause security issues?",
    "The pairing verification vdrf.rs:225-228 compares the result to the identity element. Can bugs in the pairing library's identity comparison allow non-identity results to pass?",
    "In verify() vdrf.rs:234-237 , the evaluation is serialized before being passed to KDF. Can this serialization step fail silently for edge cases, producing incorrect KDF inputs?",
    "The verify() function vdrf.rs:217-220 recomputes the hash-to-curve that was done in combine(). Can inconsistencies between these computations allow verification to pass for incorrect evaluations?",
    "In verify() vdrf.rs:226 , the function uses pp::G1Affine::generator(). Can a corrupted standard library or arkworks dependency return a non-standard generator, breaking all VDRF operations?",
    "The VdrfOutputInfo separator is 'v0:vdrf-output' vdrf.rs:83-85 . Can this separator collide with other protocol separators, allowing VDRF outputs to be reinterpreted in different contexts?",
    "In verify() vdrf.rs:239-245 , the KDF output length is parameterized by N. Can setting N to 0 or extremely large values cause issues with the KDF or downstream uses?",
    "The verify() function vdrf.rs:225-229 performs a pairing check that's cryptographically expensive. Can an attacker force many verification attempts to cause resource exhaustion?",

    # Category 6: Output Derivation & KDF (10 questions)
    "In verify() vdrf.rs:239-245 , the kdfn function is called with the serialized evaluation and VdrfOutputInfo. Can the KDF implementation have insufficient domain separation, allowing outputs from one context to be used in another?",
    "The KDF output in verify() vdrf.rs:239-245 depends on input and c0. Can two different evaluations with identical serialized forms cause collisions in output derivation?",
    "In verify() vdrf.rs:239-245 , kdfn derives output bytes directly. Can an attacker exploit structural weaknesses in KDF output to derive partial information about the underlying evaluation?",
    "The KDF step vdrf.rs:239-245 combines multiple inputs. Can changing the order or formatting of these inputs cause ambiguity or collisions?",
    "In verify() vdrf.rs:239-245 , the evaluation share is compressed for KDF. Can compression ambiguities or malleability in compressed G2 encoding alter the final output?",
    "The KDF output is used as final protocol output. Can insufficient entropy in evaluation shares allow brute-force attacks on the derived output?",
    "In verify() vdrf.rs:239-245 , domain separation relies on separators in VdrfOutputInfo. Can separator reuse across the codebase cause cross-protocol confusion?",
    "The KDF implementation may rely on underlying hash functions. Can weakened hash security cause the KDF to produce predictable or forgeable outputs?",
    "In verify() vdrf.rs:239-245 , missing validation on KDF output length could allow misuse in downstream protocols. Can attackers exploit variable-length outputs?",
    "The final KDF output is returned to callers. Can malicious callers use chosen-input attacks to derive relationships between evaluation outputs and recovered emails?",

    "NodeId Case Sensitivity: The NodeId::from_str() function checks if typ != \"node\", but does it enforce case sensitivity? Could an attacker bypass validation by submitting \"NODE:malicious-id\" or \"Node:malicious-id\" to create collision attacks on VDRF evaluation points?",
    "NodeId Empty String Handling: Can NodeId::from_str() accept an empty string after the colon (e.g., \"node:\")? If so, does this create a zero-length NodeId that could cause panics or undefined behavior when computing eval_point() via hashing?",
    "NodeId Hyphen Boundary Cases: The validation allows hyphens in NodeIds, but does it prevent leading/trailing hyphens (e.g., \"node:-malicious\" or \"node:malicious-\")? Could these create ambiguous NodeIds that collide after normalization?",
    "NodeId Maximum Length: Is there a maximum length enforced for NodeIds? Could an attacker submit extremely long NodeIds (e.g., 10MB) that pass validation but cause memory exhaustion when stored in HashMap<NodeId, ...> collections in VDRF operations?",
    "NodeId Unicode Normalization: The validation checks c.is_ascii_alphabetic(), but does it reject Unicode lookalikes or homoglyphs? Could an attacker use visually similar characters to impersonate legitimate node IDs in social engineering attacks?",
    "NodeId Consecutive Hyphens: Does the validation prevent multiple consecutive hyphens (e.g., \"node:valid--malicious\")? Could this create parsing ambiguities when NodeIds are concatenated or split?",
    "NodeId eval_point() Collision Risk: The eval_point() method uses Fr::from_le_bytes_mod_order() on a hash. Could an attacker deliberately search for NodeIds that produce the same field element, causing VDRF share collisions and breaking threshold security?",
    "NodeId Zero Point Assertion: The eval_point() method asserts that the hash cannot be zero, but this uses assert_ne! which panics in release builds. Should this return a SwafeError instead to prevent DoS attacks where malicious nodes force crashes?",
    "NodeId Deserialization Bypass: The NodeId struct derives Deserialize but also has from_str() validation. Could an attacker directly deserialize invalid NodeIds (e.g., via bincode) bypassing the FromStr validation, then use them in VDRF operations?",
    "NodeId Display/FromStr Roundtrip: Does Display::fmt() produce output that FromStr::from_str() can parse? If not, could this cause inconsistencies where a NodeId serializes to a string that cannot be deserialized back?",
    "NodeId Extra Colons: The validation checks parts.next().is_some() for extra parts, but does it handle multiple colons correctly (e.g., \"node:id:extra:parts\")? Could this bypass validation or create parsing ambiguities?",
    "NodeId Hash Collision with Account IDs: Are NodeIds and AccountIds hashed with different domain separators? Could an attacker craft a NodeId that produces the same hash as an AccountId, confusing authorization checks?",
    "NodeId Homograph Attack: Could two visually identical but byte-different NodeIds (after ASCII validation) exist in the system? For example, could normalization differences create collisions in databases or smart contract storage?",
    "NodeId as HashMap Key: NodeIds are used as HashMap keys in VDRF operations. Does the Hash implementation produce consistent results across serialization boundaries? Could hash collisions lead to wrong shares being retrieved?",
    "NodeId Clone Safety: The NodeId derives Clone, but it wraps a String. Could cloning a NodeId used in cryptographic operations lead to secret data being duplicated in memory without proper zeroization?",
    "NodeId Type Confusion: The from_str() validation only checks the prefix \"node\". Could an attacker submit other prefixed strings (e.g., \"account:id\") that get stored as NodeIds, causing type confusion in smart contract logic?",
    "NodeId Injection in Tagged Encoding: The Tagged trait uses \"v0:node-id\" as a separator. If a NodeId contains the substring \"v0:node-id\", could it break domain separation in cryptographic operations?",
    "NodeId PartialEq Consistency: The NodeId derives PartialEq over the wrapped String. Is string comparison correct for cryptographic identity? Should it compare normalized forms or hashes instead?",
    "NodeId AsRef Implementations: The NodeId implements AsRef<str> and AsRef<String>. Could these expose internal string data in a way that bypasses access controls or allows modification?",
    "NodeId Serialization Format Change: If the NodeId serialization format changes (e.g., from \"node:id\" to a different scheme), could old NodeIds become invalid, breaking existing VDRF shares and causing permanent account lockout?",
    "NodeId Prefix Validation Timing: The validation checks prefix equality with a simple != comparison. Could this introduce timing side-channels that leak information about valid NodeIds to remote attackers?",
    "NodeId Character Set Restriction Bypass: The validation uses is_ascii_alphabetic() || is_ascii_digit() || c == '-'. Are there any ASCII characters in ranges 0x00-0x7F that could pass this check but cause issues in downstream parsing?",
    "NodeId Reconstruction from Parts: After splitting on ':', the code reconstructs NodeId(s.to_owned()) with the original string. If the split logic has bugs, could this allow injection of invalid characters?",
    "NodeId Error Message Information Leakage: The error messages in from_str() reveal validation logic (e.g., \"node id must contain only letters, digits and hyphens\"). Could this help attackers craft malicious inputs?",
    "NodeId VDRF Share Distribution: When NodeIds are used to deal VDRF shares via VdrfSecretKey::deal(), could an attacker register multiple NodeIds with nearby eval_point() values to learn information about the polynomial?",

    # I. Cryptographic Implementation & Correctness (30)
    "Schnorr Signature Verification Equation: In VerificationKey::verify(), the verification checks [s]G = R + [e]PK. Could an attacker exploit any edge cases where this equation holds for invalid signatures (e.g., point at infinity, zero scalars)? v0.rs:41-49",
    "Nonce Reuse Attack: In SigningKey::sign(), the nonce k is generated fresh each time. However, if the RNG fails silently or produces predictable output, could two signatures with the same nonce leak the private key? v0.rs:93-94",
    "Challenge Hash Computation Mismatch: The signing process uses hash_to_fr() while verification uses Fr::from_le_bytes_mod_order(&hash()). Could this difference cause valid signatures to fail or invalid signatures to pass? v0.rs:35-39 v0.rs:96-100",
    "Point Validation on R Component: When deserializing a Signature, is the r component validated to be a valid curve point in the correct subgroup? v0.rs:18-24",
    "Scalar Validation on s Component: When deserializing a Signature, is the s component validated to be in the correct field range? v0.rs:18-24",
    "Public Key Validation: When deserializing a VerificationKey, is it validated to be a non-identity point in the correct subgroup? v0.rs:26-30",
    "Signature Malleability: Given a valid Schnorr signature, could an attacker construct another valid signature for the same message? v0.rs:18-24",
    "Cross-Version Signature Verification: If VerificationKey::verify() receives a V0 signature but newer versions exist, could version mismatch lead to incorrect acceptance? mod.rs:29-36",
    "Generator Point Consistency: If the generator used in signing differs from that in verification, could this break validation? v0.rs:42-44",
    "Challenge Hash Domain Separation: Could separator collisions allow signatures to be replayed across contexts? v0.rs:77-79",
    "Message Hashing Pre-commitment: Could double-hashing in SchnorrHash introduce second-preimage issues? v0.rs:37-39 v0.rs:99-100",
    "Field Element Reduction: Could reduction via from_le_bytes_mod_order introduce biases weakening security? v0.rs:35-39",
    "Signature Equation Timing Side Channel: Could timing differences in equality check leak information? v0.rs:45-46",
    "RNG Failure Mode: If SigningKey::gen() uses a weak RNG, can predictable secret keys be generated? v0.rs:83-84",
    "Batch Verification Absence: Could lack of batch verification leak timing info across multiple signatures? mod.rs:29-36",
    "Public Key Derivation Caching: Could race conditions in OnceCell lead to repeated derivations with leaks? v0.rs:58-60",
    "Scalar Addition Overflow: Could overflow in s = k + e * sk produce invalid yet verifiable signatures? v0.rs:103",
    "Point Conversion Issues: Could projective/affine conversion errors allow forgery? v0.rs:42-44",
    "Challenge Hash Serialization Order: Could reordering serialized fields break backward compatibility? v0.rs:69-75",
    "Curve Parameter Validation: If curve parameters change, could old signatures break or new ones be forged? v0.rs:1-2",
    "Zero Private Key: If SigningKey::gen() yields zero, signatures become forgeable. Is this prevented? v0.rs:83-89",
    "Multiple Representations of Same Public Key: Could compressed point malleability affect protocol hashing? v0.rs:108-112",
    "Signature Component Swapping: Could attackers mix r and s components from different signatures? v0.rs:18-24",
    "Hash Function Collision: Could SHA3-256 collisions allow cross-message replay? v0.rs:99-100",
    "Deterministic Nonces: Should deterministic nonces replace RNG-based ones to avoid reuse? v0.rs:94",
    "Public Key Recovery from Signatures: Could observers derive verification keys from signatures? v0.rs:93-104",
    "Signature Length Extension: Could appended bytes still allow deserialization to succeed? v0.rs:18-24",
    "Cross-Curve Attacks: Could signatures from another curve be accepted if versioning fails? mod.rs:7-23",
    "VerificationKey Cloning Timing: Could cloning leak timing differences? v0.rs:32-33",
    "Message Hash Prefix Collision: Could similar prefix hashes collide despite Tagged separation? v0.rs:99-100",

    # II. Domain Separation & Tagged Interface (20)
    "Tagged Separator Reuse: Could identical separators allow replay across modules? mod.rs:25-27",
    "Missing Tagged Implementation on Signature: Could lack of Tagged enable type confusion? mod.rs:7-11",
    "Tagged Type Confusion: Could two Tagged types serialize identically? mod.rs:31-35",
    "SchnorrHash Separator Collision: Could another scheme reuse 'v0:schnorr'? v0.rs:77-79",
    "Tagged Encoding Injectivity: Can different Tagged values encode to identical bytes? encode.rs:8-38",
    "Separator Version Prefix Manipulation: Could stripping the 'v0:' prefix cause replay? mod.rs:25-27",
    "Empty Separator String: Could empty SEPARATOR collide with bincode varints? encode.rs:8-10",
    "Separator Injection: Could malicious separators inject nulls or newlines? mod.rs:25-27",
    "Message Type Downgrade: Could deserialization as a different Tagged type bypass checks? mod.rs:31-35",
    "Tagged Message Serialization Order: Could reordering break verification? encode.rs:20-37",
    "Cross-Module Separator Collisions: Could two modules reuse same SEPARATOR? mod.rs:25-27",
    "VerificationKey Hash for AccountId: Could malleability allow multiple AccountIds? mod.rs:25-27",
    "Trait Object Safety: Could Tagged trait erasure cause confusion in collections? mod.rs:31-35",
    "Message Hash Pre-image Resistance: Could weak pre-image resistance allow collisions? v0.rs:99-100",
    "Bincode Varint Manipulation: Could length prefix manipulation inject arbitrary data? encode.rs:5-6",
    "SchnorrHash Message Field Size: Does fixed-size hashing introduce truncation risk? v0.rs:74",
    "VerificationKey Equality Check: Could equivalent points compare unequal? mod.rs:13-17",
    "Tagged Version Mismatch: Could Tagged changes break old signatures? mod.rs:31-35",
    "Separator Length Limit: Could long separators cause serialization DoS? mod.rs:25-27",
    "Message Type Erasure: Could equal serialization lead to unintended signature reuse? mod.rs:31-35",

    # III. Versioning & Serialization (25)
    "Version Tag Range Validation: Can version tags ≥128 bypass validation? venum.rs:34-49",
    "Forward Compatibility: Can V1 signatures cause downgrade attacks via V0-only code? mod.rs:7-11",
    "Version Tag Mutation: Could in-transit bit-flips switch signature versions? venum.rs:61-78",
    "Signature Serialization Size: Can malformed sized signatures bypass checks? v0.rs:18-24",
    "VerificationKey Serialization: Could multiple serialization paths produce inconsistent hashes? mod.rs:13-17",
    "SigningKey Deserialization Attack: Could malicious deserialization corrupt OnceCell? v0.rs:54-60",
    "Bincode Configuration Drift: Could mismatched configs break deserialization? encode.rs:5-6",
    "G1Affine Serialization: Could uncompressed G1 data bypass validation? pairing.rs:54-80",
    "Fr Serialization: Could oversized values break deserialization? pairing.rs:116-143",
    "Version Enum Matching Failure: Could unhandled version variants be ignored? mod.rs:31-35",
    "Tuple Serialization Mismatch: Could struct-vs-tuple encoding break compat? venum.rs:66-77",
    "Deserialization Panic DoS: Could repeated invalid tags cause DoS? venum.rs:103-113",
    "VerificationKey Hash Collisions: Could hash collisions affect HashMaps? mod.rs:13-17",
    "SigningKey Skipped Field Serialization: Could vk OnceCell remain uninitialized? v0.rs:58-60",
    "Cross-Platform Serialization: Could endianness differences break signatures? encode.rs:5-6",
    "Version Removal Breaking: Could removing V0 break old signatures? venum.rs:275-324",
    "JSON vs Bincode: Could format inconsistencies break verification? encode.rs:52-60",
    "StrEncoded Base64 Formatting: Could padding variants cause misinterpretation? encode.rs:88-154",
    "Version Tag Exhaustion: Could >127 versions require breaking serialization? venum.rs:38-46",
    "Signature Clone Semantics: Could cloning duplicate sensitive cached values? mod.rs:7-11",
    "VerificationKey as HashMap Key: Could inconsistent hashing exist? mod.rs:13-17",
    "Deserialize from Untrusted Sources: Could malformed input exploit deserializer? mod.rs:7-11",
    "Arkworks Serialization Changes: Could upstream changes break signatures? pairing.rs:54-80",
    "Tuple Length Validation: Can altered tuple lengths bypass checks? venum.rs:116-117",
    "VerificationKey Debug Output: Could debug printing leak info? mod.rs:13-17",

    # IV. Key Management & Lifecycle (20)
    "Private Key Zeroization Timing: Could compiler optimizations remove zeroization? v0.rs:63-67",
    "OnceCell Zeroization Absence: Could cached VerificationKey leak in memory? v0.rs:58-67",
    "SigningKey Clone Safety: Could cloning leave un-zeroized secret copies? v0.rs:54-67",
    "VerificationKey Derivation Race: Could concurrent calls race in OnceCell? v0.rs:108-112",
    "SigningKey File Persistence: Could disk copies escape zeroization? v0.rs:54-60",
    "Key Generation RNG Weakness: Could weak RNG produce predictable keys? v0.rs:83-89",
    "VerificationKey In-Memory Exposure: Could mass storage of keys allow correlation attacks? v0.rs:26-30",
    "SigningKey Memory Paging: Could OS page out secret data to disk? v0.rs:54-67",
    "Missing Key Rotation: Could long-lived keys become weak without rotation? mod.rs:38-57",
    "VerificationKey On-chain Mutability: Could malicious actors replace keys on-chain? mod.rs:13-17",
    "Drop During Panic: Will Drop run on panic to zeroize secret key? v0.rs:63-67",
    "Weak KDF for Shared Secrets: Could weak derivation allow brute-forcing? mod.rs:38-42",
    "Multiple VerificationKeys per Account: Could outdated keys still verify? mod.rs:13-17",
    "SigningKey in RikSecretData: Could weak encryption leak keys? mod.rs:19-23",
    "VerificationKey Immutability: Could inability to update vk cause issues after compromise? v0.rs:108-112",
    "Key Export Without Zeroization: Could exported keys remain in memory? v0.rs:54-60",
    "Public Key Reconstruction: Could public keys be derived from signatures? v0.rs:93-104",
    "Allocator Security: Could freed but non-zeroed memory leak private keys? v0.rs:63-67",
    "Backup Encryption Binding: Could decrypted keys be used for wrong accounts? mod.rs:19-23",
    "Lack of HSM Integration: Could software-only key storage be scraped? mod.rs:38-42",

    # V. Integration with Account Management (15)
    "AccountId Derivation Malleability: Could point malleability allow multiple AccountIds? mod.rs:25-27",
    "Account Recovery Signature Verification: Could silent failures allow unauthorized recovery? mod.rs:29-36",
    "Recovery Request Replay: Could RecoveryRequest signatures be replayed? mod.rs:45-49",
    "Account Update Replay: Could old signatures be replayed without nonce checks? mod.rs:45-49",
    "Dirty Account State Signatures: Could stale signatures apply to dirty state? mod.rs:29-36",
    "Multiple Account Owners: Could multiple verification keys grant unilateral control? mod.rs:13-17",
    "Account Linking Replay: Could linking signatures attach emails to wrong accounts? mod.rs:45-49",
    "AccountId Collision Possibility: Could duplicate VerificationKeys cause same AccountId? mod.rs:25-27",
    "Account Deletion Replay: Could old deletion signatures be reused? mod.rs:45-49",
    "New Owner Signature Missing: Could missing signatures allow unauthorized ownership transfer?",

    "In DecryptionKey::gen() v0.rs:54-59 , the secret key sk is generated directly from the RNG without any rejection sampling or range checks. Could a weak or biased RNG produce secret keys that lie in a small subgroup or have low discrete log complexity, allowing an attacker to brute-force guardian decryption keys and violate the \"only owner can reconstruct backups\" invariant?",
    "The DecryptionKey::gen() function v0.rs:54-59 accepts any CryptoRng + Rng implementation. If a malicious off-chain node or compromised client supplies a deterministic or predictable RNG, could this lead to predictable secret keys, enabling an attacker to pre-compute decryption keys for future guardian shares and compromise backup reconstruction?",
    "The EncryptionKey is derived lazily in encryption_key() v0.rs:61-66 using OnceCell. If the public key computation curve::GAffine::generator() * self.sk encounters an edge case (e.g., sk = 0), could this result in the identity element as a public key, causing all encryptions to the same point and breaking IND-CCA2 security for that guardian?",
    "In DecryptionKey::gen() v0.rs:54-59 , there's no validation that sk ≠ 0. If a zero secret key is generated (though statistically improbable), the corresponding public key would be the identity element. Could this enable an attacker to forge ciphertexts that decrypt under multiple keys, violating the binding between guardian and their backup share?",
    "The ephemeral Diffie-Hellman secret ts in encrypt() v0.rs:106-107 is sampled from the provided RNG. If the RNG is compromised or predictable (e.g., seeded with low-entropy data), could an attacker predict ts, compute the shared secret, and decrypt guardian shares, violating backup confidentiality?",
    "The encrypt() function v0.rs:99-132 generates a fresh ephemeral key ts for each encryption. If the RNG fails or repeats nonces (e.g., due to insufficient entropy after fork), could this lead to nonce reuse in the underlying symmetric AEAD, breaking semantic security and allowing ciphertext decryption by observing XOR differences?",
    "In encryption_key() v0.rs:61-66 , the public key is computed as curve::GAffine::generator() * self.sk. If the curve implementation has vulnerabilities (e.g., cofactor issues, invalid point handling), could a malicious party craft invalid public keys that pass deserialization but enable cryptographic attacks when used for guardian share encryption?",
    "The secret key sk in DecryptionKey v0.rs:29-34 is stored as curve::Fr. Does this type guarantee that values are always in the correct field, or could deserialization allow out-of-range values that break discrete log assumptions and enable unauthorized decryption?",
    "The DecryptionKey struct v0.rs:28-34 caches the public key in a OnceCell. If an attacker can trigger multiple initializations through concurrent access or race conditions, could this lead to inconsistent public/private key pairs, allowing a guardian's share to be encrypted to a different key than they can decrypt?",
    "In encrypt() v0.rs:106-107 , the ephemeral scalar ts is generated without checking if it's zero. If ts = 0 (with negligible probability), the ephemeral public key tp would be the identity element, and the shared secret computation would fail. Could this cause a denial-of-service in backup creation, preventing guardians from receiving valid shares?",
    "In decrypt() v0.rs:73-78 , the shared secret is computed as (ct.tp * self.sk).into_affine(). If ct.tp is a maliciously crafted point (e.g., point of small order, invalid curve point), could this lead to a predictable shared secret, allowing an attacker to decrypt guardian shares without knowing the secret key?",
    "The encrypt() function v0.rs:111-114 computes the shared secret as (self.0 * ts).into_affine(). If self.0 (the recipient's public key) is not validated during deserialization and is a point of small order, could this result in a small shared secret space, enabling brute-force attacks on guardian backup shares?",
    "In both encrypt() and decrypt() v0.rs:75-78 , the result of scalar multiplication is converted to affine coordinates with .into_affine(). If the multiplication results in the point at infinity (e.g., due to small-order points), could this cause a panic or produce an invalid shared secret, violating the integrity of guardian share encryption?",
    "The shared secret in decrypt() v0.rs:74-78 is serialized using serialize_compressed(). If this serialization is not canonical or allows multiple representations of the same point, could an attacker create multiple valid ciphertexts for the same plaintext, enabling ciphertext malleability attacks on guardian shares?",
    "In encrypt() v0.rs:110-114 , the input key material (IKM) for the KDF is the serialized shared secret. If the serialization includes extra metadata or non-canonical representations, could this lead to different IKMs for the same shared secret, breaking decryption and causing guardian shares to be permanently undecryptable?",
    "The Diffie-Hellman computation in decrypt() v0.rs:75-78 uses the ciphertext's ephemeral key ct.tp directly without validation. Could a malicious party who controls a minority of guardians craft invalid ephemeral keys that cause arithmetic errors during shared secret computation, preventing honest guardians from decrypting their shares?",
    "In encrypt() v0.rs:107 , the ephemeral public key is computed as (curve::GAffine::generator() * ts).into(). If the generator point is not properly validated or is substituted during deserialization, could this lead to weak ephemeral keys that compromise the security of guardian share encryption?",
    "The shared secret computation in both encrypt() and decrypt() v0.rs:75-78 assumes the curve operations are constant-time. If the underlying ark_ec library has timing side-channels during scalar multiplication, could a malicious off-chain node or network adversary extract guardian secret keys through timing analysis of decryption operations?",
    "In decrypt() v0.rs:73-78 , the shared secret is computed before any validation of the ciphertext's MAC. If an attacker can trigger shared secret computation with many invalid ciphertexts, could this create a timing side-channel that leaks information about the secret key self.sk?",
    "The ephemeral key tp in Ciphertext v0.rs:42-47 is stored as a curve point. If this point is not checked for subgroup membership during deserialization, could an attacker provide points in a small subgroup, reducing the effective security of guardian share encryption to the subgroup order?",
    "The DiffieHellmanCtx structure v0.rs:21-26 includes both the ephemeral public key tp and the recipient's public key pk in the KDF context. If either key is malleated or substituted after encryption but before KDF derivation, could this break the binding between ciphertext and recipient, allowing guardian shares to be decrypted by unintended parties?",
    "In both encrypt() and decrypt() v0.rs:82-88 , the DiffieHellmanCtx is constructed with tp and pk. However, the user-provided context ctx is passed separately to the symmetric AEAD. Could a type confusion attack occur where the same context type is used with different separators, allowing a guardian share encrypted for backup recovery to be decrypted in an account recovery session?",
    "The kdfn() function v0.rs:82-88 takes &DiffieHellmanCtx which includes the public keys. If the serialization of DiffieHellmanCtx is not injective (i.e., different contexts could serialize to the same bytes), could this enable context confusion attacks where a ciphertext from one guardian is decryptable by another?",
    "In encrypt() v0.rs:119-125 , the DiffieHellmanCtx uses self.0 as the pk field. If the EncryptionKey can be malleated or corrupted during transmission (e.g., from contract storage), could this cause the encryption and decryption contexts to mismatch, permanently locking guardian shares?",
    "The DiffieHellmanCtx implements Tagged v0.rs:49-51 with separator \"v0:pke-dhpk-ss\". If a future version uses a different separator or the separator can be controlled by an attacker, could this enable cross-protocol attacks where guardian shares encrypted in one context are decrypted in another?",
    "In decrypt() v0.rs:84-87 , the DiffieHellmanCtx is constructed with self.encryption_key().0. If the cached public key in OnceCell is uninitialized or corrupted, could this lead to using an incorrect public key in the KDF context, causing decryption to fail or succeed for wrong ciphertexts?",
    "The KDF context binding includes the ephemeral key tp v0.rs:23 , which is also part of the ciphertext v0.rs:45 . If an attacker modifies tp in the ciphertext after encryption, the context will mismatch and decryption will fail. However, could this allow a denial-of-service attack where a malicious guardian or off-chain node corrupts ciphertexts to prevent other guardians from participating in backup recovery?",
    "The kdfn() call v0.rs:82-88 derives a symmetric key from the shared secret and context. If the KDF output length is insufficient or the KDF has cryptographic weaknesses, could an attacker with partial knowledge of guardian shares brute-force the symmetric key and decrypt guardian backup shares?",
    "In encrypt() and decrypt(), the user-provided context ctx: &A v0.rs:68-72 is passed to the symmetric AEAD but not directly to the DiffieHellmanCtx. If two different context types serialize to the same bytes, could this enable a collision attack where a guardian share encrypted for one backup is decryptable in another backup, violating backup-to-account binding?",
    "The DiffieHellmanCtx structure v0.rs:21-26 is serialized as part of the KDF input. If the serialization library (serde/bincode) has vulnerabilities or allows non-canonical encodings, could an attacker craft two different DiffieHellmanCtx instances that produce the same KDF output, breaking the uniqueness of derived keys?",
    "The decrypt() function v0.rs:81-91 calls sym::open() which performs MAC verification. If the MAC check is timing-variable or the error handling leaks information about which part of decryption failed, could a network adversary or malicious guardian use this as an oracle to extract information about the guardian's secret key?",
    "In encrypt() v0.rs:117-128 , the symmetric key is derived from the shared secret and immediately used with sym::seal(). If the symmetric AEAD has nonce reuse vulnerabilities or weak key derivation, could this compromise the confidentiality of guardian shares even if the underlying PKE is secure?",
    "The sym::open() call in decrypt() v0.rs:81-91 returns a generic SwafeError::DecryptionFailed on failure. Does this error leak information about whether the failure was due to MAC mismatch, deserialization error, or other causes? Could a malicious off-chain node use this to distinguish between corrupted ciphertexts and wrong keys?",
    "The symmetric key passed to sym::seal() v0.rs:117-128 is derived from kdfn() with a fixed-size output. If the output size is shorter than the security parameter (e.g., 128 bits instead of 256 bits), could this reduce the effective security of guardian share encryption below the intended level?",
    "In encrypt() v0.rs:117-128 , the same derived key is used for potentially multiple messages if the function is called repeatedly. Although each call generates a fresh ts, could repeated encryptions with the same recipient key create patterns that leak information about the guardian shares or the shared secrets?",
    "The sym::open() function v0.rs:81-91 takes the symmetric key and ciphertext. If an attacker can replay the same ciphertext multiple times to the same guardian, could timing differences in decryption (even with constant-time primitives) leak information about the plaintext or key material?",
    "In decrypt() v0.rs:81-91 , after successful MAC verification in sym::open(), the plaintext is deserialized. If deserialization fails, is the derived symmetric key properly zeroized, or could it remain in memory and be leaked through side-channels or memory dumps?",
    "The encrypt() function v0.rs:117-128 passes msg and ctx to sym::seal(). If the message type M or context type A implement Tagged incorrectly (e.g., with colliding separators), could this enable type confusion attacks where a guardian share is interpreted as a different data structure after decryption?",
    "The derived symmetric key in both encrypt() and decrypt() is not explicitly zeroized after use. Could this leave key material in memory longer than necessary, increasing the risk of key extraction through memory dumps or side-channel attacks on guardian devices?",
    "In encrypt() v0.rs:119-125 , the KDF output is directly used as the AEAD key. If the KDF is not key-committing or has weak output properties, could an attacker find two different shared secrets that produce the same symmetric key, enabling a chosen-ciphertext attack on guardian shares?",
    "The decrypt() function v0.rs:68-92 requires the same context ctx: &A that was used during encryption. If the context is not properly bound to the backup or account instance, could an attacker take a guardian share ciphertext from one backup and replay it in another backup, violating the backup-to-account binding invariant?",
    "In encrypt() v0.rs:99-132 , the user-provided context ctx is passed to the symmetric AEAD layer. If the context type A does not include sufficient binding information (e.g., backup ID, account address, nonce), could this allow cross-context attacks where a ciphertext valid in one recovery session is accepted in another?",
    "The DiffieHellmanCtx v0.rs:21-26 binds the public keys but not the user context ctx. If two encryptions use the same recipient key but different user contexts, could an attacker swap the symmetric ciphertexts while keeping the same tp, causing guardian shares to decrypt with incorrect associated data?",
    "In decrypt() v0.rs:90-91 , the context ctx is passed to sym::open(). If the caller provides an incorrect context (e.g., due to a bug or malicious input), the function will fail with DecryptionFailed. Could this error be exploited to leak information about which guardian shares belong to which backup?",
    "The context type A: Tagged v0.rs:68-72 must implement the Tagged trait with a domain separator. If two different context types use the same separator string, could this enable cross-protocol attacks where a guardian share encrypted for backup recovery is decryptable in account recovery or vice versa?",
    "In both encrypt() and decrypt(), the context is provided by the caller without validation. If a malicious off-chain node or compromised guardian provides a context that collides with contexts from other backups, could this enable a guardian to decrypt shares from multiple backups, violating the isolation between different users' backups?",
    "The decrypt() function v0.rs:68-92 does not verify that the context matches any on-chain commitment or merkle root. Could an attacker provide a valid ciphertext but an incorrect context to cause decryption to fail, enabling a denial-of-service attack where guardians cannot decrypt their shares even though the ciphertext is valid?",
    "In encrypt() v0.rs:126-127 , the context is serialized as part of the AEAD associated data. If the context contains large or unbounded data structures, could this cause performance issues or memory exhaustion when encrypting guardian shares for a backup with many guardians?",
    "The context binding in decrypt() v0.rs:90-91 relies on the symmetric AEAD's associated data mechanism. If the AEAD implementation has weaknesses in AD handling (e.g., not actually binding AD to the ciphertext), could this allow an attacker to swap contexts and decrypt guardian shares with incorrect metadata?",
    "In encrypt(), the context ctx is used in both the DiffieHellmanCtx (indirectly via public keys) and the symmetric AEAD. If these two bindings are not cryptographically independent, could a collision in one allow an attacker to forge valid ciphertexts that decrypt under different contexts?",
    "The DiffieHellmanCtx has a fixed separator v0.rs:49-51 \"v0:pke-dhpk-ss\". If this separator is reused in other parts of the codebase or can be influenced by user input, could this enable domain separation failures where guardian shares are confused with other encrypted data types?",
    "The decrypt() function v0.rs:68-92 accepts a generic message type M: Tagged + DeserializeOwned. If an attacker can cause the deserialization to succeed with a different type than intended (e.g., deserializing a GuardianShare as an AccountSecret), could this violate type safety and lead to incorrect recovery flows?",
    "In the Tagged trait implementation for DiffieHellmanCtx v0.rs:49-51 , the separator is a compile-time constant. However, if the separator is not globally unique across all Tagged types in the codebase, could this enable cross-type confusion where a ciphertext intended for one purpose is decrypted in another?",
    "The encrypt() function v0.rs:99-132 serializes the message msg: &M where M: Tagged. If the Tagged implementation for guardian share types has a weak or colliding separator, could this allow an attacker to create fake guardian shares that pass decryption but contain malicious data?",
    "In decrypt() v0.rs:81-91 , the sym::open() call uses the message type M's separator for domain separation. If multiple message types in the backup/recovery flow share the same separator (e.g., due to copy-paste errors), could this enable type confusion attacks where one share type is substituted for another?",
    "The context type A: Tagged v0.rs:68-72 is separate from the message type M: Tagged. If an attacker can find two types A1 and A2 with colliding separators but different semantic meanings, could this enable cross-context attacks where a guardian share encrypted for backup recovery is decrypted in a different protocol flow?",
    "In both encrypt() and decrypt(), the Tagged trait ensures domain separation. However, if the trait is implemented incorrectly for guardian share types (e.g., using dynamic separators or user-controlled strings), could this break domain separation and enable collision attacks on encrypted shares?",
    "The DiffieHellmanCtx structure v0.rs:21-26 contains curve points that are serialized. If the serialization format changes between versions or is not canonical, could an old ciphertext become undecryptable or decryptable with incorrect context, permanently locking guardian shares?",
    "In decrypt() v0.rs:81-91 , the deserialization of the plaintext uses bincode::serde::decode_from_slice(). If the deserializer allows multiple valid encodings for the same data structure, could an attacker create non-canonical guardian shares that bypass integrity checks in later recovery steps?",
    "The encrypt() function v0.rs:117-128 passes both message and context to the symmetric layer. If the symmetric layer does not properly separate these in its MAC computation, could an attacker swap messages and contexts to create valid but semantically incorrect ciphertexts?",
    "The file is named v0.rs v0.rs:1 , suggesting versioning. If a future v1.rs uses different cryptographic primitives or serialization formats, could old guardian shares encrypted with v0 become permanently undecryptable if the versioning is not properly handled in the parent module?",
    "The DiffieHellmanCtx separator v0.rs:50 includes \"v0:\" prefix. If version negotiation is not properly enforced, could an attacker downgrade a v1 ciphertext to v0, exploiting potential weaknesses in the older version to decrypt guardian shares?",
    "In decrypt() v0.rs:68-92 , there's no explicit version check on the ciphertext. If a malicious party provides a ciphertext from a different version with a compatible structure, could this cause unexpected behavior or security vulnerabilities when guardians attempt to decrypt their shares?",
    "The EncryptionKey and DecryptionKey structures v0.rs:14-34 use serde for serialization. If the serialization format changes between versions (e.g., adding new fields), could old keys become incompatible, preventing guardians from accessing their historical backup shares?",
    "In the parent pke/mod.rs module, v0 types are wrapped in versioned enums. If the version dispatch logic has bugs or allows version confusion, could an attacker cause a v0 DecryptionKey to be used with a v1 Ciphertext, potentially leading to security vulnerabilities or recovery failures?",
    "The DecryptionKey implements Drop v0.rs:36-40 to zeroize the secret key self.sk. However, if the DecryptionKey is cloned (it implements Clone v0.rs:28-34 ), could the cloned copies retain the secret key in memory even after the original is dropped, violating the zeroization guarantee?",
    "In DecryptionKey::Drop v0.rs:36-40 , only self.sk is zeroized. The cached public key in self.pk: OnceCell is not zeroized. While public keys don't need zeroization, could this leave other sensitive data in the OnceCell if it's used for caching computed values?",
    "The DecryptionKey struct v0.rs:28-34 implements Serialize and Deserialize. If a guardian's DecryptionKey is serialized to disk or transmitted over the network, could the secret key be intercepted before the Drop is called, allowing an attacker to extract it and decrypt all shares for that guardian?",
    "In decrypt() v0.rs:68-92 , the secret key self.sk is used in scalar multiplication. If the scalar multiplication operation is not constant-time or the secret key is copied into temporary buffers during computation, could this leave copies of the key in memory that are not zeroized?",
    "The DecryptionKey::gen() function v0.rs:54-59 generates a fresh key by sampling from the RNG. If the RNG's internal state is not properly zeroized after key generation, could the generated secret keys be reconstructed by analyzing memory dumps or side-channels?",
    "In encryption_key() v0.rs:61-66 , the public key is computed from the secret key. If this computation is performed multiple times (e.g., due to incorrect OnceCell usage), could intermediate values from the scalar multiplication remain in memory and leak information about the secret key?",
    "The DecryptionKey is cloneable v0.rs:28-34 . If a guardian clones their key for concurrent operations (e.g., decrypting multiple shares), could one clone be dropped while another is still in use, causing the secret key to be zeroized prematurely and breaking decryption?",
    "In decrypt() v0.rs:73-78 , the shared secret is computed into a local ikm vector. Is this vector properly zeroized after use, or could it remain in memory and be extracted through side-channels, allowing an attacker to decrypt future ciphertexts from the same guardian?",
    "The DecryptionKey struct v0.rs:28-34 contains a OnceCell<curve::GAffine> for caching the public key. If the OnceCell is not properly handled during serialization/deserialization, could a deserialized key have an uninitialized or corrupted public key, causing subsequent operations to fail or leak information?",
    "In encryption_key() v0.rs:62-65 , the OnceCell::get_or_init() is called with a closure that computes the public key. If this closure panics or is interrupted (e.g., by a signal), could the OnceCell be left in an inconsistent state, causing subsequent encryption operations to use an incorrect public key?",
    "The secret key sk: curve::Fr v0.rs:31 is a field element. If the zeroize() implementation for curve::Fr is not thorough or misses some internal buffers, could residual key material remain in memory after drop, allowing an attacker to recover guardian secret keys?",
    "In DecryptionKey::gen() v0.rs:54-59 , the generated key is returned directly without any additional protection (e.g., encryption with a master key). If the key is stored in plaintext in guardian device memory, could a memory dump or malware extract all guardian keys, enabling unauthorized backup reconstruction?",
    "The DecryptionKey implements Clone v0.rs:28 via the derive macro. If cloning creates deep copies of the secret key sk, could multiple copies of the key exist in memory simultaneously, increasing the attack surface for key extraction?",
    "In decrypt() v0.rs:75-78 , the scalar multiplication ct.tp * self.sk may create intermediate values during computation. Are these intermediate values properly zeroized by the ark_ec library, or could they remain in memory and leak information about the guardian's secret key?",
    "The DecryptionKey serialization v0.rs:28-34 skips the pk field with #[serde(skip)]. If a guardian serializes and deserializes their key, the public key cache is lost. Could this cause the public key to be recomputed multiple times, increasing exposure to side-channel attacks?",
    "The pk field in DecryptionKey",

    # I. Cryptographic Correctness & Key Commitment (1–25)
    "Nonce Uniqueness Under Key Reuse: In the seal function, the synthetic nonce is derived from kdfn(key, &NonceTuple{...}) where the tuple includes a random nonce from rng.gen::<Nonce>(). If the same key is reused across multiple encryptions with the same plaintext and associated data, could a weak RNG produce colliding random nonces, leading to nonce reuse and XOR-pad reuse that enables ciphertext manipulation? symmetric.rs:81-89",
    "Key Commitment Binding: The scheme claims to be 'Key-Committing AEAD,' but does the MAC computation in seal truly bind the key to the ciphertext? Could an attacker who obtains two different keys that produce the same MAC for different plaintexts cause decryption ambiguity? symmetric.rs:99-107",
    "Synthetic Nonce Input Entropy: The NonceTuple struct used for synthetic nonce generation includes rng.gen::<Nonce>(), pt, and ad. If an attacker can predict or influence the plaintext pt during account recovery scenarios where recovery data is deterministic, does the synthetic nonce generation still provide sufficient randomness? symmetric.rs:81-89",
    "MAC Verification Constant-Time: The open function uses subtle::ConstantTimeEq for MAC comparison, but if ct.mac or mac_corr arrays contain uninitialized or partial data due to incorrect deserialization, could the constant-time comparison still leak timing information? symmetric.rs:127-129",
    "KDF Output Length Manipulation: The kdf function in hash.rs fills an arbitrary-length output buffer. If the XOR-pad buffer ct in seal is incorrectly sized due to serialization issues with pt, could this lead to truncated encryption or buffer overflow when XORing? symmetric.rs:92-96",
    "Domain Separation Tag Collision: The MACTuple and NonceTuple structs use separator: (&'static str, &'static str) with message and AD separators. Could an attacker craft a malicious Tagged implementation where M::SEPARATOR and A::SEPARATOR combine to match a different valid domain, enabling cross-domain ciphertext substitution? symmetric.rs:39-44",
    "Empty Associated Data Security: The EmptyAD type with separator 'v0:sym-ad-empty' is used when no associated data is needed. If account recovery logic incorrectly uses EmptyAD instead of binding the email certificate or account ID, could an attacker replay ciphertexts across different recovery contexts? symmetric.rs:28-30",
    "Plaintext Length Leakage: The AEADCiphertext struct stores ct: Vec<u8> whose length equals the plaintext length. For backup shares or association data, does leaking the exact plaintext size via ciphertext length violate privacy invariants by revealing which guardians are selected or the structure of encrypted data? symmetric.rs:22-26",
    "XOR Pad Derivation Collision: The KDFPad struct derives the XOR pad from the nonce alone. If two different messages with different nonces happen to produce the same KDFPad output due to KDF collisions, could this enable key recovery attacks? symmetric.rs:33-34",
    "MAC Input Ordering: The MACTuple serializes fields in the order (separator, nonce, ct, ad). Could an attacker exploit bincode's encoding scheme to craft a different struct that serializes to the same bytes, bypassing MAC verification? symmetric.rs:38-44",
    "Key Material Zeroing: After seal and open complete, are intermediate buffers like pt (plaintext) and derived XOR pads securely zeroed? If guardian shares or master secrets remain in memory, could a compromised off-chain node extract them via memory dumps? symmetric.rs:92-96",
    "Nonce Reuse Across Protocol Versions: The separators use 'v0:...' prefixes. If a future protocol version reuses the same nonce generation logic with updated separators, could old ciphertexts be replayed in new contexts? symmetric.rs:55-56",
    "Type Parameter Constraints: The seal and open functions require M: Tagged and A: Tagged. Could a malicious caller pass types that don't properly implement Tagged, leading to empty or predictable separators that break domain separation? symmetric.rs:71-76",
    "Bincode Serialization Determinism: The seal function uses bincode::serde::encode_to_vec(pt, bincode::config::standard()).unwrap(). If the plaintext type has non-deterministic serialization (e.g., HashMaps), could different serializations of the same logical plaintext produce different nonces, breaking key commitment? symmetric.rs:77-78",
    "MAC Length Hardcoding: The MAC is hardcoded to 32 bytes (SIZE_MAC). If KMAC256 allows variable-length outputs, could an attacker who controls serialization logic truncate the MAC during deserialization, weakening authentication? symmetric.rs:13",
    "Nonce Length Security: The nonce is 32 bytes (SIZE_NONCE). For the XOR-based encryption scheme, is 32 bytes sufficient to prevent nonce collisions under high-volume usage across all Swafe accounts? symmetric.rs:14",
    "Key Length Validation: The key is defined as 32 bytes (SIZE_KEY). Does the system validate that keys passed to seal and open are exactly 32 bytes? Could zero-length or incorrect-length keys cause panics or weak encryption? symmetric.rs:15-19",
    "RNG Source Trust: The seal function accepts any R: Rng for generating the random component of the synthetic nonce. If a malicious caller passes a weak or predictable RNG, could this compromise nonce uniqueness and enable chosen-ciphertext attacks during backup encryption? symmetric.rs:71-76",
    "Ciphertext Malleability: Although the MAC should prevent tampering, the XOR-based encryption allows direct bit-flipping of the ciphertext. If an attacker can manipulate the ct field before MAC verification, does the MAC verification order ensure all modifications are detected? symmetric.rs:118-129",
    "KDF Context Mixing: The kdfn function uses KMAC256 with the Tagged separator as customization string. If two different contexts (e.g., XOR pad vs. MAC) use the same input key material, could output collisions occur? symmetric.rs:93",
    "Associated Data Mutability: The ad parameter in seal and open is borrowed immutably. If the caller modifies the associated data after sealing but before storing the ciphertext on-chain, could this lead to decryption failures during recovery that permanently lock accounts? symmetric.rs:75-76",
    "Panic on Serialization Failure: The seal function calls .unwrap() on bincode serialization. If serialization fails due to malformed plaintext types, could this cause a panic in the contract execution, leading to stuck transactions? symmetric.rs:78",
    "Cross-Protocol Nonce Reuse: If the same key is used for both symmetric encryption (this module) and other schemes (e.g., PKE in pke/v0.rs), could nonce/randomness reuse across different protocols break security? symmetric.rs:81-89",
    "Synthetic Nonce Truncation: The kdfn function returns exactly SIZE_NONCE bytes. If the KDF output is truncated or padded incorrectly, could this reduce nonce entropy and increase collision probability? symmetric.rs:81-89",
    "Key Derivation Root Key Protection: The key parameter is used directly in KDF calls. If this key is derived from a master secret using the same KDF, could related-key attacks be possible? symmetric.rs:73",

    # II. Serialization & Deserialization Security (26–45)
    "Deserialization Length Mismatch: In open, after decrypting to pt, the function checks if n != pt.len() where n is bytes consumed during deserialization. Could an attacker craft a ciphertext where valid deserialization consumes fewer bytes, leaving trailing data that could be exploited in subsequent operations? symmetric.rs:139-145",
    "Type Confusion in Deserialization: The open function deserializes to generic type M: Tagged + DeserializeOwned. Could an attacker provide a ciphertext that deserializes correctly to type M but was encrypted for a different type with the same binary representation, bypassing domain separation? symmetric.rs:139-145",
    "Bincode Configuration Mismatch: Both seal and open use bincode::config::standard(). If the configuration changes between versions or is used inconsistently across modules, could ciphertexts become unreadable, permanently locking guardian shares? symmetric.rs:78",
    "Deserialization Error Information Leakage: When deserialization fails in open, the function returns SwafeError::DecryptionFailed without details. However, could timing differences between MAC failure and deserialization failure leak information about plaintext structure to an attacker? symmetric.rs:147",
    "Malformed Ciphertext Struct: The AEADCiphertext struct is derived with Deserialize. Could an attacker craft a serialized AEADCiphertext where ct.len() doesn't match the actual vector length, causing out-of-bounds access during decryption? symmetric.rs:21-26",
    "Recursive Deserialization Attack: If the plaintext type M contains nested structures, could deeply nested deserialization in open cause stack overflow or excessive memory allocation, disrupting contract execution? symmetric.rs:139-145",
    "Zero-Length Ciphertext Handling: If ct.ct is an empty vector, the decryption loop never executes. Does open correctly handle zero-length plaintexts, or could this lead to unexpected behavior in calling code expecting non-empty data? symmetric.rs:131-136",
    "Nonce Deserialization Trust: The nonce field in AEADCiphertext is used directly in MAC computation and XOR pad derivation without validation. Could an attacker craft a ciphertext with an invalid nonce (e.g., all zeros) that causes weak key derivation? symmetric.rs:22-26",
    "MAC Array Deserialization: The mac field is type [u8; SIZE_MAC]. If deserialization incorrectly handles fixed-size arrays, could a malformed ciphertext have a truncated MAC that still passes deserialization? symmetric.rs:24",
    "Plaintext Size Explosion: The seal function serializes the plaintext to Vec<u8>. Could an attacker provide a plaintext type that serializes to an enormous size (e.g., via custom Serialize impl), causing memory exhaustion when encrypting backup data? symmetric.rs:77-78",
    "Associated Data Serialization Consistency: The associated data ad is serialized inside MACTuple and NonceTuple. If ad has non-deterministic serialization, could the same logical AD produce different MACs, breaking verification? symmetric.rs:39-44",
    "Ciphertext Clone Safety: The AEADCiphertext struct derives Clone. If a ciphertext is cloned and one copy is decrypted successfully, does the MAC verification prevent the cloned copy from being modified and reused maliciously? symmetric.rs:21-26",
    "Separator Serialization Format: The separator field in MACTuple and NonceTuple is (&'static str, &'static str). How does bincode serialize this tuple, and could an attacker exploit bincode's string encoding to create separator collisions? symmetric.rs:40",
    "Partial Deserialization State: If bincode::serde::decode_from_slice in open partially succeeds (deserializes some fields but fails on others), could partial state leak sensitive information or cause incorrect error handling? symmetric.rs:139-145",
    "Ciphertext Equality Comparison: The AEADCiphertext struct derives PartialEq and Eq. If two ciphertexts are compared for equality during account recovery, could timing differences in vector comparison leak information about plaintext differences? symmetric.rs:21-26",
    "Hash Derivation for Ciphertext: The struct derives Hash, allowing ciphertexts to be used in hash-based collections. Could an attacker cause hash collisions by crafting ciphertexts with different content but identical hashes, disrupting storage logic? symmetric.rs:21-26",
    "Debug Trait Exposure: The AEADCiphertext derives Debug. If this struct is accidentally logged during contract execution, does the debug output expose sensitive ciphertext bytes or MACs that could aid cryptanalysis? symmetric.rs:21-26",
    "Bincode Version Compatibility: If a future version of bincode changes encoding format, could old ciphertexts stored on-chain become unreadable, permanently locking backup shares? symmetric.rs:78",
    "XOR Buffer Alignment: The decryption loop XORs pt[i] ^= ct.ct[i] byte-by-byte. If the vectors have mismatched lengths due to deserialization corruption, could this cause panics or incorrect decryption? symmetric.rs:134-136",
    "Unwrap on Serialization: The seal function calls .unwrap() on serialization. If the plaintext type has custom Serialize logic that returns errors, could this lead to panics that disrupt transaction flow? symmetric.rs:78",

    # III. Domain Separation & Type Safety (46–65)
    "Tagged Trait Implementation Trust: The Tagged trait requires implementors to define const SEPARATOR: &'static str. If a malicious or buggy type defines an empty separator, does this completely break domain separation between different message types? symmetric.rs:62-64",
    "Separator Reuse Across Contexts: The file defines separators like 'v0:sym-pad', 'v0:sym-mac', and 'v0:sym-nonce'. If these separators are reused in other cryptographic contexts (e.g., signatures, commitments), could this enable cross-protocol attacks? symmetric.rs:54-68",
    "Message Type Separator Format: Message types like TestMsg1 and TestMsg2 use separators like 'v0:test-message-v1'. Could an attacker register an account or backup with carefully chosen separators that collide with system-reserved prefixes? symmetric.rs:175-181",
    "Associated Data Type Confusion: The open function accepts generic A: Tagged for associated data. If an attacker provides a different AD type than what was used in seal, the MAC verification should fail. But could type erasure in the calling code bypass this check? symmetric.rs:112-116",
    "Empty Associated Data Default: The EmptyAD type uses separator 'v0:sym-ad-empty'. If calling code defaults to EmptyAD when AD should be required (e.g., binding email certificates), could this enable replay attacks across accounts? symmetric.rs:28-30",
    "KDFPad Separator Uniqueness: The KDFPad struct has separator 'v0:sym-pad'. If this same separator is used elsewhere in the codebase for different purposes, could KDF outputs collide? symmetric.rs:54-56",
    "MACTuple Separator Format: The MACTuple uses separator: (M::SEPARATOR, A::SEPARATOR) as a tuple. Could an attacker craft message and AD types where the concatenated separator tuple matches a different valid combination? symmetric.rs:39-44",
    "NonceTuple Separator Collision: The NonceTuple has its own separator 'v0:sym-nonce' plus the message/AD separators. If the nonce generation logic is used outside this module, could nonce collisions occur? symmetric.rs:46-52",
    "Protocol Version in Separators: All separators use 'v0:' prefix. If the protocol upgrades to v1 but forgets to update some separators, could old and new ciphertexts be confused? symmetric.rs:54-68",
    "Type Parameter Variance: The seal and open functions use different type parameters for message (M) and associated data (A). Could an attacker exploit Rust's type system to pass subtypes that serialize identically but have different security properties? symmetric.rs:71-76",
    "Separator Length Limits: Are there any length limits on SEPARATOR strings? Could an attacker define a separator thousands of characters long, causing performance issues during serialization? symmetric.rs:54-68",
    "Separator Character Restrictions: Do the separators allow special characters or null bytes? Could an attacker craft a separator containing bincode delimiter characters that cause parsing ambiguities? symmetric.rs:54-68",
    "Tagged Trait Coherence: If multiple crates implement Tagged for the same type with different separators, could this lead to inconsistent domain separation across the system? symmetric.rs:54-68",
    "Tuple Separator Ordering: The MACTuple and NonceTuple put message separator first, then AD separator. If the order is reversed in calling code, could this break MAC verification? symmetric.rs:39-52",
    "Case Sensitivity in Separators: The separators are case-sensitive strings. Could an attacker exploit case variations (e.g., 'v0:Sym-Mac' vs 'v0:sym-mac') to bypass domain separation? symmetric.rs:54-68",
    "Separator Encoding: The separators are UTF-8 strings. Could an attacker use Unicode normalization or homoglyphs to create visually identical but cryptographically different separators? symmetric.rs:54-68",
    "Static Lifetime Requirement: The separators must be &'static str. Could this prevent dynamic separator generation based on runtime context (e.g., including account IDs), weakening separation? symmetric.rs:54-68",
    "Separator Collision Resistance: Are there any collision checks or uniqueness guarantees for separators across the entire codebase? Could duplicate separators in different modules cause security issues? symmetric.rs:54-68",
    "Public Visibility of Internal Types: The KDFPad, MACTuple, and NonceTuple structs are not pub, but their separators are accessible via the Tagged trait. Could external code misuse these separators? symmetric.rs:33-52",
    "Type Alias Security: The file defines type aliases Mac, Nonce, and Key as fixed-size byte arrays. Could calling code accidentally mix up these types (e.g., using a nonce as a key), bypassing type safety? symmetric.rs:17-19",

    # IV. Integration with Account, Backup & Association Systems (66–90)
    "Account Recovery Key Binding: When symmetric encryption is used to seal account recovery data (as seen in account/v0.rs), does the associated data properly bind the encrypted data to the specific account address, preventing replay across accounts? symmetric.rs:71-76",
    "Guardian Share Encryption: Backup shares are encrypted using seal. If a malicious guardian who hasn't reached the threshold t obtains multiple encrypted shares, could weaknesses in the symmetric scheme enable correlation attacks to identify other guardians? symmetric.rs:71-109",
    "Master Secret Key Storage: The account's Master Secret Key (MSK) is encrypted with symmetric encryption. If the encryption key is derived from user-controlled data, could an attacker brute-force weak keys to decrypt the MSK? symmetric.rs:71-109",
    "Email Certificate Binding: When encrypting association data (RIK), does the associated data include the email certificate to prevent an attacker from using the same encrypted RIK with a different email? symmetric.rs:75-76",
    "Off-Chain Node Secret Leakage: Off-chain nodes store encrypted shares from seal. If a minority of nodes are compromised and their full state (including keys used for symmetric encryption) is leaked, can the attacker decrypt shares for accounts they shouldn't access? symmetric.rs:71-109",
    "Cross-Account Ciphertext Replay: If two accounts use the same encryption key (e.g., derived from a common password), could an attacker copy a sealed ciphertext from one account and replay it in another account's recovery process? symmetric.rs:71-109",
    "Threshold Enforcement in Encryption: The symmetric scheme doesn't inherently enforce threshold t of n guardians. If calling code doesn't properly split and distribute shares before encrypting, could the entire secret be recoverable from a single encrypted blob? symmetric.rs:71-109",
    "Recovery Nonce Reuse: During account recovery, if the same plaintext (recovery data) is encrypted multiple times with the same key, does the synthetic nonce generation guarantee different ciphertexts, or could repeated recovery attempts leak information? symmetric.rs:81-89",
    "Association Privacy: The encrypted RIK (Recovery Identifier Key) is stored on-chain. Does the ciphertext length or structure leak information about the email address length or domain, potentially de-anonymizing users? symmetric.rs:22-26",
    "Backup Metadata Encryption: Backup metadata (guardian public keys, threshold) is encrypted. If an attacker tampers with the ciphertext, could MAC verification failure during recovery permanently lock the backup? symmetric.rs:118-129",
    "Guardian Public Key Binding: When encrypting shares destined for specific guardians, does the associated data include the guardian's public key to prevent misdirection of shares to the wrong guardian? symmetric.rs:75-76",
    "VDRF Share Encryption: The system uses VDRF for email-to-account association. If VDRF shares are encrypted with this symmetric scheme, could an attacker who compromises multiple off-chain nodes correlate encrypted shares to break anonymity? symmetric.rs:71-109",
    "PKE Integration: The pke/v0.rs module uses symmetric encryption internally. If the PKE scheme derives a shared secret that is then used as a symmetric key, could weak key derivation enable chosen-ciphertext attacks? symmetric.rs:71-109",
    "Dirty Account State: Account state can be 'dirty' (pending changes). If dirty state is encrypted but the encryption key is updated before committing, could decryption fail permanently, locking the account? symmetric.rs:112-149",
    "Multi-Email Recovery: Accounts can have multiple associated emails. If each email's recovery data is encrypted separately, could an attacker mix and match ciphertexts from different emails to forge a recovery request? symmetric.rs:71-109",
    "Guardian Approval Encryption: Guardian approvals are part of the recovery process. If approval signatures are encrypted, does the associated data bind the approval to the specific recovery request and account? symmetric.rs:75-76",
    "Share Reconstruction Ordering: When reconstructing a secret from encrypted shares, does the decryption order matter? Could an attacker force a specific decryption order to leak information via timing or error messages? symmetric.rs:112-149",
    "Encrypted Share Distribution: Shares are uploaded to off-chain nodes via HTTP endpoints. If an attacker intercepts encrypted shares in transit, could the symmetric scheme's properties prevent offline brute-force attacks? symmetric.rs:71-109",
    "Key Rotation: If an account owner wants to rotate encryption keys for backup shares, does the symmetric scheme support atomic key rotation, or could partial rotation leave some shares undecryptable? symmetric.rs:71-109",
    "Account Deletion: When an account is deleted, are all encrypted shares and recovery data properly removed? Could orphaned ciphertexts remain on-chain, leaking information about deleted accounts? symmetric.rs:71-109",
    "Guardian Revocation: If a guardian is revoked, their encrypted share should become unusable. Does the symmetric scheme allow selective share revocation without re-encrypting all shares? symmetric.rs:71-109",
    "Concurrent Recovery Attempts: If multiple recovery attempts occur concurrently for the same account, could race conditions in decrypting and verifying shares lead to incorrect state or leaked information? symmetric.rs:112-149",
    "Backup Version Migration: If the symmetric encryption scheme is upgraded (e.g., to v1), can old v0 ciphertexts be decrypted, or would this permanently lock old backups? symmetric.rs:54-68",
    "Certificate Expiry Impact: Email certificates have expiry times. If a certificate expires after sealing but before opening recovery data, could the decryption fail due to expired certificates in associated data? symmetric.rs:75-76",
    "Anonymous Recovery: The system aims to preserve anonymity during recovery. Does encrypting recovery data with this symmetric scheme prevent linking on-chain ciphertexts to specific email addresses? symmetric.rs:71-109",

    # V. Error Handling & Information Leakage (91–110)
    "Uniform Error Return: The open function returns SwafeError::DecryptionFailed for both MAC verification failures and deserialization errors. Could an attacker distinguish these cases via timing side channels? symmetric.rs:127-148",
    "MAC Verification Timing: The constant-time MAC comparison uses subtle::ConstantTimeEq. However, the check if mac_corr.ct_eq(&ct.mac).unwrap_u8() != 1 might not be constant-time for the branch. Could this leak information? symmetric.rs:127-129",
    "Deserialization Failure Details: When bincode::serde::decode_from_slice fails, the error is converted to SwafeError::DecryptionFailed without preserving the underlying cause. Could this hide important debugging information or enable silent failures? symmetric.rs:147",
    "Length Check Error Path: The check if n != pt.len() returns DecryptionFailed. Could an attacker craft ciphertexts where this check fails but MAC verification passes, leaking information about the deserialization process? symmetric.rs:141-142",
    "Error Propagation to Contracts: When open is called from contract HTTP endpoints, does the error propagate to the HTTP response? Could error messages leak information about which guardian shares failed to decrypt? symmetric.rs:128-129",
    "Panic vs Result: The seal function can panic on serialization failure (.unwrap()), while open returns Result. Could this inconsistency cause unexpected behavior in calling code? symmetric.rs:78",
    "Partial Decryption State: If open fails after decrypting but before deserialization, does the decrypted plaintext pt remain in memory? Could this leak sensitive data on failure paths? <cite repo=\"code-423n4/2025-",

    "Nonce Reuse Attack: In SigningKey::sign(), the nonce k is generated fresh each time v0.rs:94 . Can an attacker exploit scenarios where the same RNG state is reused across multiple signatures, allowing nonce extraction and private key recovery?",
    "Challenge Hash Mismatch: The sign() function uses pp::hash_to_fr() v0.rs:96-100 while verify() uses Fr::from_le_bytes_mod_order(&hash(...)) v0.rs:35-39 . Do these produce identical challenge values for the same inputs, or could this discrepancy allow forgery?",
    "Point-at-Infinity Exploitation: If an attacker submits a signature where r is the point at infinity in Signature, can the verification equation in verify() v0.rs:41-44 be satisfied trivially, bypassing authentication?",
    "Small Subgroup Attack on r: The verify() function checks [s]*G = R + [e]*PK v0.rs:41-44 but doesn't validate that r is in the prime-order subgroup. Can an attacker craft r in a small subgroup to forge signatures?",
    "Malleability of s: The Schnorr signature s = k + e*sk v0.rs:103 is computed over the scalar field. Can an attacker negate s or add multiples of the group order to create alternative valid signatures for the same message?",
    "Generator Consistency: Both sign() and verify() use pp::G1Projective::generator() v0.rs:42 v0.rs:95 . If the generator is not fixed or differs across contexts, could signatures verify incorrectly?",
    "Challenge Collision: If two different SchnorrHash inputs produce the same 32-byte hash output via SHA3-256, could an attacker create signature collisions? Are hash collisions feasible given the 256-bit output space?",
    "Public Key Validation Missing: The VerificationKey wraps a G1Affine point v0.rs:27-30 with no validation that it's in the correct subgroup. Can an attacker supply a low-order public key to create forged signatures?",
    "Zero Secret Key: If SigningKey::gen() produces sk = 0 due to RNG failure v0.rs:84 , the verification key becomes the identity point. Can this enable trivial signature forgery?",
    "Signature Component Ordering: The Signature struct serializes r then s v0.rs:18-24 . If deserialization reorders these fields, could swapped components still pass verification incorrectly?",
    "Domain Separation Vulnerability: The SchnorrHash struct uses the separator \"v0:schnorr\" v0.rs:77-79 . If another protocol component uses the same separator with compatible field types, could signed messages be interpreted as signatures elsewhere?",
    "Message Hash Precomputation: The message is hashed before inclusion in SchnorrHash v0.rs:38 v0.rs:99 . If the same message hash appears in different contexts, could cross-protocol replay attacks occur?",
    "Public Key Inclusion Order: The SchnorrHash includes pk after r v0.rs:70-75 . Could reordering these fields during serialization allow signature forgery if bincode encoding is position-dependent?",
    "Tagged Message Type Confusion: Since messages must implement Tagged, could an attacker craft a type with the same serialized bytes as a legitimate message but different semantics to repurpose signatures?",
    "Hash-to-Field Reduction: The verify() function reduces the hash via from_le_bytes_mod_order v0.rs:35 . Does this introduce bias that could weaken the signature scheme's security proof?",
    "Equality Check Timing: The verification succeeds if left == right v0.rs:45 . Is this comparison constant-time, or could timing side-channels leak information about the secret key or valid signatures?",
    "Affine Conversion Side-Channels: Both left and right are converted to affine form before comparison v0.rs:42-44 . Could the affine conversion leak timing information about point coordinates?",
    "Error Path Information Leakage: When verification fails, the function returns SwafeError::SignatureVerificationFailed v0.rs:48 . Could different failure paths (malformed signature vs. invalid signature) leak information to attackers?",
    "Point Decompression Vulnerabilities: If r in Signature is stored compressed, decompression errors during verification could cause crashes or expose which signatures are structurally valid before cryptographic checks.",
    "Batch Verification Absence: The system verifies signatures individually. If multiple signatures need verification in recovery flows, could the lack of batch verification enable performance-based DoS or make timing attacks easier?",
    "RNG Quality in gen(): The SigningKey::gen() function relies on the provided RNG v0.rs:83-90 . If a caller uses a weak or predictable RNG, can the secret key be brute-forced?",
    "Key Generation Bias: The secret key is generated via rng.gen() v0.rs:84 . Does this sample uniformly from the scalar field, or could bias enable key recovery attacks?",
    "Uninitialized Key Material: If the RNG fails silently and leaves secret_key uninitialized, could this lead to predictable keys or undefined behavior in subsequent operations?",
    "Seed Reuse Across Keys: If the same RNG seed is used to generate multiple SigningKey instances for different users, could this enable cross-user key recovery attacks?",
    "Deterministic Key Generation: The system doesn't appear to support deterministic key generation from seeds. Could the inability to reproduce keys from backups lead to account lockout scenarios?",
    "OnceCell Race Conditions: The verification_key() method uses OnceCell::get_or_init() v0.rs:109-111 . In concurrent scenarios, could multiple threads compute the verification key simultaneously, wasting resources or causing consistency issues?",
    "Cached Key Corruption: If the verification key is computed once and cached v0.rs:59 , but the secret key is modified via deserialization, could stale verification keys lead to signature verification failures?",
    "Cloning Verification Key: The cached verification key is cloned on each call v0.rs:111 . Could excessive cloning expose the key to memory leaks or side-channel attacks via memory access patterns?",
    "Verification Key Mismatch: If a SigningKey is deserialized without the cached verification key v0.rs:58-59 and later recomputed, could floating-point or encoding differences cause the derived key to differ from the original?",
    "Key Derivation Cost: Computing the verification key requires a scalar multiplication G * sk v0.rs:110 . If an attacker forces repeated deserialization, could the performance cost enable DoS on key operations?",
    "Incomplete Zeroization: The Drop implementation zeroizes sk v0.rs:63-66 , but the vk cache in OnceCell persists. Could the verification key leak information about the secret key after drop?",
    "Compiler Optimization Bypass: The manual zeroize() call v0.rs:65 may be optimized out by the compiler if it detects the value is never read afterward. Is this prevented by the zeroize crate's volatile writes?",
    "Copy-on-Write Exposure: If SigningKey is cloned, both the original and clone have independent sk fields but may share memory pages via copy-on-write. Could an attacker freeze memory before zeroization to recover keys?",
    "Serialization Key Leakage: The SigningKey derives Serialize v0.rs:54-60 . If serialized to disk or network, the secret key is exposed. Does the system prevent accidental serialization to untrusted destinations?",
    "Panic-Induced Memory Dumps: If a panic occurs before Drop is called, the secret key may remain in memory or core dumps. Could attackers trigger panics to extract keys from crash logs?",
    "Serde Skip Verification Key: The verification key has #[serde(skip)] v0.rs:58-59 , so it's not serialized. After deserialization, is the key recomputed correctly, or could mismatches cause verification failures?",
    "Secret Key Leakage via Debug: Although SigningKey doesn't derive Debug, the inner sk field does. Could attackers trigger debug logging in parent structures to leak keys?",
    "Swap Space Exposure: If the OS swaps memory to disk, secret keys may persist in swap files even after zeroization. Does the system use memory locking (mlock) to prevent this?",
    "Multi-threaded Zeroization: If a SigningKey is shared across threads via Arc and one thread drops it, could other threads still hold references to unzeroized memory?",
    "Partial Deserialization Leaks: If deserialization fails midway after reading sk but before constructing the OnceCell, could the secret key remain in the deserializer's buffer?",
    "G1 Compression Ambiguity: The Signature.r field uses G1 compressed serialization v0.rs:20-21 . Could attackers exploit sign ambiguity in compressed points to create multiple serializations of the same signature?",
    "Field Element Encoding: The s field uses Fr serialization v0.rs:22-23 . If the encoding is not canonical (e.g., multiple representations of the same scalar), could attackers bypass signature uniqueness checks?",
    "Deserialization Validation: When deserializing a Signature, are r and s validated to be in the correct algebraic structures, or could malformed values cause verification to panic or accept invalid signatures?",
    "Version Mismatch Handling: The parent module uses versioned enums mod.rs:7-11 . If a v1 signature is introduced later, could v0 signatures be misinterpreted as v1 due to missing version checks?",
    "Serialization Length Vulnerabilities: The G1 serialization expects 48 bytes. If an attacker provides fewer or more bytes, could buffer overflows or underflows occur during deserialization?",
    "Public Key Compression Side-Channels: The VerificationKey serializes as a compressed G1 point v0.rs:28-29 . Could the compression process leak information about the key via timing or power analysis?",
    "Identity Point as Public Key: If a VerificationKey is deserialized as the identity point (0), all signatures with s = k would verify. Does deserialization reject identity points?",
    "Canonical Encoding Enforcement: The system uses bincode for serialization. If bincode allows multiple valid encodings of the same VerificationKey, could attackers bypass deduplication or caching logic?",
    "Hash Collision via Key Encoding: VerificationKey derives Hash v0.rs:26 . If two different keys have the same hash due to encoding, could attackers exploit hash-based collections?",
    "Equality vs. Cryptographic Equivalence: VerificationKey derives Eq v0.rs:26 . If equality is based on serialized bytes rather than cryptographic equivalence, could equivalent keys (e.g., different curve representations) be treated as distinct?",
    "Accidental Secret Exposure: The SigningKey is marked Serialize v0.rs:54 , allowing the secret key to be serialized. Could developers accidentally log or transmit signing keys?",
    "Encrypted Storage Requirement: If signing keys are encrypted with RIK before storage (as per the association system), what happens if they're serialized unencrypted? Does the type system prevent this?",
    "Deserialization Injection: If an attacker intercepts serialized SigningKey data and injects a crafted secret key, could they impersonate users in recovery flows?",
    "Serde Skip Field Initialization: The vk field has #[serde(skip)] v0.rs:58-59 . After deserialization, does OnceCell default to empty, or could uninitialized memory cause issues?",
    "Partial Clone Security: If SigningKey::clone() is used, does the clone share the same OnceCell instance, or are they independent? Could shared caches leak information?",
    "Cross-Context Signature Reuse: The SchnorrHash type has a fixed separator v0.rs:77-79 . If messages from different contexts (account recovery, backup reconstruction) have the same fields, could signatures be replayed across contexts?",
    "Separator Collision: If another protocol component defines a Tagged type with the same separator \"v0:schnorr\", could signatures intended for one context verify in another?",
    "Message Field Ordering: The SchnorrHash struct fields are ordered r, pk, message v0.rs:70-75 . If bincode encodes fields positionally, could reordering in future versions break compatibility?",
    "Hash Output Truncation: The message hash is fixed at 32 bytes v0.rs:74 . If a future version uses larger hashes, could truncation to 32 bytes cause collisions?",
    "Domain Tuple Injection: The encode() method wraps values in a DomainTuple encode.rs:24-28 . Could attackers craft separators that collide with legitimate protocol separators to bypass domain separation?",
    "Single-Use Nonce Guarantee: In sign(), the nonce k is generated via rng.gen() v0.rs:94 . If the RNG state is not advanced properly, could the same nonce be reused, enabling private key extraction?",
    "Deterministic RNG in Tests: The test uses thread_rng() v0.rs:118 . If production code accidentally uses a seeded RNG, could nonces become predictable?",
    "Nonce Leakage via Side-Channels: The nonce k is used in a scalar multiplication G * k v0.rs:95 . Could timing, power, or cache side-channels leak k during this operation?",
    "Nonce Bias from RNG: If the RNG has statistical bias, could nonces cluster in a smaller space, enabling lattice attacks to recover the secret key from multiple signatures?",
    "RNG Failure Handling: If rng.gen() fails or panics, what happens to the partially constructed signature? Could incomplete signatures be leaked or cause crashes?",
    "Shared RNG State: If multiple SigningKey instances share the same RNG (e.g., via Arc<Mutex<Rng>>), could concurrent signing operations produce correlated nonces?",
    "Nonce Reuse Across Users: In a multi-user system, if the same RNG is used for all users without proper context separation, could nonce collisions across different users occur?",
    "Predictable RNG Seed: If the RNG is seeded with predictable data (e.g., current time with low precision), could attackers guess nonces and forge signatures?",
    "Insufficient Entropy: If the RNG draws from an entropy source with insufficient randomness, could nonces have low entropy, enabling brute-force nonce guessing?",
    "Nonce Size Validation: The nonce k is of type Fr. If Fr has a smaller bitsize than expected, could reduced nonce space enable birthday attacks on nonce collisions?",
    "Hash Function Weak Randomness: The challenge e is derived via hashing v0.rs:96-100 . If SHA3-256 is weakened in the future, could attackers find challenge collisions to forge signatures?",
    "Modular Reduction Bias: The from_le_bytes_mod_order reduces the hash modulo the field order v0.rs:35 . If the field order is close to 2^256, could bias enable statistical attacks?",
    "Challenge Precomputation: If r and pk are known before signing, could an attacker precompute challenges and search for favorable messages that produce weak challenges?",
    "Hash-to-Scalar Non-Uniformity: If hash_to_fr doesn't map uniformly to the scalar field, could certain challenges be more likely, reducing security?",
    "Truncation Weakness: If the hash is truncated (e.g., only lower bytes used), could truncation introduce patterns exploitable by attackers?",
    "RNG Type Bounds: The gen() and sign() functions require R: Rng + CryptoRng v0.rs:83 v0.rs:93 . Could callers provide a compliant but weak RNG (e.g., a PRNG with known state)?",
    "CryptoRng Marker Abuse: The CryptoRng trait is a marker with no methods. Could an attacker implement it for a weak RNG to bypass quality checks?",
    "RNG State Leak: If the RNG state is leaked via side-channels (e.g., memory dumps), could attackers predict future nonces and forge signatures?",
    "Fork Safety: If the process forks after initializing the RNG, could parent and child processes share the same RNG state, causing nonce reuse?",
    "Hardware RNG Failure: If the system relies on hardware RNGs (e.g., RDRAND) and they fail or are backdoored, could weak nonces compromise all signatures?",
    "Recovery Request Signature Binding: According to the search results, SigningKey is used to sign RecoveryRequestMessage. If the signature doesn't bind to the specific account contract address, could attackers replay recovery requests across accounts?",
    "RIK Decryption Attacks: The SigningKey is encrypted with the Recovery Initiation Key (RIK). If RIK decryption is compromised (e.g., weak password-based KDF), could attackers extract the signing key and authorize fake recoveries?",
    "Guardian Approval Bypass: Recovery requires guardian approval. If the signature verification in verify() v0.rs:34-50 has vulnerabilities, could attackers bypass guardian checks by forging signatures?",
    "Email Certificate Binding: The VerificationKey is stored in AssociationsV0.sig. If the key isn't cryptographically bound to the email certificate from Swafe-io, could attackers associate arbitrary keys with stolen emails?",
    "Signature Replay in Recovery: If a recovery request signature is accepted multiple times, could an attacker reuse a single valid signature to trigger multiple recoveries or drain accounts?",
    "Concurrent Recovery Races: If multiple recovery requests are initiated simultaneously with the same SigningKey, could race conditions in signature verification allow unauthorized parallel recoveries?",
    "Revocation Mechanism Absence: Once a VerificationKey is stored on-chain, there's no apparent revocation mechanism. If a SigningKey is compromised, can the user revoke the key to prevent unauthorized recovery?",
    "Key Rotation Gaps: If a user rotates their signing key during account lifecycle, could old signatures remain valid, allowing attackers who stole old keys to initiate recovery?",
    "Off-Chain Node Signature Verification: Off-chain nodes verify recovery signatures. If a minority of nodes are compromised and skip signature verification, could they collude with attackers to approve invalid recoveries?",
    "Email-to-Account Association Attack: If an attacker can forge a signature that verifies against a legitimate VerificationKey, could they claim ownership of another user's email-account association?",
    "Guardian Share Signature Validation: Each guardian share has an associated SigningKey. If the signature on the encrypted share isn't validated properly, could attackers inject malicious shares?",
    "Share Commitment Binding: The VerificationKey is stored in ShareComm.vk within backup ciphertexts. If the key isn't bound to the share's content, could attackers swap keys to redirect reconstruction?",
    "Threshold Bypass via Forgery: If an attacker can forge signatures for t-1 guardian shares, they could bypass the threshold requirement and reconstruct backups without sufficient guardian approval.",
    "Share Origin Authentication: Does the signature on guardian shares prove which guardian created the share, or only that someone with the signing key approved it? Could guardians repudiate shares they actually created?",
    "Replay Across Backups: If guardian share signatures don't bind to specific backup sessions or timestamps, could attackers replay old signed shares in new reconstruction attempts?",
    "Missing Share Signature: What happens if a guardian share is submitted without a signature? Could unsigned shares bypass security checks if validation is incomplete?",
    "Signature Verification Order: If shares are verified after decryption rather than before, could decryption failures leak information about share validity to attackers?",
    "Cross-Backup Share Reuse: If the same SigningKey is used across multiple backups, could shares from one backup be replayed in another backup's reconstruction?",
    "Guardian Compromise Escalation: If fewer than t guardians' signing keys are compromised, what prevents attackers from combining their forged signatures with legitimate shares to reach the threshold?",
    "Honest Guardian Signature Theft: If an attacker intercepts a legitimate guardian's signed share, could they reuse it in unauthorized reconstruction attempts?",
    "Email Privacy via Signature: The association system uses VDRF to hide email-to-account mappings. If the VerificationKey is stored on-chain in plaintext, could attackers link accounts to users by correlating keys across contexts?",
    "VDRF Output Binding: If the SigningKey is derived from or used alongside VDRF outputs, could weaknesses in the signature scheme leak information about the VDRF secret shares?",
    "Certificate Signature Verification: Email certificates from Swafe-io must be verified. If the system reuses the Schnorr signature implementation for certificate verification, could vulnerabilities affect certificate validation?",
    "Association Creation Signature: When adding an association, is the SigningKey generation authenticated by a signature from the account owner? Could attackers inject unauthorized associations?",
    "Multi-Association Key Reuse: An account may have multiple email associations. If the same SigningKey is reused across associations, could compromising one key expose all associations?",
    "Association Removal Authorization: Does removing an association require a signature? If not, could attackers with partial account access remove legitimate associations to deny recovery?",
    "Email Certificate Replay: If email certificates are signed using this Schnorr implementation, could attackers replay certificates across accounts to claim multiple identities?",
    "Anonymous Recovery Signature Leak: During anonymous recovery, does signing the recovery request leak which association is being used, violating privacy guarantees?",
    "Off-Chain Node Signature Exposure: Off-chain nodes hold VDRF shares. If they also verify recovery signatures, could timing differences in verification leak information about valid associations?",
    "Association Signature Timestamp: If recovery signatures don't include timestamps or nonces, could attackers use expired certificates or associations to initiate recovery?",
    "Scalar Multiplication Timing: Both signing v0.rs:95 and verification v0.rs:42-44 perform scalar multiplications. Are these constant-time operations, or could timing differences leak secret key bits?",
    "Verification Equation Timing: The equality check in verify() v0.rs:45 may short-circuit. Could early termination leak information about which bit positions differ, aiding in forgery?",
    "Hash Computation Timing: Hashing the message and computing the challenge v0.rs:35-39 v0.rs:96-100 may have message-length-dependent timing. Could this leak information about message content?",
    "Point Affine Conversion Timing: Converting projective points to affine form v0.rs:42-44 involves an inversion. Could timing variations in inversion leak coordinate information?",
    "RNG Generation Timing: Generating the nonce k v0.rs:94 may have variable timing. Could this leak entropy or RNG state to remote attackers?",
    "Deserialization Timing: Deserializing signatures or keys may have timing side-channels. Could attackers measure deserialization time to infer structural properties of keys or signatures?",
    "Branch-Based Timing Leaks: If the verification logic contains conditional branches based on secret values, could branch prediction side-channels leak information?",
    "Cache Timing in Scalar Mult: Scalar multiplication may use lookup tables. Could cache-timing attacks (e.g., Flush+Reload) leak nonce or secret key bits?",
    "Network Timing: If signature verification happens on-chain or via off-chain nodes, could network timing variations leak whether signatures are valid or which keys were used?",
    "Verification Key Cache Timing: The OnceCell cache v0.rs:109-111 causes timing differences between first access (computes key) and subsequent accesses (returns cached). Could this leak usage patterns?",
    "Power Analysis on Signing: The signing operation v0.rs:93-105 involves scalar multiplications and field operations. Could power analysis on IoT or embedded devices leak the secret key?",
    "EM Radiation from Scalar Mult: Electromagnetic radiation during G * k and G * sk operations could leak hamming weights of secrets. Are countermeasures like blinding used?",
    "Power Traces on Verification: Although verification is public-key operation, power traces could reveal which public keys are frequently verified, leaking usage patterns.",
    "EM Side-Channels on Cache: If the verification key cache is accessed, EM radiation from memory reads could distinguish cache hits from misses, leaking key usage.",
    "Power-Based Nonce Recovery: If the nonce generation process leaks via power consumption, could attackers extract k from a single signature and derive the secret key?",
    "Memory Residue After Zeroization: Even after zeroize() v0.rs:65 , memory pages may retain residual magnetic traces. Could cold-boot attacks recover keys from DRAM?",
    "Swap File Persistence: If secret keys are swapped to disk, zeroization doesn't affect swap files. Could attackers extract keys from hibernation files or swap partitions?",
    "Heap Fragmentation Leaks: If signing keys are allocated and deallocated repeatedly, heap fragmentation could leave copies in different memory locations. Could attackers scan heap for unzeroized copies?",
    "Memory Duplication via Fork: If the process forks, child processes inherit memory. Could child processes access parent's signing keys before they're zeroized?",
    "Speculative Execution Leaks: Could Spectre/Meltdown-style attacks leak secret key material from speculative execution of scalar multiplication operations?",
    "Verification Error Ambiguity: The error SignatureVerificationFailed v0.rs:48 doesn't distinguish between malformed signatures and cryptographically invalid ones. Could this ambiguity be exploited?",
    "Silent Failure on Deserialization: If deserializing a SigningKey fails but error handling is missing, could partially deserialized keys be used, causing undefined behavior?",
    "Panic on Invalid Points: If r in a signature is an invalid curve point, could deserialization panic instead of returning an error, enabling DoS?",
    "Verification Panic on Edge Cases: Could edge cases like infinity points or zero scalars cause verify() to panic rather than return an error?",
    "RNG Failure Silent Propagation: If rng.gen() fails in sign(), the error might not propagate correctly. Could this lead to signatures with weak nonces?",
    "Hash Function Failure: If the hash function panics (e.g., due to resource exhaustion), could this leave the system in an inconsistent state?",
    "Serialization Error Leakage: If serialization fails, do error messages leak information about the secret key structure or values?",
    "Affine Conversion Errors: If converting to affine form fails due to point-at-infinity, does the code handle this gracefully or panic?",
    "Modular Reduction Overflow: If from_le_bytes_mod_order overflows or wraps, could this produce invalid challenges?",
    "OnceCell Initialization Panic: If initializing the OnceCell panics v0.rs:109-111 , could the verification key be left in an inconsistent state?",
    "Trait Bound Violations: If a type implements Tagged but produces non-injective encodings, could different values hash to the same challenge?",
    "Serde Deserialization Assumptions: If serde's derive macros make assumptions about field ordering, could manual deserialization bypass security checks?",
    "ZeroizeOnDrop Bypass: The VerificationKey derives ZeroizeOnDrop v0.rs:26 , but it's a public key. Could unnecessary zeroization cause performance issues or hide bugs?",
    "Hash Trait on VerificationKey: VerificationKey derives Hash v0.rs:26 . If hash collisions occur, could HashMap-based storage corrupt verification key lookups?",
    "Clone on SigningKey: SigningKey derives Clone v0.rs:54 . Does cloning duplicate the secret key in memory before the original is zeroized?",
    "Debug Trait Absence: Although SigningKey avoids deriving Debug, could surrounding types with Debug leak sensitive fields indirectly?",

    "Tag Collision Attack: Can an attacker craft a serialized payload where the u8 tag value collides between different enum variants across multiple uses of versioned_enum! in the codebase (e.g., AccountState::V0 tag 0 vs BackupCiphertext::V0 tag 0), potentially causing type confusion during deserialization? venum.rs:61-78",
    "Tag Range Enforcement: The compile-time check enforces tags < 128, but can an attacker bypass this by manually crafting bincode with tags >= 128 in the serialized stream to cause undefined behavior during deserialization? venum.rs:34-49",
    "Cross-Enum Tag Reuse: Since different enums generated by the macro can use the same tag value (e.g., all V0 variants use tag 0), can an attacker substitute a GuardianShare::V0 serialization for an AccountState::V0 where both use tag 0, potentially bypassing authorization checks? venum.rs:103-113",
    "Missing Duplicate Tag Detection: The macro doesn't validate that tag values are unique within a single enum definition. Can a developer accidentally define two variants with the same tag (e.g., V0(Type1) = 0, V1(Type2) = 0), causing deserialization ambiguity? venum.rs:28-59",
    "Tag Overflow During Compilation: The compile-time panic check uses if $value >= 128, but can integer overflow during macro expansion cause the check to pass incorrectly for very large constants? venum.rs:38-46",
    "Invalid Tag Error Handling: When deserializing with an invalid tag, the error message is generic 'invalid enum variant'. Can this leak information about which versioned enum failed, allowing an attacker to fingerprint the system's internal state? venum.rs:111",
    "Tag Downgrade Attack: Can an attacker intercept a newer versioned enum (e.g., AccountState::V1) and modify the tag to an older version (V0) to exploit deprecated logic or bypass new security checks? venum.rs:100-112",
    "Tag Injection in Tuple Serialization: The serialization format is a tuple (tag, data). Can an attacker inject malicious data where the inner type also contains a tuple structure, causing nested tag confusion? venum.rs:70-73",
    "Missing Tag Monotonicity: There's no requirement that tag values increase monotonically (e.g., V0=5, V1=2, V2=10 is allowed). Can this cause forward compatibility issues where newer code misinterprets older data? venum.rs:28-59",
    "Tag Exhaustion Attack: With only 128 possible tag values (0-127), can an attacker force the system to exhaust available tags over time, preventing future version upgrades? venum.rs:38",
    "Cross-Version Tag Collision: When adding new variants to an existing enum, can a developer accidentally reuse a tag value that was previously used but removed, breaking backward compatibility? venum.rs:103-112",
    "Tag Context Binding: Tags are not cryptographically bound to the enum type. Can an attacker exploit this to substitute serialized data between different enum types in critical operations like account recovery or backup reconstruction? venum.rs:61-78",
    "Tag Verification in Batch Operations: For BatchCiphertext which contains multiple ciphertexts, are all inner tags validated consistently, or can an attacker mix tags to cause selective decryption failures? venum.rs:80-117",
    "Tag Manipulation in Signatures: When a Signature enum is serialized for verification, can an attacker modify the tag to point to a different signature algorithm, bypassing cryptographic verification? venum.rs:61-78",
    "Missing Tag Canonicalization: The macro doesn't enforce canonical encoding of tags. Can an attacker encode the same tag value in multiple ways (e.g., with leading zeros) to create distinct but equivalent serializations? venum.rs:71",
    "Tag Size Assumption: The code assumes u8 tags serialize as single bytes. Can changes in bincode configuration cause multi-byte tag encoding, breaking the < 128 assumption? venum.rs:71",
    "Tag Ordering in Deserialization: The match statement on tags uses a specific order. Can the compiler optimize this in ways that introduce timing side-channels revealing which variant was deserialized? venum.rs:103-112",
    "Tag Validation Bypass via Raw Bytes: If raw bytes are directly cast to a versioned enum (bypassing serde), can an attacker inject arbitrary tags that violate the < 128 constraint? venum.rs:80-117",
    "Tag Consistency Across Network: When versioned enums are transmitted between off-chain nodes and smart contracts, can tag inconsistencies between different deployments cause authentication failures? venum.rs:61-78",
    "Tag Forgery in Email Certificates: The EmailCertificate likely uses versioned enums. Can an attacker forge tags to associate arbitrary emails with accounts, violating the 'email-to-account uniqueness' invariant? venum.rs:28-119",
    "Tag Preservation in State Transitions: When AccountState transitions via AccountUpdate, are tags preserved correctly, or can an attacker inject mismatched tags to corrupt account state? venum.rs:61-78",
    "Tag Leakage via Error Messages: When deserialization fails due to invalid tags, do error messages reveal sensitive information about the expected enum structure or internal state? venum.rs:111",
    "Tag Replay in Guardian Shares: Can an attacker replay old GuardianShare messages with modified tags to bypass approval checks during account recovery? venum.rs:80-117",
    "Tag-Based Version Downgrade in Backups: Can an attacker modify backup ciphertext tags to force older decryption logic, potentially bypassing guardian threshold requirements? venum.rs:103-112",
    "Tag Injection in Association Records: For MskRecord and Association enums, can tag manipulation allow unauthorized reconstruction of Recovery Initiation Keys (RIKs), violating account owner exclusivity? venum.rs:61-78",

    # Category 2
    "Tuple Serialization Ambiguity: The macro serializes as (tag, data) tuple. Can an attacker craft data where the inner type also starts with a u8, causing the deserializer to misparse the tag boundary? venum.rs:66-77",
    "Length Prefix Manipulation: Bincode includes length prefixes for variable-length types. Can an attacker manipulate these to cause buffer overflows or out-of-bounds reads during deserialization of large variant data? venum.rs:80-117",
    "Nested Versioned Enum Confusion: When versioned enums contain other versioned enums (e.g., AccountState contains Ciphertext), can tag nesting create ambiguity where inner tags are mistaken for outer tags? venum.rs:61-78",
    "Bincode Configuration Mismatch: The macro uses default bincode serialization, but encode.rs defines a custom BINCODE_CONFIG. Can this mismatch cause deserialization failures or security vulnerabilities? venum.rs:61-78",
    "Variable-Length Encoding Attack: For enum variants containing Vec<u8> or String, can an attacker inject enormous length values to cause denial-of-service or memory exhaustion during deserialization? venum.rs:96-113",
    "Serialization Padding Bits: Does bincode introduce padding between the tag byte and variant data? Can an attacker exploit uninitialized padding to leak sensitive information? venum.rs:70-73",
    "Tuple Element Ordering: The serialization order is hardcoded as tag-first. If bincode's tuple ordering changes in future versions, can this break deserialization of stored data? venum.rs:70-73",
    "Missing Serialization Bounds Checks: When serializing variant data, are there checks to ensure the data doesn't exceed reasonable size limits, preventing resource exhaustion attacks? venum.rs:61-78",
    "Deserialization of Untrusted Input: The visit_seq method deserializes arbitrary input. Can an attacker provide malicious sequences that exploit vulnerabilities in the inner type's deserializer? venum.rs:96-113",
    "Trailing Data Exploitation: After deserializing the tuple, is trailing data validated or ignored? Can an attacker append malicious data that's processed by subsequent operations? venum.rs:116-117",
    "Type Confusion via Serde: Since the macro implements Serialize/Deserialize, can an attacker exploit serde's type system to deserialize versioned enums as incompatible types? venum.rs:80-118",
    "Enum Representation Assumption: The macro assumes #[repr(u8)] doesn't affect serialization, only memory layout. Can this assumption break if Rust's enum representation changes? venum.rs:51-59",
    "Serialization Interoperability: When versioned enums are transmitted between Rust nodes and Partisia smart contracts, can serialization format differences cause authentication or validation failures? venum.rs:61-78",
    "Circular Reference Handling: If variant data contains references back to the parent enum, can this cause infinite recursion during serialization? venum.rs:61-78",
    "JSON vs Bincode Confusion: The tests use both JSON and bincode serialization. Can an attacker exploit differences between these formats to create valid JSON that deserializes incorrectly via bincode? venum.rs:163-170",
    "Bincode Version Dependency: The code depends on a specific bincode version. Can future bincode updates introduce breaking changes that compromise the security of stored versioned enums? venum.rs:61-78",
    "Serialization Determinism: Is the serialization output deterministic for the same input? Non-determinism could break cryptographic signatures or commitments that depend on serialized data. venum.rs:61-78",
    "Deserialization Stack Depth: For deeply nested versioned enums, can an attacker trigger stack overflow by providing extremely nested structures? venum.rs:96-113",
    "Zero-Sized Variant Data: Can variants with zero-sized types (like () or empty structs) cause serialization/deserialization bugs or be exploited to create malformed messages? venum.rs:66-77",
    "Serialization of Cryptographic Material: When versioned enums contain sensitive keys or secrets, does serialization expose them to timing side-channels or memory leaks? venum.rs:61-78",
    "Deserialization Panic Safety: If deserialization of the inner type panics, can this leave the system in an inconsistent state or leak partially deserialized data? venum.rs:96-113",
    "Tuple Size Mismatch: The code expects exactly 2 tuple elements (tag and data). Can an attacker provide 1 or 3+ elements to trigger unexpected behavior? venum.rs:116",
    "Serialization of Large Enums: The macro allows #[allow(clippy::large_enum_variant)]. Can very large variants cause performance issues or memory exhaustion during serialization? venum.rs:53",
    "Format String Vulnerabilities: The expecting method returns a hardcoded string. Can this be exploited if the string is ever used in unsafe contexts? venum.rs:92-94",
    "Missing Integrity Checks: Serialized versioned enums lack built-in integrity checks (like checksums or MACs). Can an attacker modify serialized data undetected, especially for critical types like GuardianShare or BackupCiphertext? venum.rs:61-78",

    # Category 3
    "Forward Compatibility Breaking: The test forward_compatibility_deserialize_old_variant_with_new_enum shows old variants deserializing with new enums. Can this be exploited to bypass new security checks by using old variant serializations? venum.rs:240-272",
    "Removed Variant Attack: Test shows removed variants cause deserialization errors. Can an attacker force errors by presenting old variants, potentially locking users out of their accounts if old AccountState versions become unreadable? venum.rs:316-323",
    "Version Skipping: Can an attacker skip intermediate versions (e.g., serialize as V0, deserialize expecting V2) to bypass migration logic or security improvements? venum.rs:240-272",
    "Backward Incompatible Changes: If a variant's inner type changes incompatibly between versions (e.g., V0(OldType) → V0(NewType)), can this cause silent data corruption during deserialization? venum.rs:28-59",
    "Missing Migration Path: There's no built-in mechanism to migrate data from old to new versions. Can this cause permanent data loss if old variants become deprecated? venum.rs:240-272",
    "Version Rollback Attack: Can an attacker force the system to roll back to an older version by providing old-format data, potentially reintroducing fixed vulnerabilities? venum.rs:240-272",
    "Partial Version Support: If different nodes support different version ranges, can this cause consensus failures or allow attackers to exploit version-specific vulnerabilities? venum.rs:28-119",
    "Version Detection Bypass: There's no mechanism to detect which version an enum is before deserializing. Can this cause security checks to be applied to the wrong version? venum.rs:80-117",
    "Type Evolution Without Tag Change: Can a developer change a variant's inner type without changing its tag, causing silent deserialization failures or data corruption? venum.rs:28-59",
    "Missing Version Documentation: Tags are just numbers with no semantic versioning information. Can this cause confusion about which version introduced security fixes? venum.rs:28-59",
    "Cross-Contract Version Mismatch: When versioned enums are stored on-chain and accessed by different contracts with different version support, can this cause state inconsistencies? venum.rs:61-78",
    "Version Exhaustion: With 128 possible versions, can the protocol run out of version space for critical enums like AccountState or BackupCiphertext? venum.rs:38",
    "Version Semantic Confusion: Nothing prevents using tags non-sequentially (e.g., V0=10, V1=5). Can this cause confusion about which version is 'newer' or 'more secure'? venum.rs:28-59",
    "Emergency Version Revocation: If a version is found vulnerable, there's no mechanism to revoke it. Can attackers continue exploiting old versions indefinitely? venum.rs:28-119",
    "Version Compatibility Matrix: With multiple versioned enums (accounts, backups, associations), can incompatible version combinations cause security vulnerabilities? venum.rs:28-119",
    "Version Upgrade Race Conditions: During a version upgrade, can an attacker exploit race conditions where some components use old versions and others use new versions? venum.rs:61-78",
    "Deprecated Version Persistence: Old versions in storage (e.g., BackupCiphertext::V0) never expire. Can this allow attackers to exploit deprecated cryptographic schemes indefinitely? venum.rs:240-272",
    "Version-Specific Vulnerabilities: If V0 of an enum has a vulnerability fixed in V1, can an attacker force use of V0 to exploit it? venum.rs:103-112",
    "Missing Version Monotonicity Enforcement: Nothing prevents adding a V0 variant after V1 already exists. Can this cause confusion or security issues? venum.rs:28-59",
    "Version Compatibility Testing Gaps: Tests only cover forward compatibility for adding new variants, not for modifying existing ones. Can untested migration paths introduce vulnerabilities? venum.rs:240-324",
    "Version Information Leakage: Error messages when deserializing invalid versions could leak information about which versions the system supports, aiding attackers. venum.rs:111",
    "Version Pinning Attack: Can an attacker pin a user's data to an old version, preventing them from benefiting from security improvements in newer versions? venum.rs:240-272",
    "Version Metadata Missing: No metadata about version release dates, security fixes, or breaking changes is encoded. Can this make incident response difficult? venum.rs:28-59",
    "Cross-Module Version Dependencies: If AccountState::V1 requires BackupCiphertext::V1, how is this enforced? Can version mismatches cause security issues? venum.rs:28-119",
    "Version Aliasing: Can two different enum types use the same internal versioning scheme, causing confusion or allowing one to be deserialized as the other? venum.rs:28-119",

    # Category 4
    "Key Type Confusion: EncryptionKey, DecryptionKey, SigningKey, and VerificationKey all use versioned_enum!. Can an attacker substitute one key type for another (e.g., sign with an encryption key) to bypass authentication? venum.rs:28-119",
    "Ciphertext Malleability: Versioned Ciphertext and BatchCiphertext enums lack built-in authentication. Can an attacker modify serialized ciphertexts to maul encrypted backups or recovery data? venum.rs:61-78",
    "Signature Scheme Substitution: Multiple signature schemes could be supported via different variants. Can an attacker downgrade to a weaker scheme by modifying the tag? venum.rs:103-112",
    "Guardian Share Tampering: GuardianShare is versioned without inherent authentication. Can a malicious guardian (below threshold) modify shares to corrupt backup reconstruction? venum.rs:61-78",
    "Secret Share Type Confusion: SecretShare can contain different share types. Can an attacker substitute Shamir shares for Pedersen commitments or vice versa to bypass verification? venum.rs:61-78",
    "Backup Ciphertext Binding: Versioned BackupCiphertext must be bound to BackupId. Can deserialization bypass this binding, allowing backup theft or replay attacks? venum.rs:61-78",
    "Account State Integrity: AccountState transitions must preserve cryptographic invariants. Can version changes during serialization/deserialization bypass integrity checks? venum.rs:61-78",
    "Association Record Authenticity: MskRecord and Association contain sensitive MSK data. Does versioning preserve authenticity, or can deserialization bypass signature verification? venum.rs:61-78",
    "Batch Ciphertext Atomicity: BatchCiphertext must maintain all-or-nothing decryption semantics. Can version manipulation break this atomicity, allowing selective share disclosure? venum.rs:61-78",
    "Recovery Initiation Key Protection: RIKs are likely stored in versioned enums. Can deserialization expose RIKs in memory longer than necessary, creating side-channel vulnerabilities? venum.rs:96-113",
    "Master Secret Key Leakage: MSKs in Association enums must be zeroized after use. Does the macro's deserialization ensure proper cleanup on error? venum.rs:96-113",
    "Threshold Security Violation: Versioned enums used in threshold cryptography (Shamir secret sharing) must preserve the threshold property. Can version mismatch reduce the effective threshold? venum.rs:28-119",
    "Email Certificate Binding: Email certificates must be bound to accounts. Can versioned enum deserialization allow certificate reuse across multiple accounts? venum.rs:61-78",
    "Commitment Verification Bypass: Pedersen commitments in backups must be verified. Can version manipulation skip verification steps during deserialization? venum.rs:96-113",
    "VDRF Output Integrity: VDRF outputs for email anonymization are likely versioned. Can deserialization corrupt VDRF proofs, violating email privacy? venum.rs:61-78",
    "Key Derivation Context Loss: If versioned enums are used in key derivation (e.g., via Tagged trait), can context be lost during serialization, weakening key isolation? venum.rs:61-78",
    "Symmetric Key Confusion: Different symmetric encryption schemes might use versioned wrappers. Can an attacker substitute AES for ChaCha to exploit implementation differences? venum.rs:103-112",
    "Nonce Reuse via Version Rollback: If cryptographic nonces are versioned, can rollback attacks cause nonce reuse, breaking encryption security? venum.rs:240-272",
    "Randomness Source Versioning: If RNG state is versioned, can an attacker force use of a weaker randomness source by manipulating versions? venum.rs:103-112",
    "Curve Parameter Substitution: If different elliptic curves are supported via versions, can an attacker force use of weak curves? venum.rs:103-112",
    "Hash Function Downgrade: If hash functions are versioned, can an attacker force MD5 or SHA-1 by modifying version tags, enabling collision attacks? venum.rs:103-112",
    "Zero-Knowledge Proof Versioning: If ZK proofs are versioned, can version manipulation bypass soundness checks or allow proof forgery? venum.rs:61-78",
    "Side-Channel Resistance: Does the deserialization path for cryptographic types (keys, signatures) have constant-time properties, or can timing attacks leak version information? venum.rs:96-113",
    "Cryptographic Agility Misuse: Supporting multiple cryptographic schemes via versioning is 'crypto agility'. Can this be exploited to downgrade security or create cross-scheme attacks? venum.rs:28-119",
    "Key Compromise via Version Information: Can error messages or deserialization behavior leak information about which cryptographic schemes are in use, aiding attackers in choosing exploits? venum.rs:111",

    # Category 5
    "Unauthorized Account Recovery: AccountState and AccountUpdate are versioned. Can an attacker manipulate versions to bypass guardian approval requirements during account recovery? venum.rs:61-78",
    "Backup Reconstruction Bypass: BackupCiphertext versioning must preserve the invariant 'only owner can reconstruct backups'. Can version manipulation allow unauthorized reconstruction? venum.rs:61-78",
    "Guardian Threshold Reduction: If guardian threshold is encoded in versioned structures, can an attacker reduce the threshold by downgrading versions, allowing recovery with fewer guardians? venum.rs:103-112",
    "Email Verification Bypass: Email certificates are likely versioned. Can deserialization skip email ownership verification, allowing unauthorized account recovery? venum.rs:96-113",
    "Association Uniqueness Violation: The invariant 'email-to-account bindings are unique' must be enforced. Can versioned Association enums be exploited to bind one email to multiple accounts? venum.rs:61-78",
    "Recovery Initiation Key Theft: RIKs in Association data must only be accessible to account owners. Can deserialization expose RIKs to unauthorized parties? venum.rs:96-113",
    "Backup Ciphertext Replay: Can an attacker replay old BackupCiphertext serializations to restore accounts to previous states, potentially reverting ownership changes? venum.rs:61-78",
    "Guardian Share Forgery: Malicious guardians (below threshold) might attempt to forge GuardianShare messages. Does versioning provide any protection against forgery? venum.rs:61-78",
    "Account State Rollback: If AccountState can be deserialized from old versions, can an attacker roll back account state to re-enable removed associations or backups? venum.rs:240-272",
    "Dirty State Persistence: Account state may have 'dirty' fields that should be cleared on update. Can version manipulation prevent proper clearing, leaking old secrets? venum.rs:61-78",
    "Recovery Secret Exposure: RecoverySecrets likely contain sensitive data. Does deserialization ensure secrets are properly protected in memory? venum.rs:96-113",
    "Backup Metadata Manipulation: Backup metadata (name, description) is stored with ciphertexts. Can version manipulation allow metadata tampering that misleads users during recovery? venum.rs:61-78",
    "Multiple Email Recovery Bypass: The invariant allows 'multiple emails associated for recovery'. Can version confusion allow recovery with emails not actually associated with the account? venum.rs:96-113",
    "Off-Chain Node Minority Attack: With minority of off-chain nodes corrupted, can they exploit version manipulation to leak email addresses during association or recovery? venum.rs:61-78",

    # I. Domain Separation Security (Tagged Trait) - Questions 1-25
    "SEPARATOR Collision Attack: Does the Tagged::encode() method encode.rs:20-37 guarantee that two different types implementing Tagged with identical SEPARATOR values cannot produce colliding encodings? Could an attacker craft types with duplicate separators to forge signatures or commitments across different cryptographic domains?",
    "Empty SEPARATOR Bypass: Can a malicious implementation provide an empty string as SEPARATOR encode.rs:9 to bypass domain separation entirely, allowing cross-domain signature reuse that could enable unauthorized account recovery?",
    "SEPARATOR Collision in EmailInput vs AccountId: If EmailInput and AccountId accidentally use the same SEPARATOR value, could an attacker substitute one for the other in cryptographic operations, violating the invariant that 'an email should be associated to at most one account at a time' README.md:142 ?",
    "Version Prefix Bypass: The SEPARATOR convention uses 'v0:' prefixes. Could an attacker create a type with separator 'v0:account-idv0:backup' that collides with concatenated encodings, breaking the injectivity claim encode.rs:13-15 ?",
    "SEPARATOR Length Field Manipulation: Since bincode encodes strings with a variable-length field encode.rs:17-19, could an attacker craft a SEPARATOR that, when var-encoded, produces a length field that overlaps with the actual data, breaking domain separation guarantees?",
    "Non-Injective Encoding Attack: The Tagged::encode() method claims to be injective encode.rs:13-15. Can two different Tagged values produce identical byte encodings? If so, this could enable signature forgery or commitment collision attacks.",
    "DomainTuple Struct Ordering: The DomainTuple struct orders fields as (sep, val) encode.rs:25-28. Could reversing this order to (val, sep) in a malicious implementation allow encoding collisions that break cryptographic domain separation?",
    "Bincode Variable-Length Encoding: Bincode uses variable-length encoding for integers and strings encode.rs:17-19. Could specially crafted SEPARATOR values exploit this to create ambiguous encodings where the separator boundary is unclear?",
    "Zero-Length Value Collision: If two Tagged types have different SEPARATOR values but serialize to zero-length data, could their encodings collide in hash-based operations, enabling cross-domain attacks?",
    "Unwrap Panic in Tagged::encode(): The encode() method uses .unwrap() encode.rs:36 on bincode serialization. Could a malicious Serialize implementation cause a panic here, leading to a denial-of-service during critical operations like guardian approval or backup reconstruction?",
    "Signature Scheme Cross-Domain Reuse: If ShareHash and BackupCiphertext use similar SEPARATOR values, could a signature over a ShareHash be replayed as a signature over BackupCiphertext, bypassing guardian approval for backup reconstruction?",
    "Commitment Scheme Domain Confusion: Could an attacker reuse a Pedersen commitment created for email association as a commitment for backup verification, violating the invariant that 'only the owner of an email should be able to request the recovery of an account' README.md:138 ?",
    "VDRF Domain Separation Failure: If VDRF evaluation uses Tagged::encode() for input hashing, could an attacker craft inputs that collide across different VDRF contexts, enabling email-to-account association privacy violations?",
    "Hash Function Domain Mixing: When cryptographic hashes use Tagged::encode() for input, could identical data with different SEPARATOR values hash to predictable or related outputs, weakening privacy guarantees?",
    "MAC Authentication Domain Bypass: If authenticated encryption uses Tagged::encode() for additional authenticated data (AAD), could SEPARATOR collisions enable MAC forgery across different encryption contexts?",
    "Version Downgrade Attack: The 'v0:' prefix in SEPARATOR values suggests versioning. Could an attacker force deserialization of newer versioned data as v0 types, bypassing security checks introduced in later versions?",
    "Forward Compatibility Exploitation: If v1 types are introduced, could old code deserializing v0 data accept v1 encodings, leading to type confusion vulnerabilities that enable unauthorized account recovery?",
    "Version Separator Collision: Could 'v0:backup' and 'v1:backup' have overlapping encodings in certain edge cases, enabling version confusion attacks?",
    "Mixed Version Attack: If an account uses v0 backups but recovers with v1 logic, could an attacker exploit encoding differences to reconstruct backups without proper guardian approval?",
    "Version Migration State Corruption: During a hypothetical migration from v0 to v1 separators, could partially migrated state allow SEPARATOR collisions that enable unauthorized access?",
    "SEPARATOR Runtime Modification: Although SEPARATOR is a const encode.rs:9, could unsafe code or trait implementation tricks modify it at runtime, enabling dynamic domain separation bypass?",
    "Generic Type Parameter Confusion: If Tagged is implemented for generic types with different type parameters, could SEPARATOR values fail to distinguish between instantiations, enabling type confusion?",
    "Lifetime Parameter Encoding Gaps: Could lifetime parameters in Tagged implementations affect domain separation, where Foo<'a> and Foo<'b> have the same SEPARATOR but different security properties?",
    "Associated Type Domain Separation: If Tagged types have associated types with different security requirements, does the SEPARATOR adequately distinguish between them?",
    "Trait Object Domain Confusion: If Tagged is used via trait objects (&dyn Tagged), could dynamic dispatch enable SEPARATOR confusion when deserializing, allowing type substitution attacks?",

    # II. Binary Serialization Vulnerabilities - Questions 26-50
    "Type Substitution Attack in deserialize(): The deserialize::<T>() function encode.rs:62-74 uses bincode without explicit type verification. Could an attacker deserialize MasterSecretKey bytes as AccountId, bypassing authorization checks for backup reconstruction?",
    "Enum Variant Confusion: If versioned enums are serialized, could an attacker craft bytes that deserialize as a different variant, enabling state corruption?",
    "Struct Field Reordering Attack: If a struct's field order changes between versions, could old serialized data deserialize with fields swapped, corrupting critical state like guardian thresholds?",
    "Option None vs Some Confusion: Could maliciously crafted bytes cause Option::None to deserialize as Option::Some(attacker_data), bypassing validation checks?",
    "Vec Length Exploitation: Bincode encodes Vec length as a variable integer. Could an attacker provide a huge length field to cause memory allocation failures or bypass length validation checks?",
    "Integer Overflow in Length Fields: Could bincode variable-length length fields cause integer overflow leading to memory corruption?",
    "Nested Structure Depth Attack: Could deeply nested serialized structures cause stack overflow during deserialization, crashing off-chain nodes?",
    "Recursive Type Deserialization: Could recursive types cause infinite loops during deserialization, hanging the system during recovery?",
    "Invalid UTF-8 in String Fields: Could invalid UTF-8 cause panics when used in cryptographic operations?",
    "Floating Point NaN/Infinity Injection: Could malicious float encodings break comparison logic enabling guardian bypass?",
    "Large Allocation via Vec Deserialization: Could huge Vec lengths exhaust memory during share or backup deserialization?",
    "String Length Exploitation: Could extremely large String lengths cause memory exhaustion?",
    "HashMap/BTreeMap Size Attacks: Could huge map lengths exhaust memory when deserializing guardian approval metadata?",
    "Cumulative Allocation Attack: Could multiple nested allocations crash nodes?",
    "Allocation Amplification: Could deserialization amplify memory usage disproportionately?",
    "Non-Canonical Integer Encoding: Could variable-length integer malleability enable signature forgery?",
    "Padding Byte Exploitation: Could padding bytes hide malicious data bypassing integrity checks?",
    "Enum Discriminant Non-Uniqueness: Could variant substitution occur via non-unique discriminants?",
    "Boolean Non-Canonical Representation: Could bool values encoded as other bytes break logic?",
    "Tuple vs Struct Encoding Ambiguity: Could ambiguous encodings enable type confusion?",
    "BINCODE_CONFIG Modification Risk: Could malicious dependencies modify bincode config?",
    "Endianness Exploitation: Could cross-platform endianness mismatches break validation?",
    "Variable-Length vs Fixed-Length Configuration: Could config mismatches enable length manipulation?",
    "Size Limit Bypass: Does deserialize() enforce size limits, or can arbitrary payloads be deserialized?",
    "Trailing Bytes Ignored: Could trailing malicious data be ignored, enabling data smuggling?",

    # III. Base64 Encoding Layer - Questions 51-70
    "Base64 Padding Manipulation: Could adding '=' padding bypass validation?",
    "Invalid Character Injection: Could invalid characters cause timing leaks?",
    "Case Sensitivity Exploitation: Could case differences alter decoding?",
    "Whitespace Handling: Are whitespace characters ignored, enabling normalization bypass?",
    "NULL Byte Injection: Could null bytes cause early truncation?",
    "Base64 Size Explosion: Could base64 size increase cause buffer overflows?",
    "Length Calculation Mismatch: Could mismatched expected lengths cause overreads?",
    "URL-Safe vs Standard Base64 Confusion: Could + and / bypass validation?",
    "Base64 Variant Mixing: Could multiple variants cause confusion attacks?",
    "Empty String Edge Case: Can empty strings bypass validation?",
    "Detailed Error in str_to_bytes(): Could error messages leak sensitive data?",
    "Base64 Decoding Error Timing: Could timing differences leak structure information?",
    "Error Message Distinguishability: Could attackers distinguish base64 vs bincode failures?",
    "Partial Decode Information Leak: Could partial decode outputs leak data?",
    "Error Propagation Chain: Could chained error messages leak secrets?",
    "Base64 Collision Attack: Any byte sequences with identical encodings?",
    "Homograph Attack: Could visually similar characters enable social engineering?",
    "Base64 Canonicalization: Could non-canonical forms bypass deduplication?",
    "Encoding Round-Trip Failure: Can bytes_to_str(str_to_bytes(x)) fail identity?",
    "Base64 Truncation Attack: Could truncated strings partially decode?",

    # IV. String Serialization Layer - Questions 71-85
    "Double Encoding Attack: Could data be double-encoded, locking accounts?",
    "Error Handling Inconsistency: Could hidden panics crash nodes?",
    "deserialize_str() Type Parameter Confusion: Could type inference pick the wrong type?",
    "String Length Validation Gap: Are maximum lengths enforced?",
    "Unicode Normalization Issues: Could normalization differences bypass checks?",
    "StrEncoded Clone Semantics: Could cloning leave secrets in memory?",
    "TryFrom Validation Gaps: Could partial failures leak data?",
    "Serialize Trait Error Handling: Could error conversions hide root causes?",
    "Deserialize Trait Error Messages: Could custom errors leak sensitive types?",
    "From Trait Unwrap Panic: Could panics crash recovery endpoints?",
    "Nested Error Context Loss: Do errors preserve original context?",
    "Error Message Inconsistency: Could patterns reveal system state?",
    "Partial Failure State: Could partial serialized data corrupt state?",
    "Silent Failure Risk: Are results ever ignored?",
    "Error Recovery Exploitation: Could repeated errors leak behavior?",

    # V. StrEncoded Wrapper Security - Questions 86-105
    "From Trait Panics: Could invalid T values crash nodes?",
    "Unwrap in Hot Path: Is unwrap() reachable during guardian approval?",
    "Panic Recovery Exploitation: Could attackers induce recovery misbehavior?",
    "Double Panic Safety: Could nested panics cause undefined behavior?",
    "Panic in Drop: Could panicking Drop create memory safety issues?",
    "Serde Deserializer Mismatch: Could non-string JSON confuse deserializer?",
    "Serde Visitor Exploitation: Could malicious tokens bypass checks?",
    "Serde Derive Bypasses: Could field attributes bypass StrEncoded rules?",
    "Serde Rename Attacks: Could renamed fields collide?",
    "Serde Skip Fields: Could skipped fields remain uninitialized?",
    "Generic Type Bound Issues: Are Serialize + DeserializeOwned enough?",
    "PhantomData Exploitation: Could phantom types bypass validation?",
    "Zero-Sized Type Confusion: Could () cause unexpected behavior?",
    "Unsized Type Handling: Could dynamic trait objects reintroduce confusion?",
    "Associated Type Vulnerabilities: Are associated types safely encoded?",
    "Debug Trait Information Leak: Could Debug leak secrets?",
    "Display Trait Exposure: Could Display expose encoded secrets?",
    "Clone and Sensitive Data: Are cloned secrets zeroized?",
    "PartialEq Timing: Could comparisons leak timing info?",
    "Hash Trait Determinism: Could collisions break HashMap usage?",

    # VI. Cryptographic Integration - Questions 106-125
    "Key Serialization Leakage: Could serialized keys remain in memory?",
    "Share Serialization Integrity: Could share tampering bypass commitments?",
    "Commitment Binding Failure: Could commitments be reused across accounts?",
    "Signature Over Serialized Data: Could encoding malleability affect signatures?",
    "VDRF Input Encoding Collision: Could collisions enable multi-account mapping?",
    "Deserialization Timing Leak: Could timing reveal key structure?",
    "Base64 Decode Timing Leak: Could timing reveal partial secrets?",
    "Error Path Timing Differences: Base64 vs bincode timing oracle?",
    "Branch Prediction Side Channel: Could branching leak patterns?",
    "Cache Timing Side Channel: Could cache patterns reveal type info?",
    "Authenticated Encryption Binding: Could encoding errors break AAD binding?",
    "MAC Tag Serialization: Could malleability bypass MAC verification?",
    "Signature Verification Bypass: Could wrong-type deserialization bypass checks?",
    "Commitment Opening Validation: Could deserialized openings bypass checks?",
    "Share Reconstruction Integrity: Could malicious shares bypass interpolation validation?",
    "Random Nonce Serialization: Could serialization enable nonce reuse?",
    "Scalar Encoding Malleability: Could non-canonical scalars break signatures?",
    "Point Encoding Validation: Could invalid EC points bypass validation?",
    "Prime Field Overflow: Could field elements exceed modulus?",
    "Pairing Group Type Confusion: Could G1/G2 confusion break VDRF security?",

    # VII. State Management and Invariant Violations - Questions 126-140
    "Unauthorized Recovery via Type Confusion: Could RecoveryRequest be deserialized as BackupReconstruction?",
    "Email Certificate Deserialization Bypass: Could malformed EmailCertToken bypass ownership checks?",
    "Guardian Threshold Manipulation: Could invalid t values bypass t ≤ n?",
    "Recovery State Corruption: Could wrong-type deserialization skip states?",
    "Email-to-Account Binding Violation: Could encoding issues allow multi-binding?",
    "Unauthorized Backup Reconstruction: Could type confusion bypass owner checks?",
    "Share Distribution Tampering: Could share metadata be deserialized maliciously?",
    "Ciphertext Binding Failure: Could ciphertext be rebound to wrong account?",
    "Guardian Approval Bypass: Could serialized signatures from insufficient guardians be accepted?",
    "Share Integrity Violation: Could malicious shares bypass hash commitments?",
    "Email Anonymity Leak: Could deserialize_str() errors leak email values?",
    "Association Privacy Violation: Could serialization metadata leak email associations?",
    "VDRF Output Linkability: Could non-canonical encodings reveal linkability?",
    "Guardian Identity Leak: Could serialized guardian IDs reveal trusted guardians?",
    "Off-Chain Node Anonymity Leak: Could errors reveal which nodes processed data?",

    # VIII. HTTP Endpoint Integration - Questions 141-150
    "Malformed JSON Attack: Could malformed JSON bypass StrEncoded validation?",
    "Size Limit Enforcement: Do endpoints enforce size limits before decoding?",
    "Content-Type Bypass: Could binary data masquerade as JSON?",
    "Concurrent Deserialization Race: Could concurrent requests cause race conditions?",
    "Error Response Leakage: Could endpoints echo sensitive malformed input?",
    "Partial Deserialization Corruption: Could mid-parse failures corrupt state?",
    "Transaction Atomicity Violation: Could deserialization errors break atomicity?",
    "Idempotency Failure: Could non-deterministic parse results break idempotency?",
    "State Version Mismatch: Could old serialized state bypass new validation?",
    "Reentrancy via Deserialization: Could custom Deserialize impls trigger callbacks?",

    # Category 1: Cryptographic Correctness & Key Management (30 Questions)
    "Weak RNG in Key Generation: Does DecryptionKey::gen() mod.rs:68-70 properly validate that the provided RNG implements CryptoRng, or could a caller pass a weak PRNG leading to predictable decryption keys that would allow unauthorized backup reconstruction?",
    "Key Derivation Consistency: In DecryptionKey::encryption_key() mod.rs:72-76 , if multiple threads call this method concurrently, could the OnceCell initialization in v0 lead to inconsistent public key derivation that breaks the encryption/decryption relationship?",
    "Ephemeral Key Reuse in v0: In the v0 implementation's encrypt() function v0.rs:99-131 , if the RNG is compromised or predictable, could ephemeral Diffie-Hellman scalars (ts) repeat across encryptions, breaking IND-CCA2 security and allowing an attacker to link ciphertexts to accounts?",
    "Missing Point Validation: Does the v0 decryption logic v0.rs:68-92 validate that ct.tp is a valid curve point before performing scalar multiplication ct.tp * self.sk, potentially allowing small subgroup attacks that leak secret key bits?",
    "Shared Secret Serialization: In v0's DH shared secret computation v0.rs:74-78 , could non-canonical serialization of the affine point lead to different shared secrets for the same keypair, causing legitimate decryption to fail and locking users out of their accounts?",
    "Key Rotation Vulnerability: When an account rotates PKE keys, could old DecryptionKey instances persisting in memory v0.rs:36-40 (with Drop trait) be accessed after zeroization if cloned before rotation, allowing unauthorized recovery with outdated keys?",
    "Public Key Collision: Could two different DecryptionKey instances generate the same EncryptionKey mod.rs:72-76 due to insufficient randomness or point compression issues, causing guardian shares to be decryptable by unintended parties?",
    "Version Downgrade in Key Generation: If a malicious node forces key generation to use an older, vulnerable version by manipulating the DecryptionKey::gen() dispatch mod.rs:68-70 , could guardians' shares be encrypted with weaker cryptography?",
    "Key Export Without Protection: When DecryptionKey is serialized v0.rs:28-34 , are there any protections against exporting the secret key sk in plaintext over network channels, potentially exposing all encrypted guardian shares?",
    "Insufficient Key Length: Does the v0 implementation enforce that the scalar field Fr v0.rs:30-31 has sufficient bit security (≥256 bits) to prevent brute-force attacks on guardian share decryption keys?",
    "Side-Channel in Scalar Multiplication: Could timing variations in the curve operations curve::GAffine::generator() * self.sk v0.rs:64-65 leak secret key bits through cache timing, enabling an attacker to recover guardian decryption keys from off-chain nodes?",
    "Weak Curve Parameters: If the curve::GAffine type v0.rs:17-18 is configured with a weak elliptic curve, could discrete log attacks break the PKE scheme and allow unauthorized decryption of all guardian shares?",
    "Generator Point Manipulation: Could an attacker substitute the generator point in curve::GAffine::generator() v0.rs:64 to create rogue public keys that appear valid but are decryptable with a known private key?",
    "Zeroization Bypass: After DecryptionKey::drop() v0.rs:36-40 zeroizes the secret key, could compiler optimizations or memory swapping leave residual key material in memory/swap that an attacker with node access could recover?",
    "Key Deserialization Without Validation: When deserializing a DecryptionKey from JSON v0.rs:28-34 , does the code validate that the scalar sk is within the valid field range, or could out-of-range values cause cryptographic failures during recovery?",
    "Public Key Cache Poisoning: If the OnceCell<curve::GAffine> in DecryptionKey v0.rs:32-33 is somehow poisoned with an incorrect public key, would all subsequent encryptions be decryptable by an attacker holding the corresponding private key?",
    "Batch Key Generation Weakness: In batch_encrypt() mod.rs:149-182 , if the signing key sk is generated with weak randomness (line 160), could an attacker forge batch signatures and cause selective decryption failures?",
    "Cross-Version Key Incompatibility: Could a DecryptionKey::V0 successfully decrypt a Ciphertext::V1 (future version) without proper version checking mod.rs:86-92 , leading to silent type confusion that corrupts recovery data?",
    "Key Pair Binding Failure: Is the relationship between a DecryptionKey and its derived EncryptionKey mod.rs:72-76 cryptographically bound such that an attacker cannot substitute a rogue public key while keeping the same private key?",
    "Deterministic Key Generation: If DecryptionKey::gen() mod.rs:68-70 is called with a seeded RNG (for testing), could deterministic keys leak into production, allowing attackers to precompute guardian decryption keys?",
    "Key Rotation Atomicity: When rotating PKE keys in account state, if the old key is deleted before confirming successful encryption with the new key, could a crash during rotation permanently lock out the account owner from backup reconstruction?",
    "Malleability in Key Serialization: Could an attacker modify the serialized form of an EncryptionKey v0.rs:14-18 to create a variant key that encrypts to ciphertexts decryptable by the attacker, while still passing validation checks?",
    "Key Confusion Between Accounts: If multiple accounts accidentally use the same EncryptionKey mod.rs:54-56 (e.g., due to improper key derivation), could one account owner decrypt another's guardian shares?",
    "Missing Key Freshness Check: Does the system verify that newly generated DecryptionKey instances mod.rs:68-70 are unique and haven't been used before, preventing key reuse attacks that link multiple accounts?",
    "Key Substitution in Batch Context: In batch_encrypt() mod.rs:165-176 , could an attacker replace one guardian's EncryptionKey in the iterator with their own key, causing that guardian's share to be encrypted for the attacker instead?",
    "Ephemeral Key Leakage: After encrypt() generates the ephemeral scalar ts in v0 v0.rs:106-107 , is it properly zeroized from memory, or could it leak through stack dumps allowing IKM reconstruction?",
    "Public Key Validation on Deserialization: When deserializing an EncryptionKey from network data, does the code verify the point is on the curve v0.rs:14-18 , preventing invalid curve attacks that could break the DH assumption?",
    "Key Generation Under Adversarial RNG: If an off-chain node's RNG is compromised (minority corruption scenario), could it force DecryptionKey::gen() mod.rs:68-70 to produce keys with low entropy, making guardian shares brute-forceable?",
    "Cross-Protocol Key Reuse: If the same DecryptionKey is used for both PKE operations and other cryptographic protocols in Swafe, could key reuse enable cross-protocol attacks that break encryption security?",
    "Key Backup Without Encryption: When guardian decryption keys are stored in off-chain nodes, are they encrypted at rest, or could an attacker with node access extract raw DecryptionKey values v0.rs:28-34 and decrypt all shares?",

    # Category 2: Context Binding & Domain Separation (30 Questions)
    "Context Type Confusion: In decrypt() mod.rs:78-94 , if the context type A is substituted with a different type that has the same serialized representation but different SEPARATOR, could it break the binding and allow cross-context decryption?",
    "Empty Context Bypass: Could an attacker pass an empty or default context mod.rs:81-82 (e.g., EmptyAD) to decrypt(), bypassing intended context binding and decrypting shares meant for a different recovery session?",
    "BatchCtx Verification Key Substitution: In decrypt_batch() mod.rs:111-114 , if an attacker modifies ct.inn.vk before signature verification, could the verification pass but the context binding fail, causing guardians to decrypt shares for the wrong recovery request?",
    "Context Separator Collision: If two different context types have the same SEPARATOR constant mod.rs:51-52 , could ciphertexts encrypted for one context be decrypted using another, violating backup isolation?",
    "Nested Context Injection: In BatchCtx mod.rs:45-52 , the inner context is a tuple (A::SEPARATOR, ctx). Could an attacker craft a malicious outer context that, when nested, produces the same encoding as a legitimate inner context, enabling cross-session decryption?",
    "Context Binding to Wrong Verification Key: In batch_encrypt() mod.rs:170-174 , each ciphertext is bound to vk. If the signing key is later changed, do old ciphertexts remain valid, or could guardians decrypt shares that should be invalidated?",
    "Context Omission in Encryption: If a caller invokes encrypt() mod.rs:131-140 with a generic context (e.g., empty struct) instead of the intended account-specific context, could multiple accounts' shares be decryptable with the same context?",
    "Context Replay Across Backups: Could an attacker record the context used for one backup's guardian share encryption and replay it to decrypt shares from a different backup mod.rs:78-94 , violating per-backup isolation?",
    "Verification Key Forging: In decrypt_batch() mod.rs:104 , if signature verification is skipped or bypassed due to a bug, could an attacker replace ct.inn.vk with their own verification key and cause guardians to decrypt shares under the wrong context?",
    "Context Binding in v0 DH: The v0 implementation binds context to the DH shared secret via KDF v0.rs:82-88 . If the DiffieHellmanCtx includes both tp and pk, could an attacker swap these values to create a ciphertext that decrypts under a different key?",
    "Separator Prefix Collision: If BatchCtx::SEPARATOR mod.rs:51 and another type's separator share a common prefix, could the domain separation mechanism fail, allowing type confusion between batch and non-batch contexts?",
    "Context Serialization Ambiguity: In the Tagged::encode() implementation used for contexts encode.rs:20-37 , could two different context values produce the same byte encoding if bincode serialization is not canonical?",
    "Missing Context in Batch Inner: The BatchCiphertextV0Inner mod.rs:33-36 stores vk and cts, but does not include the outer context A. Could guardians decrypt batch ciphertexts without verifying the original context binding?",
    "Context Modification After Signature: In batch_encrypt() mod.rs:179-180 , the signature is computed over inn. If an attacker modifies the context after signature generation but before transmission, would the verification fail or silently succeed?",
    "Cross-Version Context Migration: When migrating from V0 to a future version, could the context binding format change such that V0 ciphertexts become decryptable under V1 contexts mod.rs:86-92 , breaking isolation?",
    "Context Binding to Account ID: If the context should include the account ID to prevent cross-account decryption, does the PKE module enforce this, or is it the caller's responsibility? Could a malicious node omit the account ID from the context?",
    "Batch Context Downgrade: In decrypt_batch() mod.rs:111-114 , if an attacker downgrades the nested BatchCtx to a simpler context type, could the decryption succeed with weaker binding?",
    "Separator Injection via Context Fields: If the context type A has fields that can contain the separator string mod.rs:51 , could an attacker craft a context that injects additional separators, causing domain separation bypass?",
    "Context Verification Key Mismatch: In batch operations, if the verification key in BatchCtx mod.rs:46-47 doesn't match the one in BatchCiphertextV0Inner mod.rs:34 , would decryption silently fail or succeed with the wrong key?",
    "Context Binding Across Accounts: If guardian shares for different accounts are encrypted with similar contexts (differing only in account ID), could an off-chain node correlate these to link accounts, violating privacy?",
    "Missing Context Freshness: Does the context include a timestamp or nonce to prevent replay attacks mod.rs:78-82 ? Could an attacker replay old contexts to decrypt shares from a previous recovery session?",
    "Context Truncation Attack: If the context serialization is truncated before the signature check in symmetric encryption symmetric.rs:112-129 , could the PKE layer still decrypt successfully, bypassing intended context validation?",
    "Batch Context Separator Ordering: The BatchCtx uses (A::SEPARATOR, ctx) mod.rs:47 . Could reversing the order to (ctx, A::SEPARATOR) produce the same encoding for certain context types, breaking separation?",
    "Context Type Downgrade: If decrypt() is called with a more generic context type than intended mod.rs:78-94 , would the symmetric layer's context validation catch this, or could it silently succeed?",
    "Verification Key as Context: Since vk is part of BatchCtx mod.rs:46 , could an attacker use the verification key itself as the context, creating circular dependencies in binding?",
    "Context Padding Attacks: If bincode serialization of contexts includes padding bytes that aren't canonicalized encode.rs:29-36 , could an attacker create distinct contexts that serialize identically?",
    "Context Length Extension: Could an attacker append extra data to a legitimate context without breaking serialization, causing the PKE layer to accept an extended context while the application expects the original?",
    "Missing Context in v0 Encryption: In the v0 encrypt() implementation v0.rs:99-131 , the context is passed to sym::seal(). If the symmetric layer doesn't enforce context presence, could encryptions succeed with null contexts?",
    "Context Binding to Signing Key: In batch_encrypt() mod.rs:160-161 , the signing key is ephemeral. Could an attacker precompute verification keys and cause context collisions across different batch operations?",
    "Context Deserialization Failure Handling: If the context A fails to deserialize during decrypt() mod.rs:78-94 , does the function return a clear error, or could it silently fall back to a default context?",

    # Category 3: Batch Encryption Security (30 Questions)
    "Signature Verification Bypass: In decrypt_batch() mod.rs:104 , if signature verification fails but returns Ok(()) due to a bug in the signature module, could guardians decrypt batch ciphertexts without proper authentication?",
    "Batch Ciphertext Reordering: If an attacker reorders the cts vector in BatchCiphertextV0Inner mod.rs:35 after signature generation but before storage, would the signature still verify, causing guardians to receive the wrong shares?",
    "Selective Ciphertext Removal: In decrypt_batch() mod.rs:108-118 , if an attacker removes some ciphertexts from ct.inn.cts, would the signature verification catch this, or could the batch silently decrypt with fewer guardians?",
    "Batch Index Spoofing: The decrypt_batch() function returns (M, usize) where usize is the index mod.rs:100 . Could an attacker manipulate the ciphertext order such that guardians receive the wrong index, causing them to believe they hold a different guardian position?",
    "Empty Batch Ciphertext: If batch_encrypt() is called with an empty iterator mod.rs:156 , creating a BatchCiphertext with no ciphertexts, would decrypt_batch() handle this gracefully or cause guardians to believe recovery is complete when no shares exist?",
    "Signature Key Reuse Across Batches: If the signing key in batch_encrypt() mod.rs:160 is reused across multiple batches (due to weak RNG), could an attacker link different batches to the same recovery session, leaking privacy?",
    "Verification Key Substitution Before Signing: In batch_encrypt() mod.rs:161 , if an attacker intercepts execution after vk generation but before signing, could they substitute their own verification key, making all ciphertexts decryptable under the wrong context?",
    "Batch Ciphertext Duplication: Could an attacker duplicate entries in the cts vector mod.rs:165-176 , causing multiple guardians to receive identical shares and violating threshold security?",
    "Signature Malleability: If the signature scheme used in BatchCiphertextV0 mod.rs:39-42 is malleable, could an attacker modify the signature such that it still verifies but corresponds to different batch content?",
    "Batch Verification Order Dependency: In decrypt_batch() mod.rs:108-118 , the loop tries each ciphertext sequentially until one succeeds. Could this timing difference leak which guardian is decrypting, violating anonymity?",
    "Missing All-or-Nothing Enforcement: The comments claim batch encryption provides 'all ciphertexts decrypt or all fail' guarantees mod.rs:146-148. But if signature verification succeeds, would individual ciphertext corruptions still allow partial decryption, breaking the guarantee?",
    "Batch Context Independence: In batch_encrypt() mod.rs:165-176 , each ciphertext is encrypted independently with the same context bound to vk. Could encrypting the same message multiple times with different keys leak information about the message?",
    "Signature Verification Error Handling: If ct.inn.vk.verify() mod.rs:104 throws an exception instead of returning an error, could the batch decryption bypass verification and proceed with corrupted ciphertexts?",
    "Batch Size Manipulation: Could an attacker inflate the cts vector with dummy ciphertexts mod.rs:165-176 , causing guardians' decryption attempts to exhaust computational resources while still verifying the signature?",
    "Verification Key Collision: If two different signing keys produce the same verification key mod.rs:161 (due to weak curve parameters), could batches signed with different keys become interchangeable, breaking context binding?",
    "Batch Nesting Attack: Could an attacker nest BatchCiphertext structures (encrypting a batch as a message within another batch), causing infinite recursion or stack overflow during decrypt_batch()?",
    "Early Termination on Decryption Success: In decrypt_batch() mod.rs:108-118 , the function returns immediately upon the first successful decryption. Could this timing leak reveal the guardian's position in the batch to a network observer?",
    "Signature Over Partial Data: Does the signature in BatchCiphertextV0 mod.rs:41 cover both vk and cts, or only one? Could an attacker modify the uncovered field without invalidating the signature?",
    "Batch Decryption Without Context: If decrypt_batch() is called with a null or generic context mod.rs:99 , would the individual ciphertexts still be bound to BatchCtx, or could the binding be bypassed?",
    "Iterator Exhaustion in Batch Encryption: In batch_encrypt() mod.rs:165-176 , if the iterator produces an error or panics mid-iteration, could partial batch ciphertexts be signed and stored, violating all-or-nothing guarantees?",
    "Signing Key Leakage: After batch_encrypt() generates the signing key sk mod.rs:160 , is it zeroized from memory, or could an attacker with node access recover it and forge additional batch signatures?",
    "Batch Verification Before Context Binding: In decrypt_batch() mod.rs:104-114 , the signature is verified before attempting decryption. Could an attacker craft a batch with a valid signature but corrupted contexts, causing verification to pass but decryption to fail with confusing errors?",
    "Verification Key Type Confusion: If the sig::VerificationKey type mod.rs:34 is substituted with a compatible but insecure type, could batch signatures verify under the wrong security assumptions?",
    "Batch Index Out of Bounds: If decrypt_batch() returns an index i mod.rs:116 that is out of bounds for the original guardian list, could this cause the application to assign shares to the wrong guardian?",
    "Missing Batch Freshness: Does the BatchCiphertextV0 include a timestamp or nonce to prevent replaying old batches mod.rs:33-36 ? Could an attacker replay a batch from a previous recovery session?",
    "Batch Signature Forgery: If the signature scheme in sig::SigningKey::sign() mod.rs:180 is vulnerable to forgery, could an attacker create arbitrary batch ciphertexts that pass verification?",
    "Concurrent Batch Decryption: If multiple guardians call decrypt_batch() concurrently on the same BatchCiphertext mod.rs:96-124 , could race conditions cause them to receive inconsistent results?",
    "Batch Ciphertext Version Mismatch: If a BatchCiphertext::V0 contains individual Ciphertext::V1 entries mod.rs:26-30 , would the decryption logic handle this, or could it cause type confusion?",
    "Verification Key Binding to Account: Is the verification key in BatchCiphertextV0Inner mod.rs:34 bound to the account ID, or could batches for different accounts use the same verification key, enabling cross-account share decryption?",
    "Signature Scheme Parameter Manipulation: If the signature scheme's parameters (e.g., curve, hash function) are configurable, could an attacker force batch_encrypt() to use weak parameters, breaking the all-or-nothing guarantee?",

    # Category 4: Serialization & Version Management (30 Questions)
    "Ciphertext Deserialization Without Validation: When deserializing a Ciphertext from JSON or bincode mod.rs:20-24 , does the code validate that the inner v0 tp point is on the curve, or could invalid points cause decryption failures that lock out accounts?",
    "Version Tag Manipulation: The versioned_enum! macro mod.rs:8-12 assigns version tag 0 to V0 types. Could an attacker modify the tag to a future version, causing the deserializer to interpret V0 data as a different version?",
    "Forward Compatibility Violation: If a future V1 is added, could V0 ciphertexts be accidentally decrypted as V1 mod.rs:86-92 , bypassing V1-specific security checks?",
    "Deserialization of Untrusted Ciphertexts: When off-chain nodes deserialize BatchCiphertext from network data mod.rs:26-30 , could maliciously crafted input trigger panics or memory exhaustion due to unbounded vector sizes?",
    "Serialization Format Ambiguity: If both JSON and bincode serialization are supported for Ciphertext mod.rs:20-24 , could an attacker craft input that deserializes differently under each format, causing verification/decryption mismatches?",
    "Version Downgrade in DecryptionKey: If a DecryptionKey is serialized as V0 but deserialized as a future version due to version tag corruption mod.rs:14-18 , could the decryption logic use the wrong algorithm?",
    "Missing Version Check in Decrypt: In decrypt() mod.rs:86-92 , the match statement only handles Ciphertext::V0. If a new version is added but the match isn't updated, would it fallback to DecryptionFailed or panic?",
    "Ciphertext Padding Injection: Could an attacker append extra bytes to a serialized Ciphertext v0.rs:42-47 that are ignored during deserialization but affect hash-based integrity checks elsewhere in Swafe?",

    # I. Pairing Verification Security (Questions 1–20)
    "Pairing Check Assert Panic: In check_pairing, can an attacker supply lhs and rhs arrays of different lengths to trigger the assert! panic, causing DoS in VDRF share verification or account recovery flows?",
    "Pairing Identity Element Confusion: Does check_pairing return true when comparing the identity element against itself, potentially allowing invalid VDRF evaluations where both sides are identity points to pass verification?",
    "Empty Array Pairing Check: What happens when check_pairing is called with empty arrays lhs=[] and rhs=[]? Does it return true, allowing trivial VDRF verification bypasses?",
    "Single Element Pairing Weakness: Can a malicious off-chain node provide single-element arrays to check_pairing that might have different security properties than multi-pairing verification used in VDRF?",
    "Pairing Non-Determinism: Is the pairing check deterministic across different machines/architectures? Could timing variations leak information about email associations during VDRF verification?",
    "Subgroup Membership Before Pairing: Does check_pairing verify that all G1Affine and G2Affine points are in the correct prime-order subgroup before pairing, preventing small subgroup attacks on VDRF?",
    "Point-at-Infinity in Pairing: Can an attacker include points at infinity in lhs or rhs arrays to manipulate VDRF share verification logic, potentially allowing invalid shares to pass?",
    "Pairing Batch Verification Attack: Since check_pairing uses multi_pairing, could an attacker craft multiple malicious point pairs where individual pairings fail but the sum passes, breaking VDRF security?",
    "Pairing Check Side-Channel: Does check_pairing have constant-time comparison when checking if the result equals Default::default(), or could timing leaks reveal information about VDRF secret shares?",
    "Negated Point Confusion: In VDRF verification, check_pairing receives negated G2 points. Could an attacker exploit double negation or identity element edge cases to bypass verification?",
    "Pairing Input Order Dependency: Does the order of elements in lhs and rhs arrays affect the pairing result? Could reordering points in malicious VDRF shares pass verification incorrectly?",
    "Multi-Pairing vs Single Pairing: Are there security differences between calling multi_pairing once versus multiple pairing calls? Could this affect VDRF threshold verification?",
    "Pairing Result Precision: Does the BLS12-381 pairing implementation have sufficient precision? Could rounding errors cause valid VDRF evaluations to fail or invalid ones to pass?",
    "Pairing with Corrupted Curve Points: If a deserialized G1/G2 point is not on the curve (due to deserialization bugs), does check_pairing detect this before performing the pairing operation?",
    "VDRF Share Pairing Optimization: The VDRF combine function uses pairing checks per share. Could an attacker provide many invalid shares to cause excessive pairing computations, affecting liveness?",
    "Pairing Check Error Handling: Does check_pairing handle all possible error conditions from the underlying multi_pairing operation, or could panics occur during VDRF verification?",
    "Generator Point Pairing: Does check_pairing properly handle the case where G1Affine::generator() is used in VDRF verification? Are there any edge cases with the generator point?",
    "Pairing Equation Reformulation: VDRF verification reformulates e(G1, eval) = e(C0, K) as e(G1, eval) * e(C0, -K) = 1. Could the negation introduce vulnerabilities?",
    "Concurrent Pairing Checks: If multiple VDRF verifications occur concurrently using check_pairing, are there any race conditions or shared state issues in the underlying arkworks library?",
    "Pairing Verification Bypass via Assert: Could an attacker craft inputs that pass the length assert! but still cause undefined behavior or incorrect pairing results in edge cases?",

    # II. Hash-to-Curve Domain Separation (Questions 21–40)
    "Domain Separator Collision: In hash_to_g2, the domain separator is format!(\"swafe-bls12-381-g2 : {}\", T::SEPARATOR). Could two different Tagged types with crafted SEPARATOR values produce the same domain string, causing type confusion in VDRF?",
    "Empty Separator Attack: Can a malicious implementation of Tagged provide an empty SEPARATOR, potentially colliding with another type's domain and allowing email association attacks?",
    "Separator Format String Injection: Could special characters in T::SEPARATOR break the format! string parsing, leading to incorrect domain separation in VDRF input hashing?",
    "G1 vs G2 Domain Overlap: The only difference between hash_to_g1 and hash_to_g2 domain strings is \"g1\" vs \"g2\". Is this sufficient to prevent cross-group attacks in mixed-usage scenarios?",
    "VdrfKPoint Domain Reuse: The VdrfKPoint type uses separator \"v0:vdrf-input\". Could another module accidentally reuse this separator, breaking VDRF security?",
    "Domain Separator Versioning: The v0: prefix suggests versioning. If a v1: version is introduced, could old VDRF evaluations be replayed or confused with new ones?",
    "Hasher Creation Panic: hash_to_g1 and hash_to_g2 both use .expect(\"Failed to create hasher\"). Under what conditions could hasher creation fail, and could this be exploited for DoS?",
    "Domain String Length Limits: Are there any length limits on the combined domain string \"swafe-bls12-381-g2 : {SEPARATOR}\"? Could extremely long separators cause issues?",
    "Unicode in Domain Separator: If T::SEPARATOR contains Unicode characters, does format! handle them correctly across different locales/platforms, ensuring consistent hashing?",
    "Hash-to-Curve Determinism: Are hash_to_g1 and hash_to_g2 deterministic across all platforms? Could architecture differences cause different curve points for the same input?",
    "Pedersen Generator Domain Collision: PedersenGenSep uses \"v0:pedersen\" with names \"H\" and \"G\". Could these collide with VDRF domains or other commitment schemes?",
    "Input Encoding in Hash-to-Curve: hash_to_g2 hashes input.encode(). If the encode() function has vulnerabilities, could this affect the hash-to-curve security?",
    "WBMap Domain Separation: Does the WBMap implementation in arkworks respect the domain separator passed to MapToCurveBasedHasher::new()?",
    "DefaultFieldHasher Configuration: DefaultFieldHasher<Sha3_256, 128> uses a 128-byte security parameter. Is this sufficient for BLS12-381's 128-bit security level?",
    "Hash-to-Curve Unwrap Safety: Both hash-to-curve functions call .unwrap() after .hash(). Under what conditions could hashing fail, and could this cause panics during critical operations?",
    "Cross-Type Hash Collision: Could an attacker craft two different Tagged types that, when encoded and hashed, produce the same G1 or G2 point, breaking VDRF uniqueness?",
    "Domain Separator Injection in Email Certs: If email certificates use hash-to-curve with user-controlled data, could an attacker inject domain separators to create collisions?",
    "Hash-to-Curve Bias: Does the hash-to-curve implementation have uniform distribution over the curve? Could biased outputs affect VDRF security?",
    "Concurrent Hash-to-Curve Operations: Are hash_to_g1 and hash_to_g2 thread-safe? Could concurrent VDRF operations cause issues with the hasher state?",
    "Tag Encoding Ambiguity: The Tagged::encode() method prepends the separator. Could two different (separator, value) pairs produce the same encoding, breaking domain separation?",

    # III. Serialization Security – G1 Points (Questions 41–60)
    "G1 Compressed Size Bypass: In serialize::g1::serialize, the code checks bytes.len() != 48. Could a malicious arkworks library or corrupted state produce different-sized outputs that bypass this check?",
    "G1 Point Validation Missing: Does G1Affine::deserialize_compressed verify that the deserialized point is on the curve and in the correct subgroup before returning?",
    "G1 Identity Point Serialization: How does the identity point serialize? Could an attacker substitute identity points for valid commitments in Pedersen schemes?",
    "G1 Deserialization from All-Zeros: What happens when deserializing 48 zero bytes? Is this the identity point, and could this be exploited in backup commitment verification?",
    "G1 Compression Flag Manipulation: BLS12-381 compressed points use flag bits. Could an attacker flip these bits to change point properties while maintaining valid serialization?",
    "G1 Tuple Serialization Order: serialize_tuple(48) serializes bytes sequentially. Is there any way to manipulate byte order during deserialization to change the point?",
    "G1 Visitor Incomplete Bytes: In G1Visitor::visit_seq, if seq.next_element() returns None before 48 bytes, the error message is generic. Could this leak information about serialization state?",
    "G1 Deserialization Error Leakage: Does the error message from G1Affine::deserialize_compressed leak information about why deserialization failed, potentially revealing secret point data?",
    "G1 Serialization Consistency: If the same G1Affine point is serialized multiple times, are the outputs identical? Could non-determinism affect VDRF public key verification?",
    "G1 Point-at-Infinity Handling: Does the serialization correctly handle points at infinity used in VDRF evaluations? Could infinity points cause verification bypasses?",
    "G1 Canonical Form Enforcement: Does deserialization enforce canonical form (e.g., choosing the smaller y-coordinate)? Could non-canonical forms break equality checks?",
    "G1 Batch Deserialization: If multiple G1 points are deserialized in a vector, does one invalid point corrupt the entire batch or allow partial deserialization?",
    "G1 Memory Layout Assumptions: Does the 48-byte fixed array [0u8; 48] match the expected memory layout across all platforms?",
    "G1 Tuple vs Bytes Serialization: The code uses serialize_tuple(48) instead of serialize_bytes. Could this difference affect compatibility with other serialization formats?",
    "G1 Serialization Buffer Overflow: Could data.serialize_compressed(&mut bytes) write more than 48 bytes if the implementation is buggy, causing buffer issues?",
    "G1 Compression Validation: Does the deserialization verify that the compressed form is valid according to BLS12-381 standards before decompression?",
    "G1 Error Message Timing: Does formatting the error message in deserialization take variable time based on the invalid input, potentially leaking information?",
    "G1 Serde Compatibility: Is the serialize_tuple approach compatible with all serde formats, or could some formats misinterpret the structure?",
    "G1 Negation Serialization: If a G1 point is negated, does its serialization change appropriately? Could this affect VDRF verification where negated points are used?",
    "G1 Version Compatibility: If the arkworks library updates its compressed point format, could old serialized G1 points fail to deserialize, causing account lockout?",

    # IV. Serialization Security – Fr Field Elements (Questions 61–80)
    "Fr Size Validation Bypass: The serialize::fr::serialize checks bytes.len() != 32. Could edge cases in field element representation produce different sizes?",
    "Fr Modular Reduction: In hash_to_fr, the function uses from_le_bytes_mod_order. Does this properly reduce inputs larger than the field modulus?",
    "Fr Zero Element Handling: How is Fr::ZERO serialized? Could an attacker substitute zero for valid VDRF secret shares?",
    "Fr Deserialization All-Ones: What happens when deserializing 32 bytes of 0xFF? Is this handled correctly or could it cause field overflow?",
    "Fr Canonical Encoding: Does Fr::deserialize_compressed enforce that the value is less than the field modulus? Could non-canonical values break equality checks?",
    "Fr Secret Leakage via Serialization: When VDRF secret shares (wrapped in Fr) are serialized, could the serialization process leak bits through side channels?",
    "Fr Visitor Error Messages: Do error messages in FrVisitor reveal information about the expected vs actual byte values, potentially leaking secret data?",
    "Fr Hash Collision: In hash_to_fr, could two different inputs produce the same field element after from_le_bytes_mod_order, affecting VDRF security?",
    "Fr Serialization Timing: Does serializing different Fr values take constant time, or could timing variations leak information about VDRF secret shares?",
    "Fr Zeroization: After deserializing a VDRF secret share (Fr element), is the intermediate byte buffer zeroized to prevent memory leaks?",
    "Fr Tuple Serialization Optimization: Does using serialize_tuple(32) provide any security benefits over serialize_bytes for secret field elements?",
    "Fr Batch Deserialization Safety: When deserializing Vec<Fr> for polynomial coefficients, does one invalid Fr corrupt the entire batch?",
    "Fr Additive vs Multiplicative Identity: Does serialization distinguish between Fr::ZERO (additive identity) and Fr::ONE (multiplicative identity)?",
    "Fr Negative Values: Could deserialization accept values that represent negative elements modulo p, violating canonical forms?",
    "Fr Compression Unnecessary: Fr elements are already 32 bytes. Why use compressed serialization, and could this cause confusion?",
    "Fr Endianness Consistency: from_le_bytes_mod_order uses little-endian. Is this consistent across all serialization paths?",
    "Fr Deserialization Performance: Could repeated deserialization of Fr elements create timing attack surfaces?",
    "Fr Memory Representation: Does the in-memory representation match the serialized form, or could conversion introduce vulnerabilities?",
    "Fr Equality After Round-Trip: Is deserialize(serialize(fr)) == fr guaranteed for all values?",
    "Fr Secret Share Storage: When VDRF shares are stored via serialization, could storage format leak information about polynomial structure?",

    # V. Serialization Security – G2 Points (Questions 81–100)
    "G2 Size Validation: The code checks bytes.len() != 96 for G2 compressed points. Is 96 bytes always correct?",
    "G2 Cofactor Clearing: Does G2Affine::deserialize_compressed automatically clear the cofactor?",
    "G2 Hash-to-Curve Output: Are points from hash_to_g2 guaranteed to lie in the prime-order subgroup?",
    "G2 Identity Serialization: How does the G2 identity serialize, and can this be exploited in VDRF verification?",
    "G2 Twist Security: Does serialization ensure points are on the correct twist?",
    "G2 Compression Efficiency: Could using 96-byte compressed G2 introduce subtle vulnerabilities?",
    "G2 Deserialization Side-Channels: Is decompression constant-time?",
    "G2 Visitor Byte-by-Byte: Could reading bytes one-by-one leak memory access patterns?",
    "G2 Error Propagation: Do deserialization errors leak curve point information?",
    "G2 Point Validation Order: Is validation performed in the correct ordering?",
    "G2 Serialization Round-Trip: Is serialize/deserialize stable for all valid points?",
    "G2 Generator Serialization: Is the serialized generator canonical?",
    "G2 Tuple Serialization Size: Could serde backends interpret tuple forms incorrectly?",
    "G2 Affine vs Projective: Could conversion introduce vulnerabilities?",
    "G2 Buffer Reuse: Are buffers cleared when serializing many points?",
    "G2 Deserialization Allocation: Any heap attack surface?",
    "G2 Compression Flags: Can attackers craft invalid combinations?",
    "G2 Canonical Y-Coordinate: Is canonical form enforced?",
    "G2 Batch Operations: Do batch ops leak timing side-channels?",
    "G2 Cross-Platform Consistency: Is G2 serialization stable across architectures?",

    # VI. Vector Serialization (Questions 101–120)
    "Vector Fr Length Encoding: Does serialize_compressed include a manipulable length prefix?",
    "Vector Fr Empty Handling: Could empty vectors be abused where coefficients are expected?",
    "Vector Fr Size Mismatch: Can malformed byte sequences cause partial deserialization?",
    "Vector Fr Threshold Validation: Does deserialization validate expected lengths?",
    "Vector Fr Ordering: Could reordering coefficients break VDRF security?",
    "Vector Fr Compression Format: Is compression adding any security?",
    "Vector Fr Deserialization Error: Does one invalid element corrupt the vector?",
    "Vector Fr Memory Efficiency: Could huge vectors cause memory exhaustion?",
    "Vector Fr Secret Share Lists: Does the serialization leak number of shares?",
    "Vector Fr Bincode Dependency: Could bincode updates break compatibility?",
    "Vector G1 Commitment Lists: Does serialization preserve binding between coefficients?",
    "Vector G1 Length Validation: Are vectors checked for excessive length?",
    "Vector G1 Duplicate Detection: Can duplicates break VDRF verification?",
    "Vector G1 Ordering Security: Does ordering matter for Pedersen commitments?",
    "Vector G1 Identity Elements: Can identity points break polynomial reconstruction?",
    "Vector G1 Batch Verification: Are efficient batch checks possible?",
    "Vector G1 Size Explosion: Can attackers submit vectors large enough for DoS?",
    "Vector G1 Partial Deserialization: Is partial state cleaned up?",
    "Vector Serialization Format Mismatch: Could tuple-vs-byte confusion occur?",
    "Vector Fr and G1 Correspondence: Does serialization enforce coefficient ↔ commitment alignment?",

    # VII. Cryptographic Primitive Correctness (Questions 121–140)
    "Curve Choice Security: Is BLS12-381 sufficient long-term?",
    "Pairing-Friendly Curve Attacks: Are known attacks applicable to VDRF?",
    "Arkworks Library Trust: Could arkworks bugs break pairing ops?",
    "Type Alias Confusion: Could alias misuse introduce bugs?",
    "Generator Point Hardcoding: Are generators canonical?",
    "Subgroup Order Security: Is subgroup size adequate for thresholds?",
    "Cofactor Handling: Is cofactor handling correct for G2?",
    "Curve Parameter Validation: Are parameters assumed correct?",
    "Field Arithmetic Security: Are Fr ops constant-time?",
    "Group Operation Security: Are G1/G2 ops constant-time?",
    "Pairing Non-Degeneracy: Is non-degeneracy guaranteed?",
    "Embedding Degree Security: Is k=12 adequate?",
    "Hash-to-Curve Security: Is WBMap sufficiently robust?",
    "Bilinear Map Properties: Is bilinearity enforced correctly?",
    "Zero-Knowledge Properties: Does verification leak info?",
    "Random Oracle Assumption: Could structured input break RO?",
    "Curve25519 vs BLS12-381: Performance/security tradeoff?",
    "Pairing Performance Impact: Can slow verification harm UX/security?",
    "Multi-Pairing Optimization: Could optimizations introduce errors?",
    "Cryptographic Constants: Any incorrect hardcoded constants?",

    # VIII. Integration with VDRF and Protocol Security (Questions 141–150)
    "VDRF Email Privacy: Could hash-to-curve timing leak email info?",
    "VDRF Threshold Bypass: Could weak pairing checks bypass thresholds?",
    "VDRF Output Determinism: Could non-determinism break output consistency?",
    "VDRF Share Binding: Are shares bound to their instance?",
    "VDRF Commitment Malleability: Can attackers tamper with commitments?",
    "Pedersen Commitment Soundness: Could generators leak discrete log relation?",
    "Backup Commitment Verification: Does pairing ensure commitment soundness?",
    "Email Certificate Replay: Could old certs be replayed?",
    "Guardian Approval Cryptography: Could serialization issues forged signatures?",
    "Cross-Module Cryptographic Consistency: Could inconsistent primitive use introduce vulnerabilities?",

    # I. Module Visibility & Access Control (1–20)
    "Internal Module Exposure via Re-exports: Could the pub(crate) visibility restriction on commitments, curve, pairing, pke, poly, sss, and symmetric modules be bypassed through indirect re-exports in the public modules (email_cert, hash, sig, vdrf), allowing external crates to access internal cryptographic primitives that should remain hidden? mod.rs:14-27",
    "Accidental Public Exposure of Internal Types: Do any of the re-exported types (EmailCert, EmailCertToken, EmailCertificate, hash, kdf, kdfn, Signature, Vdrf, etc.) expose internal types from pub(crate) modules in their public API signatures, potentially leaking implementation details? mod.rs:29-33",
    "Symmetric Module Access: Could unauthorized access to the internal symmetric module's AEAD implementation allow attackers to bypass key-committing properties or synthetic nonce generation used in backup encryption, violating the invariant that only account owners can decrypt backups? mod.rs:21",
    "PKE Module Encapsulation: Does the pub(crate) restriction on the pke module prevent malicious guardians from directly accessing threshold decryption internals, or could they exploit public APIs to decrypt backup shares without proper authorization checks? mod.rs:18",
    "SSS Module Direct Access: Could direct access to the internal sss (Shamir Secret Sharing) module by a compromised off-chain node allow manipulation of share generation or recovery, enabling reconstruction with fewer than threshold t shares? mod.rs:20",
    "Commitments Module Privacy: If the internal commitments module implementing Pedersen commitments were accessible, could an attacker extract randomness from commitment openings to break the binding property, allowing backup ciphertext mauling? mod.rs:15",
    "Pairing Module Exposure: Could exposure of the pairing module's BLS12-381 implementation details allow attackers to craft invalid pairing equations that bypass VDRF evaluation verification, breaking email-to-account anonymity? mod.rs:17",
    "Polynomial Module Misuse: Could unauthorized access to the poly module's Lagrange interpolation functions enable attackers to forge shares that pass verification but produce incorrect secrets during reconstruction? mod.rs:19",
    "Curve Type Aliases Leakage: Does the curve module's re-export of pairing types as public interfaces create opportunities for type confusion attacks where G1 and G2 points are swapped? mod.rs:16",
    "Cross-Module Type Confusion: Could attackers exploit the fact that multiple modules (curve, pairing, commitments, vdrf) use the same underlying BLS12-381 types to create type confusion between commitments and VDRF evaluations? mod.rs:14-27",
    "Module Import Order Dependencies: Does the order of module declarations create initialization dependencies that could be exploited if modules are imported in unexpected order, causing cryptographic primitives to use uninitialized state? mod.rs:14-27",
    "Re-export Completeness: Are there critical cryptographic types or functions in the internal modules that should be re-exported but aren't, forcing higher-level code to use unsafe workarounds that bypass security checks? mod.rs:29-33",
    "Public API Surface Minimization: Does the current re-export strategy expose more cryptographic primitives than necessary for the protocol's security model, increasing the attack surface for malicious guardians or compromised nodes? mod.rs:29-33",
    "Internal Module Circular Dependencies: Could circular dependencies between internal modules (e.g., symmetric depending on pke, which depends on symmetric) create opportunities for attackers to exploit initialization order to bypass encryption? mod.rs:14-21",
    "Signature Module Isolation: Does the public sig module properly isolate signing operations from verification operations to prevent a malicious guardian from extracting signing keys through verification API abuse? mod.rs:26",
    "Hash Module Domain Separation: Could the public hash module's re-exported functions be used without proper domain separation tags, allowing attackers to create hash collisions across different contexts (signatures vs commitments)? mod.rs:25",
    "VDRF Module State Isolation: Does the public vdrf module properly protect VDRF secret key shares from being accessed or modified by malicious nodes during evaluation operations? mod.rs:27",
    "Email Certificate Module Trust Boundary: Could the public email_cert module's re-exports allow attackers to forge email certificates by directly accessing underlying signature primitives without going through Swafe-io's trusted issuance? mod.rs:24",
    "Module Visibility Inconsistency: Are there inconsistencies in visibility modifiers across the crypto module that could allow attackers to access sensitive functions through re-exported trait implementations? mod.rs:14-27",
    "Test-Only Exports: Could test-only functions or types accidentally be included in the public or pub(crate) exports, allowing attackers to use deterministic test RNGs or bypass security checks in production? mod.rs:14-33",

    # II. BINCODE_CONFIG Definition & Usage (21–35)
    "BINCODE_CONFIG Inconsistency: The BINCODE_CONFIG constant is defined but unused in this file, while a duplicate definition exists in lib/src/encode.rs. Could this inconsistency lead to different serialization formats being used across modules, breaking deterministic encoding required for signatures and hashes? mod.rs:12",
    "Configuration Divergence: If BINCODE_CONFIG in lib/src/crypto/mod.rs differs from the one in lib/src/encode.rs, could this cause tagged values to serialize differently when hashed versus when stored, allowing signature forgery? mod.rs:12",
    "Hash Module Direct Usage: The hash module directly imports BINCODE_CONFIG from its own scope but uses it for serializing IKM in KDF functions. Could inconsistent configuration between modules lead to different KDF outputs for the same input? mod.rs:12",
    "Configuration Mutability: Is the BINCODE_CONFIG constant truly immutable, or could it be modified at runtime through unsafe code, allowing attackers to change serialization behavior mid-execution to forge signatures? mod.rs:12",
    "Variable-Length Encoding: Does the standard() bincode configuration use variable-length encoding for integers? Could this allow attackers to craft values that serialize to the same byte representation but have different semantic meanings? mod.rs:12",
    "Endianness Consistency: Does BINCODE_CONFIG enforce consistent endianness across platforms? Could cross-platform serialization differences allow attackers to create valid signatures on one platform that fail verification on another? mod.rs:12",
    "Configuration Version Locking: Is the bincode configuration version locked? Could future bincode updates change serialization format, causing old signatures or commitments to become invalid? mod.rs:12",
    "Unused Constant Attack Surface: Since BINCODE_CONFIG is defined but unused in this file, could its presence mislead developers into using it instead of the correct configuration from encode.rs, introducing serialization bugs? mod.rs:12",
    "Tagged Encoding Consistency: Do all Tagged implementations use the same bincode configuration when calling .encode()? Could mixing configurations break domain separation and allow type confusion attacks? mod.rs:12",
    "Serialization Size Attacks: Does the bincode configuration limit maximum serialization size? Could attackers craft malicious structures that consume excessive memory during serialization? mod.rs:12",
    "Float Serialization Determinism: If any cryptographic structures contain floating-point values, does BINCODE_CONFIG handle them deterministically? Could NaN or infinity values break signature verification? mod.rs:12",
    "String Encoding Format: Does BINCODE_CONFIG enforce UTF-8 validation for strings? Could invalid UTF-8 in email addresses or node IDs cause panics or bypass validation checks? mod.rs:12",
    "Struct Field Ordering: Does bincode serialize struct fields in declaration order? Could field reordering in future versions break backward compatibility for stored ciphertexts or shares? mod.rs:12",
    "Option Encoding Ambiguity: How does BINCODE_CONFIG encode Option<T> types? Could Some(None) and None serialize to the same bytes, causing confusion in guardian share storage? mod.rs:12",
    "Trailing Data Handling: Does bincode reject or ignore trailing data after deserialization? Could attackers append malicious data to signatures or ciphertexts that gets processed later? mod.rs:12",

    # III. Cryptographic Primitive Selection & Security (36–55)
    "BLS12-381 Curve Choice: The module uses BLS12-381 throughout instead of secp256r1 mentioned in the specification. Does this curve choice affect security assumptions for VDRF threshold properties or pairing-based operations? mod.rs:14-27",
    "VDRF Threshold Correctness: Do the re-exported VDRF types (Vdrf, VdrfEvaluation, VdrfPublicKey, VdrfSecretKeyShare) enforce that exactly t shares are needed for evaluation? Could an attacker combine fewer shares to break email anonymity? mod.rs:33",
    "Signature Scheme Security: Does the re-exported Signature type use Schnorr signatures over BLS12-381? Could this choice introduce vulnerabilities related to pairing-friendly curve properties that don't exist in ECDSA? mod.rs:32",
    "Hash Function Collision Resistance: The re-exported hash function uses SHA3-256. Is this sufficient for collision resistance in scenarios where guardians could grind for hash collisions to create duplicate backup IDs? mod.rs:31",
    "KDF Security Strength: Do the re-exported kdf and kdfn functions provide sufficient key stretching? Could weak KDF parameters allow attackers to brute-force derived keys from partially leaked secrets? mod.rs:31",
    "Email Certificate Cryptographic Binding: How do the re-exported email certificate types (EmailCert, EmailCertToken, EmailCertificate) cryptographically bind email addresses to user public keys? Could an attacker with two valid certificates swap bindings? mod.rs:30",
    "PKE Semantic Security: Does the internal pke module implement IND-CCA2 secure encryption? If only IND-CPA secure, could attackers perform chosen-ciphertext attacks to extract guardian shares? mod.rs:18",
    "Symmetric Encryption Authenticated: Does the internal symmetric module implement authenticated encryption (AEAD)? If not, could attackers modify backup ciphertexts without detection, causing recovery failures? mod.rs:21",
    "Commitment Hiding Property: Does the internal commitments module's Pedersen commitment implementation use statistically hiding commitments? If only computationally hiding, could future quantum computers reveal committed values? mod.rs:15",
    "Commitment Binding Property: Are Pedersen commitments in the internal module computationally binding? Could a minority of malicious guardians find collision attacks to open commitments to different values? mod.rs:15",
    "Shamir Secret Sharing Information-Theoretic Security: Does the internal sss module implement information-theoretic secure Shamir secret sharing? Could fewer than t shares leak information about the secret? mod.rs:20",
    "Polynomial Interpolation Numerical Stability: Does the internal poly module's Lagrange interpolation handle edge cases like duplicate x-coordinates? Could numerical instability allow attackers to cause incorrect secret reconstruction? mod.rs:19",
    "Pairing Non-Degeneracy: Does the internal pairing module check for degenerate pairings (identity elements)? Could attackers craft VDRF evaluations using identity points to bypass verification? mod.rs:17",
    "Hash-to-Curve Security: Do the hash-to-curve functions in the pairing module use standardized methods (RFC 9380)? Could custom hash-to-curve implementations introduce bias that breaks VDRF unpredictability? mod.rs:17",
    "Field Element Validation: Do the curve type aliases properly validate field elements? Could attackers inject invalid field elements that cause silent failures during cryptographic operations? mod.rs:16",
    "Group Element Validation: Are all group elements deserialized with subgroup checks? Could attackers provide points not in the prime-order subgroup to break VDRF security? mod.rs:14-27",
    "Randomness Source Quality: Do the cryptographic primitives use a cryptographically secure RNG? Could predictable randomness allow attackers to predict VDRF evaluations or forge signatures? mod.rs:14-27",
    "Side-Channel Resistance: Are the cryptographic implementations constant-time? Could timing attacks on signature verification or VDRF evaluation leak secret key shares to malicious guardians? mod.rs:14-27",
    "Key Generation Bias: Do key generation functions produce uniformly distributed keys? Could bias in key generation reduce the effective key space, making brute-force attacks feasible? mod.rs:14-27",
    "Cryptographic Primitive Composability: Are the chosen primitives proven secure under composition? Could interactions between VDRF, signatures, and commitments create unexpected vulnerabilities? mod.rs:14-27",

    # IV. Module Organization & Separation of Concerns (56–70)
    "Internal Module Coupling: Are the internal modules (commitments, pke, symmetric, sss) tightly coupled? Could changes to one module's implementation introduce vulnerabilities in dependent modules without obvious breakage? mod.rs:14-21",
    "Public Module Dependencies: Do public modules (email_cert, sig, vdrf) depend on internal modules in ways that could leak implementation details through error messages or timing? mod.rs:24-27",
    "Cross-Module Type Sharing: Are types from internal modules (e.g., Fr, G1Affine from pairing) used across multiple modules? Could this create opportunities for type confusion attacks? mod.rs:14-27",
    "Module Boundary Validation: Do modules validate inputs at their public API boundaries? Or could malicious data pass through one module and corrupt state in another? mod.rs:14-27",
    "Error Propagation Across Modules: When errors occur in internal modules, are they properly sanitized before propagating to public APIs? Could detailed error messages leak secrets or implementation details? mod.rs:14-27",
    "Module Initialization Order: Is there a required initialization order for modules? Could using cryptographic primitives before proper initialization cause undefined behavior? mod.rs:14-27",
    "Module State Isolation: Do modules maintain isolated state, or could operations in one module affect the state of another (e.g., global RNG state)? mod.rs:14-27",
    "Re-export Transitivity: Could transitive re-exports (public module re-exporting items from internal modules) accidentally expose internal APIs? mod.rs:29-33",
    "Module Documentation Clarity: Is the separation between internal and public modules clearly documented? Could developers accidentally use internal APIs, bypassing security checks? mod.rs:14-27",
    "Module Versioning Strategy: How are breaking changes in internal modules handled? Could version mismatches between modules cause silent failures or security vulnerabilities? mod.rs:14-27",
    "Module Feature Flags: Are any modules conditionally compiled based on feature flags? Could missing features cause fallback to insecure implementations? mod.rs:14-27",
    "Module Trait Implementations: Do modules implement common traits (e.g., Clone, Debug, Serialize) consistently? Could inconsistent implementations leak secrets through debug output? mod.rs:14-27",
    "Module Panic Safety: Are all modules panic-safe? Could panics in cryptographic operations leave sensitive data in an invalid state? mod.rs:14-27",
    "Module Memory Safety: While Rust provides memory safety, could unsafe blocks in any module introduce memory corruption that affects cryptographic operations? mod.rs:14-27",
    "Module Test Coverage: Is there sufficient integration testing across module boundaries? Could bugs in module interactions go undetected until production? mod.rs:14-27",

    # V. Re-export Security & API Design (71–85)
    "Re-export Completeness for VDRF: The file re-exports Vdrf, VdrfEvaluation, VdrfPublicKey, and VdrfSecretKeyShare, but are all necessary types exposed? Could missing types force unsafe workarounds in VDRF evaluation? mod.rs:33",
    "Hash Function Re-export Granularity: Only hash, kdf, and kdfn are re-exported from the hash module. Are other hash-related functions (like kdf_rng) intentionally hidden? Could this force developers to reimplement KDF functionality insecurely? mod.rs:31",
    "Signature Type Re-export Only: Only Signature is re-exported from the sig module, not SigningKey or VerificationKey. Could this limitation cause issues in key management or signature verification? mod.rs:32",
    "Email Certificate Type Granularity: All three email certificate types are re-exported (EmailCert, EmailCertToken, EmailCertificate). Could exposing all types allow attackers to craft certificates without going through proper issuance? mod.rs:30",
    "Missing PKE Re-exports: The pke module is internal, with no types re-exported. Could this force higher-level code to use raw encryption primitives from the symmetric module, bypassing PKE security properties? mod.rs:18",
    "Missing SSS Re-exports: The sss module is internal with no re-exports. Could this force reimplementation of secret sharing in higher-level modules, introducing bugs? mod.rs:20",
    "Missing Commitment Re-exports: The commitments module is internal. Could this prevent proper use of commitments in backup protocols, forcing insecure alternatives? mod.rs:15",
    "Re-export Type Safety: Do re-exports maintain type safety? Could casting between re-exported types and internal types bypass validation? mod.rs:29-33",
    "Re-export Documentation: Are re-exported items properly documented? Could lack of documentation lead to misuse of cryptographic primitives? mod.rs:29-33",
    "Re-export Stability Guarantees: Do re-exports provide stability guarantees? Could changes to re-exported types break compatibility with stored ciphertexts or shares? mod.rs:29-33",
    "Re-export Trait Bounds: Do re-exported types properly constrain trait bounds? Could missing bounds allow insecure type instantiations? mod.rs:29-33",
    "Re-export Lifetime Parameters: If re-exported types have lifetime parameters, are they properly constrained? Could lifetime issues allow use-after-free of cryptographic material? mod.rs:29-33",
    "Re-export Const Generics: Do re-exported types use const generics (e.g., array sizes)? Could incorrect generic parameters cause buffer overflows? mod.rs:29-33",
    "Re-export Visibility Consistency: Are visibility modifiers consistent across similar items? Could inconsistent visibility confuse developers and lead to security bugs? mod.rs:29-33",
    "Re-export Naming Conflicts: Could re-exported items conflict with names in dependent crates? Could naming conflicts lead to using wrong cryptographic primitives? mod.rs:29-33",

    # VI. Integration with Higher-Level Modules (86–105)
    "Account Module Integration: How does the account module use re-exported crypto types? Could improper integration allow unauthorized account recovery by malicious guardians? mod.rs:29-33",
    "Backup Module Secret Handling: Does the backup module properly use symmetric and pke internal modules for encryption? Could direct access bypass key-committing AEAD properties? mod.rs:18-21",
    "Association Module VDRF Usage: Does the association module correctly use re-exported VDRF types to maintain email anonymity? Could misuse leak email-to-account associations? mod.rs:33",
    "Contract Module Signature Verification: Do smart contract endpoints properly use re-exported signature types for authentication? Could signature verification bypass allow unauthorized state changes? mod.rs:32",
    "API Module Email Certificate Validation: Does the API module correctly validate email certificates using re-exported types? Could certificate validation errors allow unauthorized email-to-account associations? mod.rs:30",
    "Cross-Module Key Management: How are cryptographic keys passed between modules? Could key material leak through intermediate modules? mod.rs:29-33",
    "Cross-Module Error Handling: When cryptographic operations fail, how are errors reported to higher-level modules? Could error messages leak sensitive information? mod.rs:14-27",
    "Cross-Module State Synchronization: If multiple modules maintain cryptographic state, how is synchronization handled? Could race conditions cause state inconsistencies? mod.rs:14-27",
    "Cross-Module Type Conversion: How are types converted when passing between crypto and higher-level modules? Could unsafe conversions bypass validation? mod.rs:29-33",
    "Cross-Module Lifetime Management: How are lifetimes of cryptographic objects managed across module boundaries? Could premature drops cause use-after-free? mod.rs:29-33",
    "Contract Storage Integration: How do cryptographic types serialize for contract storage? Could storage format mismatches cause deserialization failures? mod.rs:12",
    "API JSON Serialization: How do cryptographic types serialize for API JSON responses? Could JSON serialization leak binary data or fail to round-trip? mod.rs:29-33",
    "HTTP Endpoint Authentication: Do HTTP endpoints use re-exported signature types for request authentication? Could authentication bypass allow unauthorized operations? mod.rs:32",
    "Off-Chain Node Communication: How do off-chain nodes exchange cryptographic material? Could network-level attacks intercept or modify VDRF shares? mod.rs:33",
    "Guardian Share Distribution: How are guardian shares distributed using crypto primitives? Could distribution protocol weaknesses allow share interception? mod.rs:20",
    "Recovery Protocol Cryptography: How does the recovery protocol use re-exported types for guardian approval? Could cryptographic weaknesses allow unauthorized recovery? mod.rs:29-33",
    "Backup Reconstruction Cryptography: How are backup shares combined using SSS primitives? Could reconstruction with wrong shares cause silent failures? mod.rs:20",
    "Email-Account Binding Cryptography: How does VDRF ensure email-to-account binding is unique? Could VDRF collisions allow multiple accounts per email? mod.rs:33",
    "Threshold Guardian Approval: How does the protocol enforce threshold t guardian approvals using cryptographic primitives? Could threshold bypass allow unauthorized recovery? mod.rs:20",
    "On-Chain Privacy Guarantees: How do cryptographic primitives ensure on-chain privacy? Could on-chain data analysis reveal email-account associations? mod.rs:15",

    # VII. Trust Model Enforcement (106–120)
    "Swafe-io Email Certificate Authority: Does the crypto module properly constrain email certificate issuance to Swafe-io? Could guardians or nodes forge certificates using re-exported signature types? mod.rs:30",
    "Guardian Threshold Enforcement: Do cryptographic primitives enforce that at least t guardians must participate in recovery? Could t-1 malicious guardians bypass threshold checks? mod.rs:20",
    "Honest Guardian Assumption: Does the protocol maintain security if up to t-1 guardians are malicious? Could malicious guardians exploit cryptographic primitives to forge shares? mod.rs:20",
    "Off-Chain Node Minority Corruption: If a minority of off-chain nodes are corrupted, do cryptographic primitives protect user emails and associations? mod.rs:33",
    "Off-Chain Node State Leakage: Could leaked state from minority corrupted nodes reveal secrets using cryptographic analysis? mod.rs:14-27",
    "Network Adversary Limitations: What cryptographic protections exist against network adversaries observing or modifying traffic? Could MITM attacks compromise recovery? mod.rs:29-33",
    "Unprivileged User Attack Surface: Could an unprivileged user exploit cryptographic primitives to recover another user's account? mod.rs:29-33",
    "Malicious User Certificate Forging: Could a malicious user without email access forge email certificates to associate emails to their accounts? mod.rs:30",
    "Cross-Account Interference: Could a malicious user interfere with another user's account recovery using cryptographic primitives? mod.rs:29-33",

    # === I. Domain Separation & Type Confusion Attacks (1–25) ===
    "SEPARATOR Collision Risk: Can an attacker craft two different Tagged types with identical SEPARATOR strings to cause the hash() function to produce the same hash for semantically different data, potentially enabling unauthorized account recovery by substituting email certificates with forged data structures?",
    "EmptyInfo Reuse Vulnerability: Does the EmptyInfo struct's SEPARATOR value 'v0:info-empty' uniquely distinguish it from all other protocol-level separators, or could an attacker create a malicious struct with the same separator to bypass KDF domain separation in backup reconstruction?",
    "Cross-Module Separator Collision: Are all SEPARATOR constants across the codebase systematically verified to be unique, or could collisions enable an attacker to substitute a VDRF evaluation for a backup encryption key in kdfn() calls?",
    "Tagged Trait Override Attack: Can a malicious off-chain node provide a custom implementation of Tagged with a deliberately chosen SEPARATOR that collides with legitimate types, allowing them to forge KDF-derived keys that unlock guardian-protected backups?",
    "Bincode Encoding Ambiguity: Does the encode() method in the Tagged trait guarantee injectivity for all possible Rust types, or could two different values serialize to the same byte sequence when passed to hash(), enabling signature forgery on account recovery requests?",
    "Separator String Injection: Can an attacker inject control characters or null bytes into SEPARATOR strings to cause kdf_rng() to interpret the customization string incorrectly, breaking domain separation between backup and association key derivations?",
    "Version Separator Collision: Do all versioned separators properly partition the domain space, or could a future version separator collide with older ones when serialized by bincode, enabling cross-version replay attacks?",
    "Serialization Order Dependency: Does the DomainTuple struct in encode() always serialize separator before value, or could a change in bincode version reorder fields and break domain separation?",
    "Empty Separator Vulnerability: Could an attacker register a Tagged type with an empty SEPARATOR string to cause kdf() to derive keys without proper domain separation, enabling them to decrypt backups intended for a different context?",
    "UTF-8 Encoding Attacks: Does conversion of SEPARATOR strings to bytes correctly reject non-UTF-8 sequences, preventing encoding-based separator collisions?",
    "Tagged Trait Deserialization: When deserializing Tagged values from untrusted sources, can an attacker manipulate the serialized data to cause encode() to produce a different separator than intended?",
    "Multi-Context KDF Misuse: Are callers of kdf() properly segregated by context, or could an attacker reuse IKM from one context as the val parameter in another, breaking cryptographic independence?",
    "Separator Length Extension: Does KMAC256’s customization string handling prevent length-extension attacks on separators, or can an attacker append data to a separator and derive unauthorized keys?",
    "Type Confusion via Generics: Can generic parameters in kdf() be exploited by passing types with identical serializations but different semantics, enabling cross-context key derivation?",
    "Separator Namespace Pollution: Is there a global naming convention for SEPARATOR values, or could accidental reuse enable cross-module attacks where malicious guardians decrypt backup ciphertexts?",
    "Hash Output Truncation: Does the 32-byte output of hash() provide sufficient collision resistance for all protocol uses, or could birthday-bound collisions enable forged email certificates?",
    "Customization String Encoding: Does kdf_rng() enforce a single encoding for customization strings, preventing different encodings from producing separator collisions?",
    "Nested Tagged Structures: Does encode() properly nest separators of Tagged subfields, preventing flattening attacks that bypass domain separation?",
    "Separator Prefix Attacks: Are SEPARATOR strings designed to prevent prefix-matching attacks where similar strings produce same customization prefixes?",
    "Bincode Configuration Consistency: Does the bincode configuration used in kdf_rng() match encode() to avoid nondeterministic KDF outputs?",
    "Tagged Trait Orphan Rules: Can external crates implement Tagged for std types, creating collision risks for domain separation?",
    "Separator Case Sensitivity: Does KMAC256 treat customization strings case-sensitively, preventing 'v0:backup-key' and 'V0:BACKUP-KEY' collisions?",
    "Zero-Length Separator Handling: Does kdf_rng() handle zero-length separators correctly without switching modes or producing unstable keys?",
    "Separator Whitespace Normalization: Could whitespace variations in separators fragment domains or allow bypass attacks?",
    "Tagged Trait Default Implementation: Could a weak default Tagged implementation be accidentally used, enabling predictable KDF outputs?",

    # === II. KDF Security & Key Derivation (26–55) ===
    "KMAC256 Weak Key Handling: Does kdf_rng() properly handle low-entropy IKM values, or could weak passwords produce brute-forceable keys?",
    "IKM Serialization Integrity: Can malicious serialization cause collisions between different IKM values, breaking guardian threshold security?",
    "Output Length Validation: Does kdf() enforce secure output sizes, or could a caller request dangerously short keys?",
    "KDF Output Reuse: Are KDF outputs guaranteed unique across contexts, preventing linkability of encrypted backups?",
    "KMAC256 Implementation Backdoors: Could a supply-chain compromise of sha3_kmac produce predictable outputs?",
    "IKM Zero-Byte Handling: Does the KDF reject all-zero IKM, preventing predictable keys?",
    "XofReader State Leakage: Could internal state of XofReader leak via memory dumps, enabling RNG prediction?",
    "KDF Determinism Across Platforms: Are KDF outputs identical across architectures, preventing cross-platform inconsistency?",
    "Output Buffer Aliasing: Could overlapping output buffers cause undefined behavior or predictable KDF outputs?",
    "Customization String Length: Do very long separators cause truncation or collisions in KMAC256?",
    "Fixed-Size KDF Constant-Time: Does kdfn() run in constant time, preventing timing leaks?",
    "IKM Type Confusion: Can serialization of non-standard types (e.g., NaN floats) break determinism?",
    "XofReader Read Errors: Could silent read errors cause weak randomness?",
    "KDF Context Binding: Is IKM bound to account and email context, preventing cross-account derivation?",
    "KMAC Key Commitment: Does the construction prevent two IKM values from producing same output?",
    "Output Length Overflow: Could huge output sizes cause memory exhaustion?",
    "IKM Deserialization Attacks: Could malicious bincode data cause code execution?",
    "XOF Mode Security: Is arbitrary-length XOF extraction secure?",
    "KDF Salt Absence: Does separator uniqueness prevent rainbow-table attacks?",
    "IKM Length Validation: Are tiny IKMs rejected as too weak?",
    "Output Buffer Initialization: Are output buffers zeroed before writing to avoid leaks?",
    "KMAC Finalize Idempotence: Can XOF readers be reused safely?",
    "KDF Version Migration: Could version confusion cause the use of weaker KDF variants?",
    "IKM Padding Oracle: Does KDF serialization leak structure via timing?",
    "Output Distribution Uniformity: Is KDF output uniformly random?",
    "XofRng CryptoRng Trait: Does XofRng actually guarantee cryptographic randomness?",
    "KDF Composition Attacks: Is using one KDF output as another’s IKM secure?",
    "KMAC Absorb Phase: Can absorb be skipped due to malformed input?",
    "Output Length Side-Channels: Do memory access patterns leak output length?",
    "IKM Sanitization: Is IKM securely zeroed after use?",

    # === III. Hash Function Security (56–75) ===
    "SHA3-256 Collision Resistance: Is SHA3-256 strong enough for all signature uses?",
    "Preimage Attack on Commitments: Could preimage weaknesses reveal email bindings?",
    "Second Preimage Resistance: Can a recovery request be substituted with another preimage?",
    "Hash Output Truncation Safety: Does SHA3-256 avoid length-extension attacks?",
    "Tagged Encoding Preimage: Can two Tagged values encode identically?",
    "Hash Function Malleability: Can input mutation preserve hash validity?",
    "SHA3-256 Finalization: Does finalize() properly pad inputs?",
    "Hash Input Size Limits: Do huge inputs cause memory exhaustion?",
    "Differential Cryptanalysis: Are known SHA3-256 differential attacks relevant?",
    "Hash Composition Security: Does hashing a hash weaken security?",
    "Multi-Collision Attacks: Could an attacker produce many colliding email hashes?",
    "Hash Rate Limiting: Can attackers DoS by flooding hash operations?",
    "Tagged Encoding Canonicalization: Do identical values always encode identically?",
    "Hash Digest Comparison: Is equality check constant-time?",
    "Partial Hash Collisions: Can prefix collisions bypass weak comparisons?",
    "Hash Algorithm Agility: Can the system migrate to new hash algorithms?",
    "Tagged Value Mutation: Can post-hash mutation cause verification bypass?",
    "Hash Output Encoding: Can base64 or hex collisions occur?",
    "Multi-Block Hash Security: Does SHA3-256 remain secure for huge encodings?",
    "Hash Precomputation Tables: Can attackers precompute common email hashes?",

    # === IV. RNG Derandomization & XofRng Security (76–100) ===
    "XofRng Determinism Exploitation: Can deterministic RNG output be predicted if IKM is known?",
    "XofRng State Cloning: Can RNG state be duplicated to predict outputs?",
    "RngCore Implementation Correctness: Are repeated patterns possible?",
    "try_fill_bytes Error Suppression: Do silent errors weaken randomness?",
    "next_u64 Endianness: Are cross-platform RNG outputs consistent?",
    "next_u32 Truncation: Does truncation reduce entropy?",
    "XofRng Seek Operations: Can RNG streams be rewound or desynchronized?",
    "RNG Output Bias: Is XOF output statistically uniform?",
    "XofRng Re-initialization: Do repeated calls with same inputs create replayable nonces?",
    "fill_bytes Buffer Overrun: Can malformed buffers cause memory corruption?",
    "RNG State Serialization: Can an attacker save/restore RNG state?",
    "XofReader Depletion: Does XOF ever run out of bytes, producing zeros?",
    "next_u64/u32 Consistency: Do combination calls fragment state?",
    "CryptoRng Trait Misuse: Is XofRng misused under assumption of true randomness?",
    "RNG Fork Attacks: Do concurrent reads interleave outputs?",
    "XofRng Drop Safety: Is internal state zeroed on drop?",
    "Deterministic RNG Audit Trail: Does deterministic RNG allow forensic reconstruction?",
    "RNG Period Length: Could XOF reach a repeating cycle?",
    "XofRng Synchronization: Do guardians derive incompatible shares due to misaligned reads?",
    "RNG Initialization Vector: Is the RNG IV unique or reused?",
    "next_u64 Bit Alignment: Are reads atomic and constant-time?",
    "XofRng Clone Semantics: Would cloning duplicate state?",
    "RNG Output Verification: Does the system check for zero/low-entropy outputs?",
    "fill_bytes Partial Writes: Could partial writes leave uninitialized bytes?",
    "XofRng Memory Footprint: Can attackers cause memory exhaustion?",

    # === V. Integration with Symmetric Encryption, PKE, VDRF (101–125) ===
    "Symmetric Encryption Nonce Derivation: Does KDF-derived nonce avoid reuse?",
    "PKE Shared Secret KDF: Are shared secrets validated for low-order points?",
    "VDRF Output Derivation: Could manipulated evaluations produce predictable KDF outputs?",
    "Backup Metadata Key Derivation: Are metadata/data keys separated by domain?",
    "Association Recovery Key: Is account/email context bound in KDF?",
    "Account MSK Decryption Key: Is MSK tied to recovery identity?",
    "Symmetric MAC Derivation: Are MAC/encryption keys domain-separated?",
    "PKE Encapsulation Key: Is public key included in KDF?",
    "VDRF Proof Verification: Can hash collisions enable fake VRF proofs?",
    "Backup Share Encryption: Is pad reuse possible?",
    "Association Anonymity: Can timing of KDF reveal targeted emails?",
    "Symmetric Pad Length: Does pad generation leak plaintext length?",
    "PKE Hybrid Encryption: Are ephemeral keys separated from long-term keys?",
    "VDRF Threshold Composition: Does each evaluation use distinct separators?",
    "Backup Versioning: Is version included in KDF inputs?",
    "Association Secret Share Distribution: Could deterministic RNG leak distribution patterns?",
    "Account Secret Lifecycle: Are old KDF keys securely erased?",
    "Symmetric Cipher Agility: Will algorithm migration remain secure?",
    "PKE Public Key Binding: Is recipient public key bound in shared secret derivation?",
    "VDRF Input Validation: Are malicious inputs prevented in evaluation → KDF pipeline?",
    "Backup Threshold Enforcement: Is threshold cryptographically enforced in keys?",
    "Association Encapsulation: Does KDF bind secrets to recipients?",
    "Account Recovery Replay: Can attackers replay old KDF inputs?",
    "Symmetric Ciphertext Integrity: Are authentication keys distinct from encryption keys?",
    "PKE/VDRF/Backup Composition: Are domain separators disjoint across all layers?",

    # === VI. Serialization, Encoding & Error Handling (126–140) ===
    "Bincode Serialization Panics: Can malicious inputs cause panic in kdf_rng()?",
    "Tagged Encode Panics: Can an attacker cause panics in encode()?",
    "Serialization Format Versioning: Could bincode upgrades break encoding determinism?",
    "Deserialization of KDF Outputs: Could deserialization corruption bypass threshold checks?",
    "Encode Buffer Allocation: Can huge Tagged values exhaust memory?",
    "Serialization Type Safety: Does bincode enforce strict type matching?",
    "Unwrap Safety Audit: Could unwrap() calls panic with adversarial inputs?",
    "Bincode Schema Evolution: Could struct changes break existing backups?",
    "Serialization Side-Channel: Does serialization leak timing info?",
    "Error Message Leakage: Could detailed errors leak sensitive metadata?",
    "Serialization Canonicalization: Do identical values always encode canonically?",
    "Bincode Integer Encoding: Could varint ambiguities create collisions?",
    "Encode Buffer Reuse: Could buffer reuse leak residual bytes?",
    "Serialization Endianness: Are big-endian systems supported safely?",
    "Unwrap Panic Recovery: Do panics leave guardian state inconsistent?",

    # === VII. Side-Channels & Constant-Time Security (141–150) ===
    "Hash Computation Timing: Do variable input sizes leak timing information?",
    "KDF Timing Side-Channels: Does kdf() run in constant time?",
    "XofRng Timing Leakage: Could fill_bytes() leak RNG state via timing?",
    "Hash Output Comparison: Are digest comparisons constant-time?",
    "Branch Prediction Attacks: Can speculative execution leak secrets in kdf()?",
    "Memory Access Patterns: Do memory accesses leak data-dependent structure?",
    "Cache-Timing on Domain Separators: Can attackers infer operation type via separator lookup timing?",
    "Constant-Time Nonce Generation: Is nonce derivation constant-time?",
    "Side-Channel Resistant XOR: Is XOR encryption implemented in constant time?",
    "Zeroization of Sensitive Buffers: Are all sensitive buffers securely zeroed after use?"


]


def question_format(question: str) -> str:
    prompt = f"""
You are a Web3 Security Researcher. Your task is to analyze the Swafe protocol codebase (which includes a Rust library, Partisia smart contracts, and REST API endpoints) with a laser focus on this single question:

**Security Question (scope for this run):** {question}

Your mission:
- Use the security question as your starting point. Investigate all code paths, system components, and protocol logic related to that question and look for one concrete, exploitable vulnerability. Accept the premise of the question and investigate thoroughly.
- Explore a wide range of realistic input scenarios and edge cases. Test extreme and boundary values across all relevant modules (e.g. cryptographic primitives, account/backup flows, API inputs, guardian thresholds). Use messages and transactions that an untrusted client or node could actually send on-chain or via the REST API. Consider malformed email certificates, forged secret shares, threshold manipulation, or replaying outdated messages.
- Work through complete flows end‑to‑end: simulate how an unprivileged user’s request (e.g. a recovery or backup operation) propagates through the API, contracts, and core library, how guardians and off‑chain nodes process it, and how on‑chain/off‑chain state evolves. Pay special attention to key invariants: only the account owner may request backup reconstruction or account recovery; the specified guardian threshold must be respected; email ↔ account associations must remain unique. Track how data moves across components and identify any step where an invariant might break or an unexpected condition could be exploited.
- Consider Swafe’s trust model: Swafe‑io, guardians, and off‑chain nodes are trusted roles Do not assume they behave maliciously; instead, look for subtle logic errors or unintended behaviours that could be triggered by an unprivileged user or adversarial environment. Issues requiring misbehaving trusted roles or misconfiguration are out of scope.
- If you find a vulnerability, produce a report in the exact format below. If **no** valid vulnerability emerges, clearly state: **“#NoVulnerability found for this question.”** (with the hashtag, exactly as shown, and nothing else).
- Do not invent or repeat findings you’ve reported for this question in previous runs. Stay strictly within the scope defined by the security question and the audit’s scope list (only the files enumerated in `scope.txt` are eligible). Avoid discussing unrelated issues or best practices not tied to this question.
- Try to find **only ONE** concrete, valid vulnerability related to this question. Focus your investigation deeply on this potential issue and ignore other tangential problems.
- Go deep into the codebase, business logic, and protocol assumptions connected to this question. Examine how different modules interact (core cryptography, backup and recovery logic, guardian approval flows, API endpoints, Partisia contract storage and HTTP wrappers) and whether trust assumptions hold. Do not just surface‑level scan; reason about the system’s behaviour under adverse conditions relevant to the question.

Important rules:
- The vulnerability must be actually triggerable in a real network or on‑chain/off‑chain context. Purely theoretical issues are only valid if you can explain precisely how they would manifest in practice (e.g. unauthorized account recovery leading to loss of keys/funds, unauthorized backup reconstruction, permanent freezing of secrets, denial‑of‑service on the API or contract affecting users, etc.).
- Be 100% certain the issue is exploitable. If you cannot concretely demonstrate an exploit scenario, report **“#NoVulnerability found for this question.”**
- Focus on external attack surfaces (non‑privileged actors) first. For example, consider actions by an unauthenticated network client, a normal user request, or a public API call. If the relevant functionality is restricted to trusted roles (e.g. Swafe‑io, guardian management), do not assume those roles act maliciously; instead, scrutinize for subtle logic errors or unintended behaviours that could occur accidentally.
- The following types of issues are **out of scope** and should NOT be reported as vulnerabilities:
  * Gas/fee optimizations, micro‑optimizations, or stylistic/code clarity improvements.
  * Incorrect log/event outputs or REST responses that do not affect protocol state or security.
  * Missing input validation or edge‑case checks that only prevent user mistakes (assume honest users/guardians follow expected procedures).
  * Issues that require misconfiguration or intentional misuse by trusted roles (admins/guardians/off‑chain nodes are trusted; focus on vulnerabilities that an attacker without special privileges can exploit).
  * API denial‑of‑service attacks that do not lead to unauthorized recovery or compromise (per README, DoS on HTTP endpoints is only QA).
  * Out‑of‑scope modules or files (e.g. CLI components).
  * Best‑practice recommendations, feature requests, or low‑impact bugs that do not pose a security risk.
  * Attacks requiring control of privileged keys/addresses, leaked private keys, or off‑chain conditions outside the protocol’s control (e.g. 51% attacks on underlying consensus).

- Check all places in the codebase where the relevant logic might reside (Rust library functions, Partisia smart contracts, API handlers, cryptographic utilities, storage structures, etc.).
- Ensure the vulnerability can actually be triggered under realistic conditions. If an issue only occurs under extremely contrived scenarios or requires numerous unlikely prerequisites, treat it as not a valid finding.

**In‑Scope Impact (for the Swafe contest)** – valid vulnerabilities must lead to at least one of the following consequences; anything else is invalid:
* Direct loss of funds or compromise of private keys/secrets.
* Permanent freezing of secrets or accounts (requiring a hard fork or intervention to fix).
* Critical API/contract outage preventing account recovery or backup reconstruction for ≥25% of users.
* Unintended permanent chain split or contract state corruption requiring a hard fork.
* Network (Partisia) unable to confirm new transactions (total network shutdown).
* Increase in network processing node resource consumption by ≥30% without brute‑force.
* Shutdown of ≥30% of processing nodes without brute force (medium).
* A bug in the Swafe/Partisia integration that results in unintended smart contract behaviour.
* Temporary freezing of transactions or recovery operations by delaying one block by ≥500% of average block time (medium).
* Processing transactions beyond set parameters (e.g. bypassing mempool limits).
* Shutdown of ≥10% but <30% of processing nodes without brute force (low).
* Modification of transaction or recovery fees outside design parameters.

Audit Report

## Title
[Clear and specific name of the vulnerability related to the question]

## Summary
A short, direct summary of the issue and where it occurs in the codebase.

## Impact
Categorize the severity as Low, Medium, or High.

## Finding Description
Explain the vulnerability step‑by‑step:
- **Location:** Identify the specific module, file, and line (or function) where the issue occurs.
- **Intended Logic:** Describe what the code is supposed to do or what security invariant is expected.
- **Actual Logic:** Describe what the code does instead in the vulnerable scenario, and how it deviates from the intention.
- **Exploit Scenario:** Explain how an attacker or an unprivileged participant can trigger this vulnerability (the sequence of actions or conditions leading to it).
- **Security Failure:** State which security property is broken (e.g. unauthorized recovery, invariant violation, privacy leak, denial‑of‑service) and how the system fails as a result.

## Impact Explanation
Explain the concrete impact of this vulnerability:
- What assets, secrets, or processes are affected (e.g. funds, master secret keys, account ownership)?
- How severe is the damage (e.g. keys stolen or permanently locked, users locked out, network nodes crash or halt)?
- Why does this matter for the security or reliability of the system?

## Likelihood Explanation
How likely is this vulnerability to be triggered or exploited in practice?
- Who can trigger it (any network participant or only under specific conditions)?
- What conditions or timing are required (normal operation or rare circumstances)?
- How frequently could it occur or be exploited if not fixed?

## Recommendation
Provide a concise fix or mitigation strategy. Suggest specific changes (e.g. adding a check, modifying logic) or design adjustments to prevent the vulnerability.

## Proof of Concept
Provide a minimal, reproducible proof‑of‑concept (PoC) demonstrating the issue using the project’s test framework:
- Specify the **file name and test function** where this PoC code should be added (or a new test file name, if appropriate) within the repository’s tests.
- Setup: Describe any necessary initial state or configuration (e.g. initialize account and backups, register guardians, issue email certificate).
- Trigger: Execute the actions that trigger the vulnerability (e.g. send a crafted recovery request or forged secret share, call a function with specific inputs).
- Observation: Explain what the test observes (e.g. an invariant violation, a panic/crash, unauthorized recovery) that confirms the bug. The test should fail (or detect the issue) on the vulnerable code.

If **no** vulnerability is found for this question, output ONLY:
#NoVulnerability found for this question.
"""
    return prompt

def validation_format(report: str) -> str:
    prompt = f"""
You are a Senior Web3 Security Researcher **Judge**. Your task is **validation** of a single security question/claim. The string below is the security **report/claim** to investigate and validate (against the Swafe codebase):

SECURITY QUESTION / CLAIM (scope for this run):
{report}

================================================================================================================================================
Your mission:

1) **Treat the claim as the starting point** — Do not discuss the report’s style or who wrote it. Focus solely on the technical claim. Investigate whether the underlying technical claim is a valid, exploitable vulnerability in Swafe’s codebase (library, contracts, API). Use the code, tests, documentation, and contest scope to confirm or refute the claim.

2) **Search & Cross‑Check**:
   - Inspect all relevant code paths, functions, and modules related to the claim across Swafe’s Rust library, Partisia contracts, and API handlers. Trace the execution flow from any external entry point (REST call, smart‑contract HTTP endpoint, off‑chain node message, etc.) to the point of the alleged vulnerability. Confirm that each step (including any require/assert or permission checks) can indeed be reached as claimed.
   - Cross‑check the invariants and trust assumptions described in the README: only the account owner may request reconstruction or recovery; guardian threshold must be respected; email ↔ account associations are unique. Verify that the claim truly violates one of these invariants without relying on trusted roles misbehaving.
   - Consult the scope file to ensure the affected code is in‑scope. Anything outside the listed files (e.g., CLI) is out of scope and invalid. Search project documentation, previous audits or knowledge bases for similar issues and note if the behaviour is documented, intentional, or fixed. If it’s a known issue listed in the README (e.g. API DoS is QA), it is ineligible.

3) **Platform Acceptance Rules (Code4rena)** — The claim is **invalid** and must be rejected (output `#NoVulnerability found for this question.`) if any of the following apply:
   - The exploit requires a misconfiguration or malicious action by a trusted role (Swafe‑io, guardian, or off‑chain node). Trusted roles are assumed honest; we only consider subtle bugs where even a trusted actor cannot prevent the issue.
   - The issue is purely about efficiency, gas/fee optimization, or code style with no security impact.
   - There is no feasible on‑chain/off‑chain input that can trigger the issue (i.e., it cannot occur through any realistic user request or network message).
   - The scenario relies on stolen private keys, majority collusion, 51% attacks, or other off‑protocol manipulations; these are out of scope.
   - The code already prevents or handles the scenario (the claim misreads the code or overlooks existing checks).
   - The issue depends only on adversarial behaviour by out‑of‑scope components or third‑party dependencies.
   - The exact issue is a duplicate of a known issue or publicly known problem with no new dimension.
   - It only affects tests, documentation, or non‑production code, or it’s a dev feature not deployed in production.
   - The outcome is not a security risk (e.g. it only causes a revert or harmless error).

   **Swafe/Code4rena context:**
   - Only files listed in `scope.txt` are in scope ignore any claim targeting other files.
   - API denial‑of‑service attacks without unauthorized recovery or data compromise are QA only.
   - Valid impacts must align with the contest’s severity categories (direct loss of funds/secrets, permanent freezing, critical outages, etc.).

4) **Language & Test Expectations**:
   - **Rust / Partisia contracts:** Expect a Rust or Java test (using the project’s `just`/Maven setup) that reproduces the issue by calling the appropriate functions, sending transactions, or interacting with the HTTP wrapper.
   - The PoC should set up accounts, backups, guardians, and recovery thresholds as needed, then send a crafted request to trigger the bug. If the test or exploit cannot actually run and reproduce the issue, the claim fails.

5) **Minimal Validation Checklist** (all must be satisfied for a valid finding):
   1. **Confirm Flow** – Identify the entry point and path to the vulnerable code. Ensure that the input described in the claim is something an attacker can supply and that permission checks do not block it.
   2. **State Change Analysis** – Observe the key state variables or outputs before and after the exploit. Pinpoint where the expected behaviour diverges (e.g. guardian threshold bypass, unauthorized recovery).
   3. **Realistic Inputs** – Verify that the exploit uses plausible inputs within allowed ranges (e.g. valid email certificates, guardian signatures, shares) without requiring truncated or oversized values that would normally be rejected.
   4. **Impact Verification** – Confirm that the exploit has a concrete adverse effect (unauthorized account/backup recovery, permanent lockout, network halt, secret theft). A benign revert or self‑inflicted error is not a valid vulnerability.
   5. **Reproducible PoC** – A PoC test should be provided or constructed that triggers the issue in the Swafe environment. If reproduction is impossible or purely hypothetical, the claim fails.
   6. **No Special Privileges Needed** – The exploit should be possible for an unprivileged user. It should not require the attacker to be a guardian or Swafe‑io.
   7. **No Out‑of‑Scope Dependencies** – The exploit should not rely on components outside the audit scope or unrealistic assumptions.

6) The vulnerability must lead to one of the in‑scope impacts listed in the contest rules (direct fund/secret loss, critical or medium system failure, etc.). If the claimed impact falls outside these categories or cannot be triggered, it is invalid.

7) **Outcome & Response**:
   - If you confirm the claim is a **valid vulnerability** (all checks passed), output the following **Audit Report** format, ensuring clarity and completeness:
     ```
     Audit Report

     ## Title
     [Clear and specific name of the vulnerability related to the question]

     ## Summary
     Short, direct summary of the issue and where it occurs.

     ## Impact
     Low / Medium / High

     ## Finding Description
     - location: <file and line number or module name where the issue occurs>
     - intended logic: <explanation of the intended correct behavior>
     - actual logic: <explanation of the flawed behavior>
     - exploitation path: <how an attacker triggers the issue, step by step>
     - security guarantee broken: <which invariant or property is violated>

     ## Impact Explanation
     Describe the impact in terms of consequences (fund/secret loss, permanent lockout, network halt, etc.).

     ## Likelihood Explanation
     Discuss how likely this is to be encountered or exploited (who can do it, how often, conditions).

     ## Recommendation
     Suggest a fix or mitigation (e.g. additional check, logic change).

     ## Proof of Concept
     Provide a test or script (file name and function) that reproduces the issue:
     - setup (initial state or prep steps)
     - action (call/transaction that triggers the bug)
     - result (observed incorrect outcome confirming the bug)
     ```
   - If you determine **no valid vulnerability** exists (the claim fails any criterion), you **must** respond with exactly:
     ```
     #NoVulnerability found for this question.
     ```

8) **Prior Art & Intentional Behavior**:
   - Check if the behaviour is intentional or already fixed in a later version. An intentional design (e.g. API error message) is not a vulnerability unless the report shows it can be abused.
   - If the issue is publicly documented or listed in the README as known (e.g. API DoS is QA:), it is ineligible.
   - Duplicates of previously reported issues without new exploitability should be rejected.

9) **Be Strict & Objective**:
   - Do not award credit for hypothetical or negligible issues. If the only consequence is a benign revert or inconvenience, respond with `#NoVulnerability found for this question.`

================================================================================================================================================
Now perform the validation and respond with either the **Audit Report** (if the claim is valid) or **#NoVulnerability found for this question.** (if invalid), strictly following the above instructions.
"""
    return prompt
